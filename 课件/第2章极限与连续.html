<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <!--
        用户需求：响应式设计优化
        - 适配不同屏幕尺寸
        - 禁止用户缩放以保持设计一致性
        - 优化移动设备显示
    -->
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>第2章 极限与连续</title>

    <!-- MathJax 配置 - 只保留内联配置，避免冲突 -->
    <script>
        // 全局错误处理
        window.onerror = function(msg, url, line, col, error) {
            console.error('页面错误:', msg, 'at', line + ':' + col);
            return true;
        };
        
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready!');
                    });
                }
            }
        };
    </script>
    <script async id="MathJax-script" type="text/javascript"
        src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js"></script>

    <!-- Font Awesome 图标库 -->
    <link rel="stylesheet" href="../common-assets/css/fontawesome.min.css">
    <link rel="stylesheet" href="../common-assets/css/solid.min.css">

    <style>
        /* ========================================
           用户需求：高职学生友好型课件样式
           设计风格：明亮、开放、专业、简洁
           ======================================== */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'SimHei', Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            margin: 0;
            padding: 0;
            /* 优化字体渲染 */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        /* 加载指示器 */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 16px;
            color: #6b7280;
        }

        /* 幻灯片容器 */
        .slide-wrapper {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .slide {
            display: none;
            width: 100%;
            height: 100%;
            padding: 20px 30px;
            /* 预留底部空间，避免被底部导航遮挡 */
            padding-bottom: calc(84px + env(safe-area-inset-bottom));
            background: #ffffff;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .slide.active {
            display: block;
            opacity: 1;
        }

        /* 幻灯片内容布局 */
        .slide-container {
            display: grid;
            grid-template-columns: minmax(340px, 44%) 1fr;
            grid-auto-rows: 1fr;
            gap: 24px;
            height: 100%;
            max-width: 1800px;
            margin: 0 auto;
            align-items: stretch;
        }

        .slide-container .cover-page {
            grid-column: 1 / -1;
        }

        .slide-container>*:only-child {
            grid-column: 1 / -1;
        }

        /* iframe容器 - 用于嵌入式实验室页面 */
        .iframe-container {
            display: flex;
            gap: 0;
            height: 100vh;
            width: 100vw;
            position: fixed;
            top: 0;
            left: 0;
            overflow: hidden;
        }

        .iframe-container iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .left-content {
            grid-column: 1;
            min-width: 0;
            overflow-y: auto;
            padding: 16px 20px 24px 16px;
            font-size: 18px;
            line-height: 1.9;
            background:
                linear-gradient(180deg, rgba(59, 130, 246, 0.04) 0, rgba(59, 130, 246, 0.04) 1px, transparent 1px) 0 0/100% 32px,
                #ffffff;
            border-right: 1px solid #e5e7eb;
            border-radius: 8px;
        }

        /* 滚动条样式 - Webkit浏览器 */
        .left-content::-webkit-scrollbar {
            width: 8px;
        }

        .left-content::-webkit-scrollbar-track {
            background: #f3f4f6;
            border-radius: 4px;
        }

        .left-content::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 4px;
            transition: background 0.3s;
        }

        .left-content::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        /* 滚动条样式 - Firefox */
        .left-content {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e0 #f3f4f6;
        }

        .right-visual {
            grid-column: 2;
            min-width: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            position: relative;
            min-height: 0;
        }

        .right-visual canvas {
            width: 100% !important;
            height: 100% !important;
            max-width: none;
            max-height: none;
            object-fit: contain;
        }

        /* ========================================
           响应式设计优化
           用户需求：适配不同屏幕尺寸，保持良好的阅读体验
           ======================================== */

        /* 大屏幕优化 (1600px+) */
        @media (min-width: 1600px) {
            .slide-container {
                max-width: 2000px;
            }

            .left-content {
                font-size: 18px;
            }

            h1 {
                font-size: 36px;
            }

            h2 {
                font-size: 26px;
            }
        }

        /* 中等屏幕 (1200px - 1600px) - 默认样式已适配 */

        /* 小屏幕平板 (768px - 1200px) */
        @media (max-width: 1200px) {
            .slide-container {
                grid-template-columns: 1fr;
                grid-auto-rows: auto;
                gap: 20px;
                height: calc(100% - 40px);
            }

            .left-content {
                flex: 0 0 auto;
                max-height: 45%;
                font-size: 15px;
                line-height: 1.7;
                overflow-y: auto;
            }

            .right-visual {
                flex: 1;
                min-height: 350px;
                padding: 15px;
            }

            h1 {
                font-size: 28px;
                margin-bottom: 15px;
            }

            h2 {
                font-size: 22px;
                margin: 15px 0 12px 0;
            }

            h3 {
                font-size: 18px;
            }

            canvas {
                max-width: 100%;
                max-height: 100%;
            }
        }

        /* 手机横屏 (481px - 768px) */
        @media (max-width: 768px) {
            .slide {
                padding: 15px 20px;
                padding-bottom: calc(90px + env(safe-area-inset-bottom));
            }

            .slide-container {
                grid-template-columns: 1fr;
                grid-auto-rows: auto;
                gap: 15px;
                height: calc(100% - 30px);
            }

            .left-content {
                font-size: 14px;
                line-height: 1.6;
                padding-right: 10px;
                max-height: 50%;
            }

            .right-visual {
                min-height: 300px;
                padding: 10px;
            }

            h1 {
                font-size: 24px;
                margin-bottom: 12px;
                padding-left: 12px;
                border-left-width: 4px;
            }

            h2 {
                font-size: 20px;
                margin: 12px 0 10px 0;
            }

            h3 {
                font-size: 17px;
                margin: 12px 0 8px 0;
            }

            h4 {
                font-size: 15px;
            }

            p,
            ul,
            ol {
                font-size: 14px;
                line-height: 1.6;
            }

            .definition,
            .note {
                padding: 12px 0;
                padding-left: 15px;
                margin: 15px 0;
            }

            .animate-button {
                padding: 10px 18px;
                font-size: 13px;
                margin: 4px;
            }

            .nav-controls {
                bottom: 15px;
            }

            .nav-btn {
                width: 28px;
                height: 28px;
            }
        }

        /* 手机竖屏 (最大 480px) */
        @media (max-width: 480px) {
            .slide {
                padding: 10px 15px;
                padding-bottom: calc(100px + env(safe-area-inset-bottom));
            }

            .slide-container {
                gap: 10px;
                height: calc(100% - 20px);
            }

            .left-content {
                font-size: 13px;
                line-height: 1.5;
                padding-right: 8px;
                max-height: 55%;
            }

            .right-visual {
                min-height: 250px;
                padding: 8px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 10px;
                padding-left: 10px;
                border-left-width: 3px;
            }

            h2 {
                font-size: 18px;
                margin: 10px 0 8px 0;
            }

            h3 {
                font-size: 16px;
                margin: 10px 0 6px 0;
            }

            h4 {
                font-size: 14px;
                margin: 8px 0;
            }

            p,
            ul,
            ol {
                font-size: 13px;
                line-height: 1.5;
                margin: 8px 0;
            }

            ul,
            ol {
                padding-left: 20px;
            }

            li {
                margin: 4px 0;
            }

            .definition,
            .note {
                padding: 10px 0;
                padding-left: 12px;
                margin: 12px 0;
                border-left-width: 3px;
            }

            .definition strong {
                font-size: 15px;
                margin-bottom: 8px;
            }

            .animate-button {
                padding: 8px 14px;
                font-size: 12px;
                margin: 3px;
            }

            .controls {
                gap: 6px;
                margin-top: 10px;
            }

            .nav-controls {
                bottom: 10px;
                gap: 8px;
            }

            .nav-btn {
                width: 24px;
                height: 24px;
            }

            .slide-number {
                font-size: 10px;
            }

            .slide-number input {
                width: 40px;
                font-size: 10px;
            }

            input[type="number"],
            input[type="text"] {
                padding: 6px 10px;
                font-size: 12px;
            }

            .MathJax {
                font-size: 1em !important;
            }

            mjx-container {
                margin: 6px 0 !important;
            }
        }

        /* 超小屏幕 (最大 360px) */
        @media (max-width: 360px) {
            .slide {
                padding: 8px 12px;
            }

            .left-content {
                font-size: 12px;
            }

            h1 {
                font-size: 18px;
            }

            h2 {
                font-size: 16px;
            }

            h3 {
                font-size: 15px;
            }

            h4 {
                font-size: 13px;
            }

            p,
            ul,
            ol {
                font-size: 12px;
            }

            .right-visual {
                min-height: 200px;
            }
        }

        /* 横屏模式优化 */
        @media (max-height: 600px) and (orientation: landscape) {
            .slide-container {
                grid-template-columns: minmax(300px, 40%) 1fr;
            }

            .left-content {
                max-height: 100%;
                font-size: 13px;
            }

            .right-visual {
                flex: 1;
                min-height: auto;
            }

            .nav-controls {
                bottom: 8px;
            }
        }



        /* 控制按钮容器 */
        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* 标题样式 */
        h1 {
            font-size: 38px;
            color: #1f2937;
            margin-bottom: 24px;
            border-left: 6px solid #3b82f6;
            padding-left: 20px;
            line-height: 1.4;
        }

        h2 {
            font-size: 28px;
            color: #374151;
            margin: 24px 0 18px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #e5e7eb;
        }

        h3 {
            font-size: 24px;
            color: #4b5563;
            margin: 20px 0 14px 0;
            font-weight: 600;
        }

        h4 {
            font-size: 20px;
            color: #6b7280;
            margin: 16px 0 10px 0;
            font-weight: 600;
        }

        p {
            font-size: 18px;
            line-height: 1.9;
            color: #374151;
            margin: 12px 0;
        }

        ul,
        ol {
            font-size: 18px;
            line-height: 2;
            margin: 15px 0;
            padding-left: 35px;
        }

        li {
            margin: 8px 0;
        }

        /* Canvas 样式 */
        canvas {
            display: block;
            background: white;
            max-width: 100%;
            height: auto;
        }

        /* 封面页样式 */
        .cover-page {
            width: 100%;
            text-align: center;
            padding: 100px 40px;
        }

        .cover-title {
            font-size: 48px;
            margin-bottom: 40px;
            color: #1f2937;
        }

        .cover-subtitle {
            font-size: 28px;
            color: #6b7280;
            margin-bottom: 30px;
        }

        .cover-list {
            list-style: none;
            font-size: 22px;
            line-height: 2.5;
            margin-top: 30px;
            padding: 0;
        }

        /* 封面页响应式 */
        @media (max-width: 768px) {
            .cover-page {
                padding: 60px 20px;
            }

            .cover-title {
                font-size: 32px;
                margin-bottom: 30px;
            }

            .cover-subtitle {
                font-size: 22px;
                margin-bottom: 20px;
            }

            .cover-list {
                font-size: 18px;
                line-height: 2.2;
            }
        }

        @media (max-width: 480px) {
            .cover-page {
                padding: 40px 15px;
            }

            .cover-title {
                font-size: 26px;
                margin-bottom: 20px;
            }

            .cover-subtitle {
                font-size: 18px;
                margin-bottom: 15px;
            }

            .cover-list {
                font-size: 16px;
                line-height: 2;
            }
        }

        /* 定义框 - 简洁无框设计 */
        .definition {
            background: transparent;
            padding: 16px 0;
            border-left: 4px solid #3b82f6;
            padding-left: 20px;
            margin: 20px 0;
        }

        .definition strong {
            color: #1e40af;
            font-size: 18px;
            display: block;
            margin-bottom: 12px;
        }

        .definition p {
            margin: 10px 0;
            color: #374151;
        }

        /* 注意框 - 简洁无框设计 */
        .note {
            background: transparent;
            padding: 16px 0;
            border-left: 4px solid #f59e0b;
            padding-left: 20px;
            margin: 20px 0;
            font-size: 16px;
        }

        .note strong {
            color: #d97706;
            font-weight: 600;
        }

        /* 示例框 - 简洁无框设计 */
        .example {
            background: transparent;
            padding: 16px 0;
            border-left: 4px solid #8b5cf6;
            padding-left: 20px;
            margin: 20px 0;
        }

        .example h4 {
            color: #7c3aed;
            margin-bottom: 12px;
        }

        /* 数学公式容器优化 */
        .MathJax {
            font-size: 1.1em !important;
        }

        mjx-container {
            margin: 8px 0 !important;
        }

        /* 改进按钮样式 */
        .animate-button {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin: 5px;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .animate-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        .animate-button:active {
            transform: translateY(-1px);
        }

        /* 导航控制 - 极简设计 */
        .nav-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 1000;
            padding-bottom: env(safe-area-inset-bottom);
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.15);
            color: transparent;
            border: none;
            padding: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0;
            transition: all 0.2s;
            position: relative;
        }

        .nav-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-top: 2px solid rgba(0, 0, 0, 0.5);
            border-right: 2px solid rgba(0, 0, 0, 0.5);
        }

        .nav-btn:first-child::before {
            transform: translate(-40%, -50%) rotate(-135deg);
        }

        .nav-btn:last-child::before {
            transform: translate(-60%, -50%) rotate(45deg);
        }

        .nav-btn:hover {
            background: rgba(0, 0, 0, 0.25);
        }

        .nav-btn:hover::before {
            border-color: rgba(0, 0, 0, 0.7);
        }

        .slide-number {
            font-size: 11px;
            color: #9ca3af;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 0;
            opacity: 0.6;
        }

        .slide-number input {
            width: 50px;
            text-align: right;
            border: none;
            background: transparent;
            font-size: 11px;
            padding: 0 2px;
            margin: 0;
            color: #000000;
            font-weight: 700;
        }

        .slide-number input::-webkit-outer-spin-button,
        .slide-number input::-webkit-inner-spin-button {
            display: none;
        }

        .slide-number input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .slide-number input:focus {
            outline: none;
            color: #000000;
        }

        #slideNumberTotal {
            color: #9ca3af;
        }

        /* Canvas 样式（去除可视化外框效果） */
        canvas {
            display: block;
            background: white;
        }

        /* 按钮样式 */
        .animate-button {
            background: #10b981;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s;
        }

        .animate-button:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }



        /* 输入框样式 */
        input[type="number"],
        input[type="text"] {
            padding: 8px 12px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* ========================================
           触摸设备优化
           用户需求：改善移动设备的交互体验
           ======================================== */

        /* 触摸目标最小尺寸 */
        @media (hover: none) and (pointer: coarse) {
            .animate-button {
                min-height: 44px;
                min-width: 44px;
                padding: 12px 20px;
            }

            .nav-btn {
                min-width: 44px;
                min-height: 44px;
            }

            input[type="number"],
            input[type="text"] {
                min-height: 44px;
                font-size: 16px;
                /* 防止iOS自动缩放 */
            }

            /* 移除hover效果，使用active效果 */
            .animate-button:hover {
                transform: none;
                box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
            }

            .animate-button:active {
                transform: scale(0.95);
                box-shadow: 0 1px 4px rgba(16, 185, 129, 0.2);
            }

            .nav-btn:hover {
                background: rgba(0, 0, 0, 0.15);
            }

            .nav-btn:active {
                background: rgba(0, 0, 0, 0.3);
                transform: scale(0.9);
            }
        }

        /* 打印样式 */
        @media print {
            .nav-controls {
                display: none;
            }

            .slide {
                page-break-after: always;
            }

            .slide-container {
                flex-direction: column;
            }

            .left-content,
            .right-visual {
                max-height: none;
            }
        }

        /* 高对比度模式支持 */
        @media (prefers-contrast: high) {
            .definition {
                border-left-width: 5px;
            }

            .note {
                border-left-width: 5px;
            }

            h1 {
                border-left-width: 8px;
            }
        }

        /* 减少动画模式 */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }

            .slide {
                transition: none;
            }

            .animate-button:hover,
            .animate-button:active {
                transform: none;
            }
        }

        /* 返回按钮样式 */
        .return-home-panel {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 9999;
            display: flex;
            gap: 10px;
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }

        .return-home-panel:hover {
            opacity: 1;
        }

        .return-home-panel .return-link {
            padding: 6px 12px;
            background: rgba(15, 23, 42, 0.7);
            color: #f8fafc;
            text-decoration: none;
            border-radius: 999px;
            font-size: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }

        .return-home-panel .return-link:hover {
            background: rgba(15, 23, 42, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(15, 23, 42, 0.3);
        }

        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.7);
        }

        .return-home-panel .return-link.return-main:hover {
            background: rgba(79, 70, 229, 0.9);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.3);
        }

        /* 桌面端：左侧板书标题吸顶 */
        @media (min-width: 1024px) {

            .left-content h2,
            .left-content h3 {
                position: sticky;
                top: 0;
                background: #ffffff;
                z-index: 2;
                padding-top: 8px;
                box-shadow: 0 2px 0 rgba(229, 231, 235, 0.6);
            }
        }

        /* 统一封面样式（与第1章一致） */
        .slide-container.cover {
            align-items: stretch;
        }

        .cover-left {
            padding: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .cover-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(90deg, #4a90e2, #9b59b6);
            color: #fff;
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 14px;
            width: fit-content;
            box-shadow: 0 6px 16px rgba(74, 144, 226, 0.35);
        }

        .cover-title {
            font-size: 4rem;
            line-height: 1.1;
            margin: 18px 0 8px 0;
            color: #1a1a2e;
            background: linear-gradient(90deg, #1a1a2e 0%, #4a90e2 60%, #9b59b6 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .cover-subtitle {
            font-size: 1.6rem;
            color: #4f5b6a;
            margin: 10px 0 18px 0;
        }

        .cover-meta {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            color: #6b7b8c;
            font-size: 0.95rem;
        }

        .cover-meta span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .cover-actions {
            display: flex;
            gap: 14px;
            margin-top: 26px;
            flex-wrap: wrap;
        }

        .cover-right {
            position: relative;
            overflow: hidden;
        }

        .cover-visual {
            position: relative;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(1200px 800px at 80% 20%, rgba(155, 89, 182, 0.18), transparent 60%),
                radial-gradient(900px 700px at 20% 80%, rgba(74, 144, 226, 0.18), transparent 60%),
                linear-gradient(135deg, #ffffff 0%, #f7faff 50%, #f9f6ff 100%);
        }

        .cover-visual::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(600px 300px at 50% -10%, rgba(255, 255, 255, 0.7), transparent 70%);
            pointer-events: none;
        }

        .math-badge {
            position: absolute;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
            color: #34495e;
            font-weight: 600;
            animation: floatY 6s ease-in-out infinite;
            backdrop-filter: blur(4px);
        }

        .math-badge.b1 {
            left: 12%;
            top: 22%;
            animation-delay: 0s;
        }

        .math-badge.b2 {
            right: 14%;
            top: 30%;
            animation-delay: 0.8s;
        }

        .math-badge.b3 {
            left: 20%;
            bottom: 18%;
            animation-delay: 1.5s;
        }

        .math-badge.b4 {
            right: 18%;
            bottom: 22%;
            animation-delay: 2.2s;
        }

        @keyframes floatY {
            0% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-12px);
            }

            100% {
                transform: translateY(0px);
            }
        }

        .orbit {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 320px;
            height: 320px;
            margin-left: -160px;
            margin-top: -160px;
            border-radius: 50%;
            border: 1px dashed rgba(52, 152, 219, 0.35);
            animation: spin 18s linear infinite;
        }

        .orbit .dot {
            position: absolute;
            top: -6px;
            left: 50%;
            width: 12px;
            height: 12px;
            margin-left: -6px;
            background: #4a90e2;
            border-radius: 50%;
            box-shadow: 0 0 0 6px rgba(74, 144, 226, 0.15);
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* 悬浮主按钮（左下角） */
        .floating-control-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 56px;
            height: 56px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 50%;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            z-index: 1100;
            transition: all 0.25s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .floating-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.18);
            background: #111827;
        }

        .floating-control-btn .btn-icon {
            color: #111827;
            font-size: 20px;
            transition: transform 0.3s ease, color 0.3s ease;
        }

        .floating-control-btn:hover .btn-icon {
            color: #ffffff;
        }

        .floating-control-btn.active .btn-icon {
            transform: rotate(45deg);
        }

        /* 悬浮二级按钮容器与项（横向一排） */
        .floating-menu-items {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1099;
            pointer-events: none;
            opacity: 0;
            transition: all 0.25s ease;
        }

        .floating-menu-items.active {
            opacity: 1;
            pointer-events: auto;
        }

        .floating-menu-item {
            position: absolute;
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.25s ease;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
            transform: scale(0);
            backdrop-filter: blur(8px);
            color: #111827;
        }

        .floating-menu-items.active .floating-menu-item {
            transform: scale(1);
        }

        .floating-menu-item:hover {
            background: #111827;
            color: #ffffff;
            transform: scale(1.06);
        }

        .floating-menu-item .item-icon {
            font-size: 16px;
        }

        .floating-menu-item .item-text {
            position: absolute;
            top: -32px;
            left: 0;
            transform: translateX(-10%);
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 6px 10px;
            border-radius: 12px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .floating-menu-item:hover .item-text {
            opacity: 1;
        }

        /* 横向布局 */
        .floating-menu-item:nth-child(1) {
            bottom: 28px;
            left: 88px;
            transition-delay: 0.08s;
        }

        .floating-menu-item:nth-child(2) {
            bottom: 28px;
            left: 148px;
            transition-delay: 0.12s;
        }

        /* 统一型弹层（实验室/本章目录/返回目录） */
        .lab-submenu {
            position: fixed;
            top: 12%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1200;
            width: 96%;
            max-width: 1000px;
            max-height: 78vh;
            overflow-y: auto;
            overflow-x: hidden;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .submenu-content {
            padding: 24px;
            position: relative;
        }

        .submenu-title {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .submenu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .submenu-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: #f8f9fa;
            border: 2px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s ease;
            font-size: 14px;
            color: #2c3e50;
        }

        .submenu-item:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .submenu-icon {
            margin-right: 10px;
            font-size: 16px;
        }

        .submenu-close {
            position: absolute;
            top: 12px;
            right: 16px;
            width: 28px;
            height: 28px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.25s ease;
        }

        .submenu-close:hover {
            background: #c0392b;
            transform: scale(1.08);
        }
    </style>
</head>

<body>
    <!-- 返回按钮 -->
    <div class="return-home-panel">
        <a class="return-link" href="../index.html"><i class="fa-solid fa-house"></i> 返回主站</a>
        <a class="return-link return-main" href="javascript:void(0)"
            onclick="event.stopPropagation(); toggleCourseSubmenu()"><i class="fa-solid fa-arrow-left"></i> 返回目录</a>
    </div>

    <!-- 加载指示器 -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">正在加载课件...</div>
    </div>

    <div class="slide-wrapper" id="slideWrapper">
        <!-- 幻灯片将通过 JavaScript 动态生成 -->
    </div>

    <!-- 导航控制 -->
    <!-- 用户需求：支持键盘、鼠标、触摸多种交互方式 -->
    <div class="nav-controls" role="navigation" aria-label="幻灯片导航">
        <button class="nav-btn" onclick="prevSlide()" aria-label="上一页" title="上一页 (←)"><i class="fa-solid fa-arrow-left"></i> 上一页</button>
        <div class="slide-number" role="status" aria-live="polite">
            <input type="number" id="slideNumberInput" min="1" max="61" value="1" onchange="jumpToSlide(this.value)"
                aria-label="当前页码">/<span id="slideNumberTotal">61</span>
        </div>
        <button class="nav-btn" onclick="nextSlide()" aria-label="下一页" title="下一页 (→)">下一页 →</button>
    </div>

    <!-- 悬浮控制按钮与二级菜单 -->
    <button class="floating-control-btn" id="floating-control-btn"><span class="btn-icon">+</span></button>
    <div class="floating-menu-items" id="floating-menu-items">
        <div class="floating-menu-item" onclick="event.stopPropagation(); toggleLabSubmenu()">
            <span class="item-icon"><i class="fa-solid fa-flask"></i></span>
            <span class="item-text">实验室</span>
        </div>
        <div class="floating-menu-item" onclick="event.stopPropagation(); toggleChapterSubmenu()">
            <span class="item-icon"><i class="fa-solid fa-clipboard-list"></i></span>
            <span class="item-text">本章目录</span>
        </div>
    </div>

    <!-- 实验室弹层（第二章） -->
    <div class="lab-submenu" id="lab-submenu" style="display: none;">
        <div class="submenu-content">
            <div class="submenu-title">第二章实验室</div>
            <div class="submenu-grid">
                <div class="submenu-item" onclick="window.open('../网页资源/index.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-list"></i></span><span
                        class="submenu-text">资源总览</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-1.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">图像压缩与数列极限实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-2.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">数列极限案例探索实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-3.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">函数极限与自变量变化实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-4.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">左右极限与存在性判定实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-5.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">无穷大与无穷小倒数关系实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-6.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">重要极限实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-7.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">无穷小比较实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-8.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">函数增量实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-9.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">等价无穷小倒水游戏</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-10.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">连续与间断游戏</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-11.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">函数连续性实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-12.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">函数间断点实验室</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-13.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">极限与连续游戏</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-14.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">直接代入法求极限游戏</span></div>
                <div class="submenu-item" onclick="window.open('../网页资源/lab 2-15.html', '_blank')"><span
                        class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span
                        class="submenu-text">极限求解方法知识图谱</span></div>
            </div>
            <div class="submenu-close" onclick="toggleLabSubmenu()">×</div>
        </div>
    </div>

    <!-- 本章目录弹层（结构化） -->
    <div class="lab-submenu" id="chapter-submenu" style="display: none;">
        <div class="submenu-content">
            <div class="submenu-title">第二章课件目录</div>
            <div class="submenu-grid" id="chapter-submenu-grid">
                <!-- 由脚本基于 slidesData 自动生成：封面 + 各节标题 -->
            </div>
            <div class="submenu-close" onclick="toggleChapterSubmenu()">×</div>
        </div>
    </div>

    <!-- 全部课件目录弹层 -->
    <div class="lab-submenu" id="course-submenu" style="display: none;">
        <div class="submenu-content">
            <div class="submenu-title">全部课件目录</div>
            <div class="submenu-grid">
                <div class="submenu-item" onclick="window.location.href='第1章代数.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第1章 代数</span></div>
                <div class="submenu-item" onclick="window.location.href='第2章极限与连续.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第2章 极限与连续</span></div>
                <div class="submenu-item" onclick="window.location.href='第3章导数与微分.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第3章 导数与微分</span></div>
                <div class="submenu-item" onclick="window.location.href='第4章导数应用.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第4章 导数应用</span></div>
                <div class="submenu-item" onclick="window.location.href='第5章不定积分.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第5章 不定积分</span></div>
                <div class="submenu-item" onclick="window.location.href='第6章定积分.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第6章 定积分</span></div>
                <div class="submenu-item" onclick="window.location.href='第7章常微分方程.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第7章 常微分方程</span></div>
                <div class="submenu-item" onclick="window.location.href='第8章多元函数微分学.html';"><span
                        class="submenu-icon"><i class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第8章
                        多元函数微分学</span></div>
                <div class="submenu-item" onclick="window.location.href='第9章多元函数积分学初步.html';"><span
                        class="submenu-icon"><i class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第9章
                        多元函数积分学初步</span></div>
                <div class="submenu-item" onclick="window.location.href='第10章线性代数.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第10章 线性代数</span></div>
                <div class="submenu-item" onclick="window.location.href='第11章无穷级数.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第11章 无穷级数</span></div>
                <div class="submenu-item" onclick="window.location.href='第12章向量代数与空间解析几何.html';"><span
                        class="submenu-icon"><i class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第12章
                        向量代数与空间解析几何</span></div>
                <div class="submenu-item" onclick="window.location.href='第13章概率与统计.html';"><span class="submenu-icon"><i
                            class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">第13章 概率与统计</span></div>
            </div>
            <div class="submenu-close" onclick="toggleCourseSubmenu()">×</div>
        </div>
    </div>

    <script>
        // ========================================
        // 全局变量
        // ========================================
        let currentSlide = 1;
        let totalSlides = 0;
        let activeAnimation = null; // 当前活动的动画对象

        // 基于 slidesData 自动生成实验室目录
        function buildLabMenu() {
            const grid = document.querySelector('#lab-submenu .submenu-grid');
            if (!grid) return;
            grid.innerHTML = '';

            // 1. 添加资源总览 (固定项)
            const overviewItem = document.createElement('div');
            overviewItem.className = 'submenu-item';
            overviewItem.onclick = () => window.open('../网页资源/index.html', '_blank');
            overviewItem.innerHTML = '<span class="submenu-icon"><i class="fa-solid fa-list"></i></span><span class="submenu-text">资源总览</span>';
            grid.appendChild(overviewItem);

            // 2. 遍历幻灯片查找实验室
            slidesData.forEach((slide, index) => {
                // 识别实验室幻灯片：标题包含"实验室" 或 内容包含 lab 2-
                if (slide.title.includes('实验室') || (slide.content && slide.content.includes('lab 2-'))) {
                    const title = slide.title.replace('实验室 - ', '').replace('实验室：', '');

                    const item = document.createElement('div');
                    item.className = 'submenu-item';
                    item.onclick = () => {
                        jumpToSlide(index + 1);
                        toggleLabSubmenu();
                    };
                    item.innerHTML = `<span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">${title}</span>`;
                    grid.appendChild(item);
                }
            });
        }

        // 基于 slidesData 自动生成本章目录
        function buildChapterMenu() {
            const grid = document.getElementById('chapter-submenu-grid');
            if (!grid) return;
            grid.innerHTML = '';

            // 工具：中文数字转阿拉伯（1-10即可）
            const zhNumMap = { '一': 1, '二': 2, '三': 3, '四': 4, '五': 5, '六': 6, '七': 7, '八': 8, '九': 9, '十': 10 };
            function chineseToArabic(zh) {
                if (zh in zhNumMap) return zhNumMap[zh];
                // 兼容“十一”“十二”这类
                if (zh.length === 2 && zh[0] === '十') return 10 + (zhNumMap[zh[1]] || 0);
                if (zh.length === 2 && zh[1] === '十') return (zhNumMap[zh[0]] || 0) * 10;
                return null;
            }

            // 收集：封面 + 各节 + 小节
            const sections = [];
            let currentSection = null;

            // 封面
            sections.push({
                title: '封面',
                index: 1,
                isSection: true,
                arabic: 0,
                subs: []
            });

            const sectionRe = /第([一二三四五六七八九十]+)节\s*(.*)?/;
            const subRe = /^(\d+)\.(\d+)\s*[\-：:]?\s*(.*)$/;

            for (let i = 0; i < slidesData.length; i++) {
                const s = slidesData[i];
                const raw = (s && s.title) ? String(s.title).trim() : '';
                if (!raw) continue;

                const mSection = raw.match(sectionRe);
                if (mSection) {
                    const zh = mSection[1];
                    const rest = (mSection[2] || '').trim();
                    const arabic = chineseToArabic(zh) || sections.length; // 回退
                    currentSection = {
                        title: `第${zh}节 ${rest || ''}`.trim(),
                        index: i + 1,
                        isSection: true,
                        arabic,
                        subs: []
                    };
                    sections.push(currentSection);
                    continue;
                }

                const mSub = raw.match(subRe);
                if (mSub) {
                    const major = parseInt(mSub[1], 10);
                    const label = (mSub[3] || raw).trim() || raw;
                    const subItem = {
                        title: raw, // 保留原始标题（含 5.1 等编号）
                        label,
                        index: i + 1
                    };

                    // 放到最近的对应节（数字与节号一致）
                    let target = currentSection;
                    if (!target || (target && typeof target.arabic === 'number' && target.arabic !== major)) {
                        target = sections.find(sec => sec.isSection && sec.arabic === major) || currentSection;
                    }
                    if (target && target.isSection) {
                        target.subs.push(subItem);
                    }
                }
            }

            // 渲染：每个大节作为一个可点击项，下面跟随小节
            sections.forEach(sec => {
                const secEl = document.createElement('div');
                secEl.className = 'submenu-item';
                secEl.innerHTML = '<span class="submenu-icon"><i class="fa-solid ' + (sec.arabic ? 'fa-clipboard-list' : 'fa-house') + '"></i></span><span class="submenu-text">' + sec.title + '</span>';
                secEl.onclick = function () { jumpToSlide(sec.index); toggleChapterSubmenu(); };
                grid.appendChild(secEl);

                if (sec.subs && sec.subs.length) {
                    sec.subs.forEach(sub => {
                        const subEl = document.createElement('div');
                        subEl.className = 'submenu-item';
                        subEl.style.marginLeft = '12px';
                        subEl.style.fontSize = '13px';
                        subEl.innerHTML = '<span class="submenu-icon"><i class="fa-solid fa-circle-dot"></i></span><span class="submenu-text">' + sub.title + '</span>';
                        subEl.onclick = function () { jumpToSlide(sub.index); toggleChapterSubmenu(); };
                        grid.appendChild(subEl);
                    });
                }
            });
        }

        // ================= 悬浮菜单与弹层：函数与互斥控制 =================
        function closeAllSubmenus(exceptId) {
            const ids = ['lab-submenu', 'chapter-submenu', 'course-submenu'];
            ids.forEach(id => {
                if (id !== exceptId) {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                }
            });
        }
        function toggleLabSubmenu() {
            const el = document.getElementById('lab-submenu');
            if (!el) return;
            const willOpen = el.style.display !== 'block';
            closeAllSubmenus('lab-submenu');
            el.style.display = willOpen ? 'block' : 'none';
        }
        function toggleChapterSubmenu() {
            const el = document.getElementById('chapter-submenu');
            if (!el) return;
            const willOpen = el.style.display !== 'block';
            closeAllSubmenus('chapter-submenu');
            el.style.display = willOpen ? 'block' : 'none';
        }
        function toggleCourseSubmenu() {
            const el = document.getElementById('course-submenu');
            if (!el) return;
            const willOpen = el.style.display !== 'block';
            closeAllSubmenus('course-submenu');
            el.style.display = willOpen ? 'block' : 'none';
        }
        function initFloatingControl() {
            const floatingBtn = document.getElementById('floating-control-btn');
            const floatingMenu = document.getElementById('floating-menu-items');
            if (!floatingBtn || !floatingMenu) return;
            floatingBtn.addEventListener('click', function (e) {
                e.stopPropagation();
                floatingBtn.classList.toggle('active');
                floatingMenu.classList.toggle('active');
            });
        }

        // ========================================
        // 幻灯片数据
        // 用户需求：保留所有原始内容，使用简洁的代码结构
        // ========================================
        const slidesData = [
            // 第1页：封面
            // 用户需求：响应式封面设计，适配不同屏幕尺寸
            {
                title: "第2章 极限与连续",
                content: `
                    <div class="slide-container cover">
                        <div class="left-content tex2jax_process cover-left">
                            <div class="cover-badge"><i class="fa-solid fa-seedling"></i><span> 第二章</span></div>
                            <h1 class="cover-title">极限与连续</h1>
                            <p class="cover-subtitle">微积分的基础与核心</p>
                            <div class="cover-meta">
                                <span><i class="fa-solid fa-book-open"></i> 基础篇</span>
                                <span><i class="fa-solid fa-bolt"></i> 关键概念速览</span>
                            </div>
                            <div class="cover-actions">
                                <a class="home-link-btn" href="../index.html"><span>主页</span></a>
                                <a class="home-link-btn" href="../故事书/第二章/与幽灵共舞.html"><span>故事书</span></a>
                                <a class="home-link-btn" href="../习题/assets/limit.html"><span>习题</span></a>
                                <!-- 产教结合页面链接（部署时需要修改为实际部署AI功能的域名） -->
                                <a class="home-link-btn" href="https://ai.projectmath.xyz/project/index.html"><span>资源</span></a>
                            </div>
                        </div>
                        <div class="right-visual cover-right">
                            <div class="cover-visual">
                                <div class="math-badge b1">lim</div>
                                <div class="math-badge b2">ε-δ</div>
                                <div class="math-badge b3">∞</div>
                                <div class="math-badge b4">→</div>
                                <div class="orbit"><span class="dot"></span></div>
                            </div>
                        </div>
                    </div>
                `,
                animation: "title"
            },

            // 第2页：第一节标题
            {
                title: "第一节 极限的概念",
                content: `
                    <div class="slide-container">
                        <div style="width: 100%; padding: 40px; display: flex; flex-direction: column; justify-content: center;">
                            <h2 style="font-size: 48px; margin-bottom: 50px; text-align: center; color: #3b82f6;">第一节 极限的概念</h2>
                            <h3 style="font-size: 32px; margin-bottom: 40px; color: #374151;">本节内容</h3>
                            <ul style="font-size: 26px; line-height: 2.5; padding-left: 40px;">
                                <li><strong>1.1</strong> 数列的极限：从离散的数点看趋势</li>
                                <li><strong>1.2</strong> 函数的极限：从连续的曲线看趋势</li>
                                <li><strong>1.3</strong> 无穷小与无穷大：特殊的极限情况</li>
                            </ul>
                        </div>
                    </div>
                `,
                animation: null
            },

            // 第3页：数列的引入
            {
                title: "1.1 - 数列的引入与定义",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>2.1.1 数列与数列极限</h3>
                            <h4>1. 什么是数列？</h4>
                            <div class="definition">
                                <strong>定义1：数列</strong>
                                <p>按一定次序排列的一列数 $x_{1},x_{2},x_{3},\\ldots,x_{n},\\ldots$，称为数列，记作 $\\{x_n\\}$。</p>
                                <p>其中，$x_n$ 称为数列的<strong>通项</strong>，它表示数列中第 $n$ 个数的值。</p>
                            </div>
                            <div class="note">
                                <strong>注意</strong>：数列的本质是自变量为正整数 $n$ 的一个特殊函数 $f(n) = x_n$。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-sequence" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "sequence"
            },

            // 第4页：视角转变
            {
                title: "1.1 - 视角转变：从有限到无限",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>2. 视角转变：从"过程"到"终点"</h4>
                            <p style="background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong>核心区别</strong>：高中数学关注数列的"过程"，例如某一项的值或前n项的和；
                                高等数学更关注数列的"终点"，即当项数无限增多时，它会奔向何方。
                            </p>
                            <h4 style="color: #3b82f6; margin-top: 20px;">高中数学：有限视角</h4>
                            <ul style="line-height: 1.8;">
                                <li>研究对象：前 n 项（n 是具体的、有限的）</li>
                                <li>核心问题：通项公式 $a_n$ 是什么？前 n 项和 $S_n$ 是多少？</li>
                                <li>关键词：通项、求和、递推</li>
                            </ul>
                            <h4 style="color: #10b981; margin-top: 20px;">大学高数：无限视角</h4>
                            <ul style="line-height: 1.8;">
                                <li>研究对象：整个数列的长期趋势</li>
                                <li>核心问题：当 $n \\to \\infty$ 时，$a_n$ 的最终归宿是？</li>
                                <li>关键词：极限、收敛、发散</li>
                            </ul>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-viewshift" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "viewshift"
            },

            // 第5页：考拉兹猜想
            {
                title: "1.1 - 拓展案例：考拉兹猜想",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>拓展案例 1：考拉兹猜想 (Collatz Conjecture)</h4>
                            <p>任意正整数按"奇数乘3加1，偶数除以2"的规则演化，形成的数列似乎最终都会陷入 $4 \\to 2 \\to 1$ 的循环。</p>
                            <div style="margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                                <label style="font-weight: bold; margin-right: 10px;">输入一个正整数：</label>
                                <input type="number" id="collatz-input" min="1" value="27" style="padding: 8px; border: 2px solid #3b82f6; border-radius: 4px; width: 100px;">
                                <button onclick="updateCollatz()" class="animate-button">生成序列</button>
                                <div id="collatz-info" style="margin-top: 15px; font-family: monospace; color: #374151;"></div>
                            </div>
                            <div class="note">
                                这是一个著名的数学难题，展示了简单规则如何产生复杂的、难以预测的长期行为。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-collatz" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "collatz"
            },

            // 第6页：斐波那契数列
            {
                title: "1.1 - 拓展案例：斐波那契数列",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>拓展案例 2：斐波那契数列与黄金分割</h4>
                            <p>斐波那契数列：$1, 1, 2, 3, 5, 8, 13, \\ldots$ (后一项是前两项之和)</p>
                            <p>研究其前后项比值的极限，会发现一个神奇的数字：</p>
                            <div style="background: rgba(251, 191, 36, 0.15); padding: 20px; border-radius: 10px; margin: 20px 0; text-align: center; font-size: 20px;">
                                $$\\displaystyle\\lim_{n\\to\\infty}\\frac{F_{n+1}}{F_{n}} = \\Phi \\approx 1.618$$
                                <p style="margin-top: 10px; font-size: 16px;">(黄金分割数)</p>
                            </div>
                            <div class="note">
                                这个极限揭示了自然界中许多现象（如花瓣、螺壳）背后的数学规律。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-fibonacci" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "fibonacci"
            },

            // 第7页：设备折旧
            {
                title: "1.1 - 拓展案例：设备折旧",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>拓展案例 3：设备折旧的极限</h4>
                            <p>一台价值 $V_0$ 的设备每年折旧 10%，则其逐年价值构成一个等比数列：</p>
                            <p style="text-align: center; font-size: 20px; margin: 20px 0;">
                                $V_n = V_0 \\cdot (0.9)^{n}$
                            </p>
                            <p>当使用年限 $n$ 趋于无穷时，它的最终价值是多少？</p>
                            <div style="background: rgba(16, 185, 129, 0.15); padding: 20px; border-radius: 10px; margin: 20px 0; text-align: center; font-size: 20px;">
                                $$\\displaystyle\\lim_{n\\to\\infty} V_n = \\lim_{n\\to\\infty} V_0 \\cdot (0.9)^n = 0$$
                            </div>
                            <div class="note">
                                这个极限告诉我们，理论上设备的价值将无限趋近于0，这为评估固定资产残值提供了理论依据。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-depreciation" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "depreciation"
            },

            // 第8页：观察数列趋势
            {
                title: "1.1 - 观察数列趋势",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>3. 如何描述数列的趋势？</h4>
                            <p style="background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px;">
                                <strong>实例探索</strong>：观察数列 $x_n = \\frac{n}{n+1}$，当n越来越大时，$x_n$ 的值会发生什么变化？
                            </p>
                            <h5 style="margin-top: 20px;">Step 1: 计算前几项</h5>
                            <p>$x_1 = \\frac{1}{2} = 0.5$</p>
                            <p>$x_2 = \\frac{2}{3} \\approx 0.667$</p>
                            <p>$x_{10} = \\frac{10}{11} \\approx 0.909$</p>
                            <p>$x_{100} = \\frac{100}{101} \\approx 0.990$</p>
                            <p><strong>直观感受</strong>: 随着n增大，数值越来越大，并且无限地接近于1。</p>
                            <h5 style="margin-top: 20px;">Step 2: 建立直觉</h5>
                            <p><strong>进度条类比</strong>：想象一个总长度为 $n+1$ 的任务，已经完成了 $n$。完成度 $x_n = \\frac{n}{n+1}$ 总是差一点到100%，但随着任务总量的增加，这个差距会小到可以忽略不计。</p>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-trend" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "trend"
            },

            // 第9页：数列的终点行为
            {
                title: "1.1 - 数列的终点行为",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>4. 数列的三种"终点"</h4>
                            <p>当项数 $n$ 走向无穷时，数列的最终表现可分为三类：</p>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong style="color: #10b981;">收敛</strong>：数列的项无限趋近于一个确定的常数。
                                <p style="margin-top: 5px;">例如：$\\frac{1}{n} \\to 0$</p>
                            </div>
                            <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong style="color: #ef4444;">发散到无穷</strong>：数列的项无限增大或减小，没有尽头。
                                <p style="margin-top: 5px;">例如：$n^2 \\to +\\infty$</p>
                            </div>
                            <div style="background: rgba(245, 158, 11, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong style="color: #f59e0b;">摆动发散</strong>：数列的项在若干个值之间来回跳动，并不趋近于任何一个常数。
                                <p style="margin-top: 5px;">例如：$(-1)^n$</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-terminal" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "terminal"
            },

            // 第10页：数列极限定义
            {
                title: "1.1 - 数列极限的定义",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>5. 数列极限的定义</h4>
                            <div class="definition">
                                <strong>定义2：数列极限</strong>
                                <p>对于数列 $\\{x_n\\}$，如果当 $n$ 无限增大时，其通项 $x_n$ 无限趋近于某个确定的常数 $A$，那么就称常数 $A$ 是数列 $\\{x_n\\}$ 的极限，或者称数列 $\\{x_n\\}$ 收敛于 $A$。</p>
                                <p>记作：</p>
                                <div style="text-align: center; font-size: 20px; margin: 15px 0;">
                                    $$\\displaystyle\\lim_{n \\to \\infty} x_n = A \\quad \\text{或} \\quad x_n \\to A \\ (n \\to \\infty)$$
                                </div>
                            </div>
                            <div class="note">
                                <strong>关键点</strong>：极限描述的是一种<strong>趋势</strong>，而不是一个具体的值。$x_n$ 可以无限接近 $A$，但永不等于 $A$。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-limit-def" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "limitdef"
            },

            // 第11页：AI工具 - 数列极限可视化
            {
                title: "AI工具 - 数列极限可视化",
                content: ` <div class="iframe-container"><iframe data-src="数列ai.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="AI数列极限可视化工具"></iframe></div>`,
                animation: null
            },

            // 第12页：极限的通俗理解
            {
                title: "1.1 - 极限的通俗理解",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>6. 如何理解极限？</h4>
                            <p><strong>靶心类比</strong>：</p>
                            <p>想象数列的每一项 $x_n$ 都是一次射击的落点。$n$ 代表射击的次数。</p>
                            <ul style="line-height: 1.8;">
                                <li><strong>收敛（极限存在）</strong>：一位优秀的射手，随着练习次数 $n$ 的增加，他的射击落点 $x_n$ 会越来越密集地分布在靶心 $A$ 周围。这个<strong>靶心 $A$</strong> 就是极限。</li>
                                <li><strong>发散（极限不存在）</strong>：一位新手，他的射击落点可能毫无规律，或者越射越偏，没有一个明确的目标中心。</li>
                            </ul>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-target" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "target"
            },

            // 第13页：收敛与发散
            {
                title: "1.1 - 收敛与发散",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>7. 收敛与发散的辨析</h4>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h4 style="color: #10b981;">收敛 (Convergent)</h4>
                                <p><strong>含义：</strong>数列有极限。</p>
                                <p><strong>特征：</strong>当 $n$ 足够大之后，数列的所有项都"挤在"某个确定常数的周围。</p>
                                <p><strong>例子：</strong>$x_n = 3 + \\frac{1}{n}$，各项都挤在3的周围，极限为3。</p>
                            </div>
                            <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h4 style="color: #ef4444;">发散 (Divergent)</h4>
                                <p><strong>含义：</strong>数列没有极限。</p>
                                <p><strong>特征：</strong>数列的项不会稳定地趋近于任何一个常数。</p>
                                <p><strong>例子：</strong>$x_n = n$ (无限增大), $x_n = (-1)^n$ (来回摆动)。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-convergence" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "convergence"
            },

            // 第14页：实例分析 1
            {
                title: "1.1 - 实例分析 1",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>实例 1</h4>
                                <p>判断数列 $x_n=\\frac{n}{n+1}$ 的收敛性。</p>
                                <p><strong>分析</strong>：之前我们已经通过计算前几项，直观地发现它无限趋近于1。</p>
                                <p><strong>结论</strong>：该数列收敛，极限为1。记作 $\\displaystyle\\lim_{n\\to\\infty}\\frac{n}{n+1}=1$。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-example1-1" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "example1_1"
            },

            // 第15页：实例分析 2
            {
                title: "1.1 - 实例分析 2",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>实例 2</h4>
                                <p>判断数列 $x_{n}=\\frac{1}{2}[1+(-1)^{n}]$ 的收敛性。</p>
                                <p><strong>分析</strong>：写出前几项：$x_1=0, x_2=1, x_3=0, x_4=1, \\ldots$。数列的项在0和1之间来回跳跃。</p>
                                <p><strong>结论</strong>：数列没有趋近于任何一个确定的常数，因此该数列发散。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-example1-2" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "example1_2"
            },

            // 第16页：实例分析 3
            {
                title: "1.1 - 实例分析 3",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>实例 3</h4>
                                <p>判断数列 $x_{n}=\\frac{1}{(-3)^{n}}$ 的收敛性。</p>
                                <p><strong>分析</strong>：写出前几项：$-\\frac{1}{3}, \\frac{1}{9}, -\\frac{1}{27}, \\frac{1}{81}, \\ldots$。虽然数值正负交替，但它们的绝对值越来越小，无限趋近于0。</p>
                                <p><strong>结论</strong>：该数列收敛，极限为0。记作 $\\displaystyle\\lim_{n\\to\\infty} \\frac{1}{(-3)^{n}} = 0$。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-example1-3" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "example1_3"
            },

            // 第17页：实例分析 4
            {
                title: "1.1 - 实例分析 4",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>实例 4</h4>
                                <p>判断常数数列 $x_n=8$ 的收敛性。</p>
                                <p><strong>分析</strong>：数列的每一项都是8，它"无限趋近"的目标就是8本身。</p>
                                <p><strong>结论</strong>：该数列收敛，极限为8。记作 $\\displaystyle\\lim_{n\\to\\infty} 8 = 8$。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-example1-4" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "example1_4"
            },

            // 实验室：图像压缩与数列极限实验室
            {
                title: "实验室 - 图像压缩与数列极限",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-1.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="图像压缩与数列极限实验室"></iframe></div>`,
                animation: null
            },

            // 实验室：数列极限案例探索实验室
            {
                title: "实验室 - 数列极限案例探索",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-2.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="数列极限案例探索实验室"></iframe></div>`,
                animation: null
            },

            // 第20页：从数列到函数（原第18页 +2个实验室）
            {
                title: "1.2 - 从数列到函数",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h2>2.1.2 函数极限</h2>
                            <h4>1. 从离散到连续</h4>
                            <p>数列是自变量为正整数 $n$ 的函数。如果把自变量 $n$ 扩展到全体实数 $x$，我们就从离散的数点过渡到了连续的函数图像。</p>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h3 style="color: #3b82f6;">数列 (离散点)</h3>
                                <p>研究当 $n$ 沿着 $1,2,3...$ 的路径奔向正无穷时，点的纵坐标 $x_n$ 的趋势。</p>
                            </div>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h3 style="color: #10b981;">函数 (连续线)</h3>
                                <p>研究当 $x$ 沿着实数轴奔向某个目标（有限值或无穷）时，曲线的高度 $f(x)$ 的趋势。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-sequence-function" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "sequence_function"
            },

            // 第21页：函数极限的本质
            {
                title: "1.2 - 函数极限的本质",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>2. 函数极限的核心思想</h4>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>核心问题</strong>：当自变量 $x$ 无限逼近某个目标时，对应的函数值 $f(x)$ 是否也无限逼近一个确定的数值？
                            </div>
                            <div class="note">
                                <strong>关键点</strong>：我们只关心"逼近"的过程，不关心在目标点"本身"发生了什么。就像我们关心赛车冲线瞬间的速度，而不关心它停在终点线上的状态。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-limit-concept" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "limit_concept"
            },

            // 第22页：趋近方式的多样性
            {
                title: "1.2 - 趋近方式的多样性",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>3. 趋近方式的多样性</h4>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h3 style="color: #3b82f6;">数列：离散的道路</h3>
                                <p>自变量只能取 $1,2,3,\\ldots$，唯一的趋近方式是 $n\\to \\infty$</p>
                            </div>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h3 style="color: #10b981;">函数：连续的高速公路</h3>
                                <p>自变量是连续实数，可以左趋近、右趋近、趋向 $+\\infty$ 或 $-\\infty$。</p>
                            </div>
                            <div style="background: rgba(251, 191, 36, 0.1); padding: 15px; border-radius: 8px; margin: 20px 0;">
                                <strong>思考</strong>："定义域扩展后，趋近方式为何变多？这就是函数极限比数列极限复杂的原因。"
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-domain-approach" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "domain_approach"
            },

            // 第23页：AI工具 - 函数极限可视化
            {
                title: "AI工具 - 函数极限可视化",
                content: ` <div class="iframe-container"><iframe data-src="函数ai.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="AI函数极限可视化工具"></iframe></div>`,
                animation: null
            },

            // 第24页：类型1 - x趋向无穷
            {
                title: "1.2 - 类型1：$x \\to \\infty$ 时的极限",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>类型一：自变量趋于无穷 ($x \\to \\infty$)</h4>
                            <div class="definition">
                                <strong>定义3：$x \\to \\infty$ 时的极限</strong>
                                <p>如果当 $|x|$ 无限增大时，函数值 $f(x)$ 无限趋近于某一个确定的常数A，那么A就称为函数 $f(x)$ 当 $x \\to \\infty$ 时的极限，记作：</p>
                                <div style="text-align: center; font-size: 20px; margin: 15px 0;">
                                    $$\\displaystyle\\lim_{x\\to\\infty}f(x)=A$$
                                </div>
                            </div>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px; margin: 20px 0;">
                                <strong>定理1：左右极限关系</strong>
                                <p>$$\\displaystyle\\lim_{x\\to\\infty}f(x)=A \\iff \\lim_{x\\to+\\infty}f(x) = A \\text{ 并且 } \\lim_{x\\to-\\infty}f(x) = A$$</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-function-infinity" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "function_infinity"
            },

            // 第25页：实例 - 1/x的极限
            {
                title: "1.2 - 实例：$y=\\frac{1}{x}$ 的极限",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>实例 5</h4>
                                <p>考察函数 $y=\\frac{1}{x}$ 在 $x\\to+\\infty$ 时的趋势。</p>
                                <p><strong>分析</strong>: 当x取值越来越大时 (如10, 100, 10000), 函数值 $\\frac{1}{x}$ 越来越小，无限趋近于0。</p>
                                <p><strong>结论</strong>: $$\\displaystyle\\lim_{x\\to+\\infty}\\frac{1}{x}=0$$</p>
                                <p>同理可得 $$\\displaystyle\\lim_{x\\to-\\infty}\\frac{1}{x}=0$$</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-one-over-x" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "one_over_x"
            },

            // 第26页：类型2 - x趋向x0
            {
                title: "1.2 - 类型2：$x \\to x_0$ 时的极限",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>类型二：自变量趋于有限值 ($x \\to x_0$)</h4>
                            <div class="definition">
                                <strong>定义4：$x \\to x_0$ 时的极限</strong>
                                <p>若当 $x$ 从 $x_0$ 的左右两侧无限趋近于 $x_0$ 时，函数值 $f(x)$ 无限趋近于确定的常数 $A$，则称 $A$ 是函数 $f(x)$ 当 $x \\to x_0$ 时的极限。</p>
                                <p>记作：$$\\displaystyle\\lim_{x \\to x_0} f(x) = A$$</p>
                            </div>
                            <div class="note">
                                <strong>再次强调</strong>: $x \\to x_0$ 指的是 $x$ 无限接近 $x_0$，但 $x \\neq x_0$。极限值 $A$ 与函数在 $x_0$ 点的取值 $f(x_0)$ 是否存在、是否相等，没有必然联系。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-point-limit" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "point_limit"
            },

            // 第27页：左右极限
            {
                title: "1.2 - 左右极限",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>5. 左极限与右极限</h4>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h5>左极限 ($x \\to x_0^-$)</h5>
                                <p>指 $x$ 从 $x_0$ 的左侧（即 $x < x_0$）无限逼近 $x_0$ 时 $f(x)$ 的趋势。</p>
                                <p>记作：$$\\displaystyle\\lim_{x\\to x_0^-}f(x)$$</p>
                            </div>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h5>右极限 ($x \\to x_0^+$)</h5>
                                <p>指 $x$ 从 $x_0$ 的右侧（即 $x > x_0$）无限逼近 $x_0$ 时 $f(x)$ 的趋势。</p>
                                <p>记作：$$\\displaystyle\\lim_{x\\to x_0^+}f(x)$$</p>
                            </div>
                            <div style="background: rgba(251, 191, 36, 0.1); padding: 15px; border-radius: 8px; margin: 20px 0;">
                                <strong>定理2：极限存在的充要条件</strong>
                                <p>$$\\displaystyle\\lim_{x\\to x_0}f(x)=A \\iff \\lim_{x\\to x_0^-}f(x) = \\lim_{x\\to x_0^+}f(x) = A$$</p>
                                <p>即：函数在某点的极限存在，当且仅当其左右极限均存在且相等。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-left-right-limits" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "left_right_limits"
            },

            // 实验室：函数极限与自变量变化实验室
            {
                title: "实验室 - 函数极限与自变量变化",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-3.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="函数极限与自变量变化实验室"></iframe></div>`,
                animation: null
            },

            // 实验室：左右极限与存在性判定实验室
            {
                title: "实验室 - 左右极限与存在性判定",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-4.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="左右极限与存在性判定实验室"></iframe></div>`,
                animation: null
            },

            // 第30页：应用实例 - 瞬时速度
            {
                title: "1.2 - 应用实例：瞬时速度",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>应用实例：瞬时速度</h4>
                                <p>物理学中，平均速度是 $\\frac{\\Delta s}{\\Delta t}$。当时间间隔 $\\Delta t$ 趋于0时，平均速度的极限就是瞬时速度。</p>
                                <p>设 $t_0$ 时刻的路程为 $s(t_0)$，$t$ 时刻的路程为 $s(t)$，则 $t_0$ 时刻的瞬时速度为：</p>
                                <div style="background: rgba(59, 130, 246, 0.15); padding: 20px; border-radius: 10px; margin: 20px 0; text-align: center; font-size: 20px;">
                                    $$v(t_0) = \\displaystyle\\lim_{t \\to t_0} \\frac{s(t) - s(t_0)}{t - t_0}$$
                                </div>
                                <p>这是导数概念的起源。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-velocity" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "velocity"
            },

            // 第31页：应用实例 - 动物种群
            {
                title: "1.2 - 应用实例：动物种群模型",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>实例：自然保护区中动物数量的变化规律</h4>
                                <p>动物群体数量会逐渐增长，但由于资源限制，群体不可能无限增大，它应达到某一饱和状态。</p>
                                <p>饱和状态就是时间 $t \\to \\infty$ 时动物群的数量。</p>
                                <p>这个模型展示了极限在生态学中的应用。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-population" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "population"
            },

            // 第32页：反正切函数的极限
            {
                title: "1.2 - 实例：反正切函数的极限",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>例4</h4>
                                <p>讨论反正切函数 $y=\\arctan x$ 的极限。</p>
                                <p><strong>解</strong>:</p>
                                <p>$$\\displaystyle\\lim_{x\\to+\\infty}\\arctan x=\\frac{\\pi}{2}$$</p>
                                <p>$$\\displaystyle\\lim_{x\\to-\\infty}\\arctan x=-\\frac{\\pi}{2}$$</p>
                                <p><strong>结论</strong>：由于左右极限不相等, 所以 $\\displaystyle\\lim_{x\\to\\infty}\\arctan x$ 不存在。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-arctan" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "arctan"
            },

            // 第33页：分段函数例6
            {
                title: "1.2 - 实例：分段函数在分界点的极限 (例6)",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>例6</h4>
                                <p>设 $$f(x)=\\begin{cases}x+2, & x \\geq 1 \\\\\\\\ 3x, & x < 1\\end{cases}$$</p>
                                <p>判断 $\\displaystyle\\lim_{x\\to 1}f(x)$ 是否存在。</p>
                                <p><strong>解</strong>:</p>
                                <p>$\\displaystyle\\lim_{x\\to 1^{+}}f(x)=\\lim_{x\\to 1^{+}}(x+2)=3$</p>
                                <p>$\\displaystyle\\lim_{x\\to 1^{-}}f(x)=\\lim_{x\\to 1^{-}}3x=3$</p>
                                <p><strong>结论</strong>：左右极限存在且相等, 所以 $\\displaystyle\\lim_{x\\to 1}f(x)=3$。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-piecewise1" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "piecewise1"
            },

            // 第34页：分段函数例7
            {
                title: "1.2 - 实例：分段函数在分界点的极限 (例7)",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <div class="example">
                                <h4>例7</h4>
                                <p>设 $$f(x)=\\begin{cases}x^{2}, & x\\geq 0 \\\\\\\\ x+1, & x<0\\end{cases}$$</p>
                                <p>讨论 $\\displaystyle\\lim_{x\\to 0}f(x)$ 是否存在?</p>
                                <p><strong>解</strong>:</p>
                                <p>$\\displaystyle\\lim_{x\\to 0^{-}}f(x)=\\lim_{x\\to 0^{-}}(x+1)=1$</p>
                                <p>$\\displaystyle\\lim_{x\\to 0^{+}}f(x)=\\lim_{x\\to 0^{+}}x^{2}=0$</p>
                                <p><strong>结论</strong>：左右极限不相等, 所以 $\\displaystyle\\lim_{x\\to 0}f(x)$ 不存在。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-piecewise2" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "piecewise2"
            },

            // 第35页：1.3节 - 无穷小与无穷大概念引入
            {
                title: "1.3 无穷小与无穷大概念引入",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h2>1.3 无穷小量与无穷大量</h2>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h3 style="color: #10b981;">无穷小的定义</h3>
                                <div class="definition">
                                    <p>在自变量的某个变化过程中，如果一个函数 $f(x)$ 的极限为0，则称 $f(x)$ 为该过程中的一个<strong>无穷小量</strong>。</p>
                                </div>
                                <div class="example">
                                    <p><strong>实例：</strong>当 $x \\to 1$ 时，$(x-1)$ 是无穷小。</p>
                                </div>
                            </div>
                            <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h3 style="color: #ef4444;">无穷大的定义</h3>
                                <div class="definition">
                                    <p>在自变量的某个变化过程中，如果一个函数 $f(x)$ 的绝对值无限增大，则称 $f(x)$ 为该过程中的一个<strong>无穷大量</strong>。</p>
                                </div>
                                <div class="example">
                                    <p><strong>实例：</strong>当 $x \\to 2$ 时，$\\frac{1}{(x-2)^2}$ 是无穷大。</p>
                                </div>
                            </div>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px; margin: 20px 0;">
                                <p><strong>核心关系：</strong>无穷大与非零无穷小互为倒数关系。</p>
                            </div>
                            <div class="note">
                                <p><strong>理解要点：</strong>无穷小和无穷大都是描述函数在某个过程中的<strong>行为趋势</strong>，不是具体数值。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-infinitesimal-definition" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "infinitesimal_definition"
            },

            // 第36页：无穷小是"归零"的过程
            {
                title: "1.3 无穷小是\"归零\"的过程",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h1>无穷小，是因变量y无限归零的过程</h1>
                            <div class="example">
                                <h3>例1：观察当 $x \\to 2$ 时, $y=(x-2)^2$ 的变化趋势。</h3>
                                <p><strong>过程分析：</strong></p>
                                <p>当自变量 x 从两侧无限接近 2 时...</p>
                                <p>函数值 y 在无限地、持续地接近 0。</p>
                                <p><strong>结论：</strong></p>
                                <p>在 $x \\to 2$ 这个特定过程中, $y$ 是一个<strong style="color: #10b981;">无穷小</strong>。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-infinitesimal-1" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "infinitesimal_process_1"
            },

            // 第37页：无穷小的"身份"由过程决定
            {
                title: "1.3 无穷小的\"身份\"由过程决定",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>同一函数，在不同过程中，"身份"也不同</h3>
                            <div class="example">
                                <h3>思考：函数 $y=(x-2)^2$ 永远是无穷小吗？</h3>
                                <p><strong>过程 1: $x \\to 2$</strong></p>
                                <p style="color: #10b981;">结果：$y \\to 0$ (是无穷小)</p>
                                <p><strong>过程 2: $x \\to 3$</strong></p>
                                <p style="color: #f59e0b;">结果：$y \\to 1$ (极限为1，不是无穷小)</p>
                                <p><strong>过程 3: $x \\to \\infty$</strong></p>
                                <p style="color: #ef4444;">结果：$y \\to \\infty$ (是无穷大)</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-infinitesimal-2" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "infinitesimal_context_dependent"
            },

            // 第38页：无穷大的乘积法则（重点修复页面）
            {
                title: "1.3 无穷大的基本性质",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>无穷大的基本运算法则</h3>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 10px; margin: 20px 0;">
                                <h3 style="color: #3b82f6;">法则：有限个无穷大的乘积仍是无穷大</h3>
                                <p style="margin-top: 10px;">例如：当 $x \\to \\infty$ 时，$x^2 \\to \\infty$、$x^3 \\to \\infty$，它们的乘积 $x^2 \\cdot x^3 = x^5$ 也必然趋向无穷大。</p>
                            </div>
                            <div class="note">
                                <strong>观察要点：</strong>
                                <ul style="margin-top: 10px; line-height: 1.8;">
                                    <li>蓝色曲线：$y = x^2$</li>
                                    <li>绿色曲线：$y = x^3$</li>
                                    <li>红色曲线：$y = x^5 = x^2 \\times x^3$</li>
                                </ul>
                                <p style="margin-top: 10px;">随着 $x$ 增大，$x^5$ 增长速度最快，体现了无穷大乘积的"加速"效应。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-infinite-law" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "infinitelaw"
            },
            // 第39页：AI工具 - 数列极限可视化
            {
                title: "1.3 无穷小与无穷大例题",
                content: ` <div class="iframe-container"><iframe data-src="无穷小与无穷大.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="AI数列极限可视化工具"></iframe></div>`,
                animation: null
            },

            // 实验室：无穷大与无穷小倒数关系实验室
            {
                title: "实验室 - 无穷大与无穷小倒数关系",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-5.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="无穷大与无穷小倒数关系实验室"></iframe></div>`,
                animation: null
            },

            // ========================================
            // 第二节：极限的性质和运算法则（3页）
            // ========================================

            // 第41页：第二节标题
            {
                title: "第二节 极限的性质和运算法则",
                content: `
                    <div class="slide-container">
                        <div style="width: 100%; padding: 40px; display: flex; flex-direction: column; justify-content: center;">
                            <h2 style="font-size: 48px; margin-bottom: 50px; text-align: center; color: #3b82f6;">第二节 极限的性质和运算法则</h2>
                            <h3 style="font-size: 32px; margin-bottom: 40px; color: #374151;">本节内容</h3>
                            <ul style="font-size: 26px; line-height: 2.5; padding-left: 40px; margin-bottom: 50px;">
                                <li><strong>2.1</strong> 极限的性质</li>
                                <li><strong>2.2</strong> 极限的四则运算法则</li>
                            </ul>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 30px; border-radius: 12px;">
                                <h3 style="color: #3b82f6; font-size: 28px; margin-bottom: 20px;">2.1 极限的性质</h3>
                                <ul style="font-size: 22px; line-height: 2.2;">
                                    <li><strong>唯一性：</strong>同一条路不可能通向两个不同终点，所以极限要么不存在，要么只有一个答案。</li>
                                    <li><strong>有界性：</strong>既然准备靠近目标，沿途数值自然被限制在一个范围内，不会突然飙到天外去。</li>
                                    <li><strong>保号性：</strong>如果一路上都大于 0，那最终靠近的目标也不会变成负数。</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                `,
                animation: null
            },

            // 第42页：极限的四则运算法则
            {
                title: "2.1 极限的四则运算法则",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>2.1 极限的四则运算法则</h3>
                            <p>设 $\\displaystyle\\lim f(x) = A, \\lim g(x) = B$，则：</p>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <ol style="font-size: 18px; line-height: 2.2;">
                                    <li><strong>和差法则：</strong>$\\displaystyle\\lim [f(x) \\pm g(x)] = A \\pm B$
                                        <br><span style="color: #6b7280; font-size: 16px;">（和差的极限等于极限的和差）</span>
                                    </li>
                                    <li><strong>乘积法则：</strong>$\\displaystyle\\lim [f(x) \\cdot g(x)] = A \\cdot B$
                                        <br><span style="color: #6b7280; font-size: 16px;">（积的极限等于极限的积）</span>
                                    </li>
                                    <li><strong>商法则：</strong>$\\displaystyle\\lim \\frac{f(x)}{g(x)} = \\frac{A}{B}$ （前提：$B \\neq 0$）
                                        <br><span style="color: #6b7280; font-size: 16px;">（商的极限等于极限的商）</span>
                                    </li>
                                </ol>
                            </div>
                            <div class="note">
                                <strong>通俗理解：</strong>求几个函数组合后的极限，可以先分别求出它们各自的极限，再进行组合运算（前提是各自的极限都存在）。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-limit-rules" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "limit_rules"
            },

            // 第43页：极限运算法则 - 互动例题（iframe嵌入）
            {
                title: "极限运算法则 - 互动例题",
                content: ` <div class="iframe-container"><iframe data-src="极限例题.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="极限运算法则互动例题"></iframe></div>`,
                animation: null
            },

            // 实验室：直接代入法求极限游戏
            {
                title: "实验室 - 直接代入法求极限游戏",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-14.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="直接代入法求极限游戏"></iframe></div>`,
                animation: null
            },

            // 实验室：极限求解方法知识图谱
            {
                title: "实验室 - 极限求解方法知识图谱",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-15.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="极限求解方法知识图谱"></iframe></div>`,
                animation: null
            },

            // ========================================
            // 第三节：极限的求法（5页）
            // ========================================

            // 第45页：第三节标题
            {
                title: "第三节 极限的求法",
                content: `
                    <div class="slide-container">
                        <div style="width: 100%; padding: 40px; display: flex; flex-direction: column; justify-content: center;">
                            <h2 style="font-size: 48px; margin-bottom: 50px; text-align: center; color: #3b82f6;">第三节 极限的求法</h2>
                            <h3 style="font-size: 32px; margin-bottom: 40px; color: #374151;">本节内容</h3>
                            <ul style="font-size: 26px; line-height: 2.5; padding-left: 40px;">
                                <li><strong>3.1</strong> 直接代入法</li>
                                <li><strong>3.2</strong> 约去零因子法</li>
                                <li><strong>3.3</strong> 分子或分母有理化</li>
                                <li><strong>3.4</strong> 倒数法及其他技巧</li>
                            </ul>
                        </div>
                    </div>
                `,
                animation: null
            },

            // 第46页：3.1 直接代入法
            {
                title: "3.1 直接代入法",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>3.1 直接代入法</h3>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>例1</strong> 求 $\\displaystyle\\lim_{x \\to 1} \\frac{3x^2 + x + 1}{4x^3 + x^2 - x + 3}$
                                <br><br>
                                <strong>解：</strong>$\\displaystyle\\frac{3(1)^2 + 1 + 1}{4(1)^3 + 1^2 - 1 + 3} = \\frac{5}{7}$
                            </div>
                            <div class="note">
                                <strong>方法说明：</strong>当函数在某点连续时，可以直接将该点的值代入函数，得到极限值。这是最简单的求极限方法。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-direct-sub" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "direct_substitution"
            },

            // 第47页：3.2 约去零因子法
            {
                title: "3.2 约去零因子法",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>3.2 约去零因子法</h3>
                            <p>$\\displaystyle\\frac{0}{0}$ 型极限被称为"未定式"。它就像一场拔河比赛，分子想把结果拉向0，分母想把结果拉向无穷大。</p>
                            <p><strong>方法：</strong>将分子或分母分解因式，<strong>约去共同的零因子</strong>，再用直接代入法。</p>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>例2</strong> 求 $\\displaystyle\\lim_{x \\to 2} \\frac{x^2-4}{x-2}$
                                <br><br>
                                <strong>解：</strong>$\\displaystyle\\lim_{x \\to 2} \\frac{(x-2)(x+2)}{x-2} = \\lim_{x \\to 2} (x+2) = 4$
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-zero-factor" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "zero_factor_cancellation"
            },

            // 第48页：3.3 分子或分母有理化
            {
                title: "3.3 分子或分母有理化",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>3.3 分子或分母有理化</h3>
                            <div style="background: rgba(245, 158, 11, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>例3</strong> 求 $\\displaystyle\\lim_{x \\to 4} \\frac{x-4}{\\sqrt{x-2}-\\sqrt{2}}$
                                <br><br>
                                <strong>解：</strong>
                                $$\\displaystyle\\lim_{x \\to 4} \\frac{(x-4)(\\sqrt{x-2}+\\sqrt{2})}{(\\sqrt{x-2}-\\sqrt{2})(\\sqrt{x-2}+\\sqrt{2})} = \\lim_{x \\to 4} (\\sqrt{x-2}+\\sqrt{2}) = 2\\sqrt{2}$$
                            </div>
                            <div class="note">
                                <strong>方法说明：</strong>当分子或分母含有根式时，通过有理化可以化简表达式，消除 $\\displaystyle\\frac{0}{0}$ 或 $\\displaystyle\\frac{\\infty}{\\infty}$ 型未定式。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-rationalize" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "rationalization_method"
            },

            // 第49页：3.4 倒数法及其他技巧
            {
                title: "3.4 倒数法及其他技巧",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>3.4 倒数法及其他技巧</h3>
                            <h4>∞/∞型有理分式的处理（抓大头法则）</h4>
                            <div style="background: rgba(139, 92, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                $$
                                \\displaystyle
                                \\lim_{x\\to\\infty}
                                \\frac{a_{n}x^{n}+a_{n-1}x^{n-1}+\\cdots+a_{0}}{b_{m}x^{m}+b_{m-1}x^{m-1}+\\cdots+b_{0}}
                                =
                                \\begin{cases}
                                    \\dfrac{a_{n}}{b_{m}}, & n = m \\\\
                                    0, & n < m \\\\
                                    \\infty, & n > m
                                \\end{cases}
                                $$
                            </div>
                            <p>极限的结果，取决于分子和分母中"跑得最快的那个领头项"。</p>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>例4</strong> 求 $\\displaystyle\\lim_{x \\to \\infty} \\frac{3x^2 + 2x + 1}{2x^2 - x + 5}$
                                <br><br>
                                <strong>解：</strong>最高次项都是 $x^2$，所以极限 = $\\displaystyle\\frac{3}{2}$
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-leading-term" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "leading_term_method"
            },

            // ========================================
            // 第四节：两个重要极限及无穷小的比较（16页）
            // ========================================

            // 第50页：第四节标题
            {
                title: "第四节 两个重要极限及无穷小的比较",
                content: `
                    <div class="slide-container">
                        <div style="width: 100%; padding: 40px; display: flex; flex-direction: column; justify-content: center;">
                            <h2 style="font-size: 48px; margin-bottom: 50px; text-align: center; color: #3b82f6;">第四节 两个重要极限及无穷小的比较</h2>
                            <h3 style="font-size: 32px; margin-bottom: 40px; color: #374151;">本节内容</h3>
                            <ul style="font-size: 26px; line-height: 2.5; padding-left: 40px; margin-bottom: 40px;">
                                <li><strong>4.1</strong> 两个重要极限</li>
                                <li><strong>4.2</strong> 无穷小的比较</li>
                            </ul>
                            <p style="font-size: 24px; color: #6b7280; padding: 30px; background: rgba(107, 114, 128, 0.05); border-radius: 12px; border-left: 5px solid #3b82f6;">
                                除了基本的四则运算法则，还有两个"公式级"的重要极限，是解决更复杂极限问题的关键工具。
                            </p>
                        </div>
                    </div>
                `,
                animation: null
            },

            // 第51页：4.1 两个重要极限
            {
                title: "4.1 两个重要极限",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>4.1 两个重要极限</h3>
                            <h4 style="color: #3b82f6;">第一个重要极限</h4>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
                                $$\\displaystyle\\lim_{x\\to 0}\\frac{\\sin x}{x}=1$$
                            </div>
                            <p>这个极限揭示了正弦函数在原点附近的局部性质，是<strong>微分学的基础</strong>。</p>
                            <div class="note">
                                <strong>几何意义：</strong>当角度很小时，正弦值与弧长几乎相等。
                            </div>
                            <h4 style="color: #10b981; margin-top: 30px;">第二个重要极限</h4>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center;">
                                $$\\displaystyle\\lim_{x\\to\\infty}\\left(1+\\frac{1}{x}\\right)^{x}=e$$
                            </div>
                            <div class="note">
                                <strong>经济学背景：</strong>该极限源于连续复利模型。如果银行的计息周期无限缩短，那么最终的本息和将趋向于初始存款的 $e$ 倍。自然常数 $e \\approx 2.718$ 是自然增长的极限模式。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-two-limits" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "two_important_limits"
            },

            // 实验室：重要极限实验室
            {
                title: "实验室 - 重要极限",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-6.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="重要极限实验室"></iframe></div>`,
                animation: null
            },

            // 第53页：4.2 无穷小的比较 - 概念引入
            {
                title: "4.2 无穷小的比较",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>4.2 无穷小的比较</h3>
                            <p>设 $\\alpha(x), \\beta(x)$ 是在 $x\\to 0$ 时趋向 0 的量，通过比较 $\\displaystyle\\lim_{x\\to 0}\\frac{\\beta(x)}{\\alpha(x)}$ 的数值来判断谁"跑得更快"。</p>
                            <div style="display: grid; gap: 12px; margin: 20px 0;">
                                <div style="background: rgba(52, 152, 219, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #3498db;">
                                    <strong>高阶无穷小：</strong>$\\displaystyle\\lim_{x\\to 0}\\frac{\\beta(x)}{\\alpha(x)}=0$ → $\\beta$ 比 $\\alpha$ "小得更快"
                                </div>
                                <div style="background: rgba(231, 76, 60, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                                    <strong>低阶无穷小：</strong>$\\displaystyle\\lim_{x\\to 0}\\frac{\\beta(x)}{\\alpha(x)}=\\infty$ → $\\beta$ 比 $\\alpha$ "小得更慢"
                                </div>
                                <div style="background: rgba(155, 89, 182, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                                    <strong>同阶无穷小：</strong>$\\displaystyle\\lim_{x\\to 0}\\frac{\\beta(x)}{\\alpha(x)}=c\\neq0$ → $\\beta$ 与 $\\alpha$ "小得一样快"
                                </div>
                                <div style="background: rgba(46, 204, 113, 0.1); padding: 15px; border-radius: 8px; border-left: 4px solid #2ecc71;">
                                    <strong>等价无穷小：</strong>$\\displaystyle\\lim_{x\\to 0}\\frac{\\beta(x)}{\\alpha(x)}=1$ → $\\beta$ 与 $\\alpha$ "几乎相等"，记作 $\\alpha\\sim\\beta$
                                </div>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-infinitesimal-compare" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "infinitesimal_comparison_intro"
            },

            // 第54页：高阶无穷小
            {
                title: "(1) 高阶无穷小",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>(1) 高阶无穷小：掉得更快</h4>
                            <div style="background: rgba(52, 152, 219, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #3498db; margin: 20px 0;">
                                <p><strong>定义：</strong>若 $\\displaystyle\\lim_{x\\to 0}\\frac{\\beta(x)}{\\alpha(x)}=0$，则 $\\beta = o(\\alpha)$，即 $\\beta$ 比 $\\alpha$ "小得更快"。</p>
                            </div>
                            <div style="margin: 20px 0;">
                                <h4>典型例子</h4>
                                <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                    <p><strong>例1：</strong>当 $x \\to 0$，$\\displaystyle\\frac{x^2}{x} \\to 0$，因此 $x^2$ 是 $x$ 的高阶无穷小。</p>
                                </div>
                                <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px;">
                                    <p><strong>例2：</strong>当 $x \\to 0$，$\\displaystyle\\frac{x^3}{x} \\to 0$，因此 $x^3$ 也是 $x$ 的高阶无穷小。</p>
                                </div>
                            </div>
                            <div class="note">高阶无穷小"俯冲"得最迅速，是我们判断收敛速度的标杆。</div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-higher-order" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "higher_order_infinitesimal"
            },

            // 第55页：低阶无穷小
            {
                title: "(2) 低阶无穷小",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>(2) 低阶无穷小：掉得更慢</h4>
                            <div style="background: rgba(231, 76, 60, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #e74c3c; margin: 20px 0;">
                                <p><strong>定义：</strong>若 $\\displaystyle\\lim_{x\\to 0}\\frac{\\beta(x)}{\\alpha(x)}=\\infty$，则 $\\beta$ 是比 $\\alpha$ 更低阶的无穷小。</p>
                            </div>
                            <div style="margin: 20px 0;">
                                <h4>典型例子</h4>
                                <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                    <p><strong>例1：</strong>当 $x \\to 0$，$\\displaystyle\\frac{x}{x^2} \\to \\infty$，因此 $x$ 是比 $x^2$ 更低阶的无穷小。</p>
                                </div>
                                <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px;">
                                    <p><strong>例2：</strong>当 $x \\to 0^+$，$\\displaystyle\\frac{\\sqrt{x}}{x} \\to \\infty$，因此 $\\sqrt{x}$ 低于 $x$。</p>
                                </div>
                            </div>
                            <div class="note">低阶无穷小像"慢跑者"，需要更长时间才能接近 0。</div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-lower-order" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "lower_order_infinitesimal"
            },

            // 第56页：同阶无穷小
            {
                title: "(3) 同阶无穷小",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>(3) 同阶无穷小：并驾齐驱</h4>
                            <div style="background: rgba(155, 89, 182, 0.1); padding: 20px; border-radius: 10px; border-left: 4px solid #9b59b6; margin: 20px 0;">
                                <p><strong>定义：</strong>若 $\\displaystyle\\lim_{x\\to 0}\\frac{\\beta(x)}{\\alpha(x)}=c\\neq0$，则 $\\beta$ 与 $\\alpha$ 是同阶无穷小。</p>
                                <p><strong>理解：</strong>两个量朝 0 的"速度"一致。</p>
                            </div>
                            <div style="margin: 20px 0;">
                                <h4>典型例子</h4>
                                <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                                    <p><strong>例1：</strong>$\\displaystyle\\frac{2x}{x} \\to 2$，因此 $2x$ 与 $x$ 同阶。</p>
                                </div>
                                <div style="background: rgba(255, 255, 255, 0.75); padding: 15px; border-radius: 8px;">
                                    <p><strong>例2：</strong>$\\displaystyle\\frac{3x^2}{x^2} \\to 3$，因此 $3x^2$ 与 $x^2$ 同阶。</p>
                                </div>
                            </div>
                            <div class="note">两个选手并肩冲线，意味着它们可以互相比较也能互换尺度。</div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-same-order" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "same_order_infinitesimal"
            },

            // 实验室：无穷小比较实验室
            {
                title: "实验室 - 无穷小比较",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-7.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="无穷小比较实验室"></iframe></div>`,
                animation: null
            },

            // 第58页：等价无穷小 - 定义与意义
            {
                title: "4. 等价无穷小：定义与意义",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>4. 等价无穷小：计算里的黄金搭档</h4>
                            <div style="background: rgba(46, 204, 113, 0.12); padding: 20px; border-radius: 10px; border-left: 4px solid #2ecc71; margin: 20px 0;">
                                <p><strong>定义：</strong>若 $\\displaystyle\\lim_{x\\to 0}\\frac{\\beta(x)}{\\alpha(x)}=1$，记作 $\\alpha\\sim\\beta$，它们在极限运算中可以互换。</p>
                                <p><strong>意义：</strong>把复杂表达式换成熟悉的"替身"，能显著简化极限运算。</p>
                            </div>
                            <div class="note">等价无穷小是一对"影分身"，随时可以无缝替换。</div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-equivalent" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "equivalent_infinitesimal_concept"
            },

            // 第59页：常用等价无穷小公式表
            {
                title: "5. 常用等价无穷小公式表",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>5. 常用的等价无穷小（当 $x\\to 0$ 时）</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                                <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px;">
                                    <h5 style="color: #3b82f6; margin-bottom: 15px;">三角函数类</h5>
                                    <p>$\\sin x \\sim x$</p>
                                    <p>$\\tan x \\sim x$</p>
                                    <p>$\\arcsin x \\sim x$</p>
                                    <p>$\\arctan x \\sim x$</p>
                                </div>
                                <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px;">
                                    <h5 style="color: #10b981; margin-bottom: 15px;">指数对数类</h5>
                                    <p>$1-\\cos x \\sim \\dfrac{1}{2}x^{2}$</p>
                                    <p>$\\ln(1+x) \\sim x$</p>
                                    <p>$e^{x}-1 \\sim x$</p>
                                    <p>$\\sqrt{1+x}-1 \\sim \\dfrac{1}{2}x$</p>
                                </div>
                            </div>
                            <div class="note">等价无穷小可以在极限运算中<strong>直接互换</strong>，记得附带"$x\\to 0$"这一前提条件。</div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-equivalent-formulas" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "equivalent_infinitesimal_formulas"
            },

            // 实验室：函数增量实验室
            {
                title: "实验室 - 函数增量",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-8.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="函数增量实验室"></iframe></div>`,
                animation: null
            },

            // 实验室：等价无穷小倒水游戏
            {
                title: "实验室 - 等价无穷小倒水游戏",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-9.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="等价无穷小倒水游戏"></iframe></div>`,
                animation: null
            },

            // ========================================
            // 第五节：函数的连续性（12页）
            // ========================================

            // 第62页：第五节标题
            {
                title: "第五节 函数的连续性",
                content: `
                    <div class="slide-container">
                        <div style="width: 100%; padding: 40px; display: flex; flex-direction: column; justify-content: center;">
                            <h2 style="font-size: 48px; margin-bottom: 50px; text-align: center; color: #3b82f6;">第五节 函数的连续性</h2>
                            <h3 style="font-size: 32px; margin-bottom: 40px; color: #374151;">本节内容</h3>
                            <ul style="font-size: 26px; line-height: 2.5; padding-left: 40px; margin-bottom: 40px;">
                                <li><strong>5.1</strong> 连续函数的概念</li>
                                <li><strong>5.2</strong> 函数的间断点</li>
                                <li><strong>5.3</strong> 初等函数的连续性</li>
                                <li><strong>5.4</strong> 闭区间上连续函数的性质</li>
                            </ul>
                            <p style="font-size: 24px; color: #6b7280; padding: 30px; background: rgba(107, 114, 128, 0.05); border-radius: 12px; border-left: 5px solid #3b82f6;">
                                我们最早接触的求极限方法——直接代入法，需要函数在目标点附近表现"平滑"。
                            </p>
                        </div>
                    </div>
                `,
                animation: null
            },

            // 第63页：连续性的直观理解
            {
                title: "5.1 连续性的直观理解",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>5.1 连续性的直观理解</h3>
                            <p style="font-size: 20px; margin: 20px 0;">想象在纸上画函数图像：如果笔尖可以一路滑过去而不需要抬起，这个点就被称为<strong>连续</strong>。</p>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <h4>连续的直观含义</h4>
                                <p>函数图像在该点不"断裂"，可以一笔画出。</p>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-continuity-concept" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "continuity_concept"
            },

            // 第64页：函数连续的严格定义
            {
                title: "5.1 函数连续的严格定义（三条件）",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>5.1 函数连续的严格定义（三条件）</h3>
                            <p>函数 $f(x)$ 在 $x_0$ 处连续，当且仅当以下三件事同时成立：</p>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <ol style="font-size: 18px; line-height: 2;">
                                    <li>$f(x_0)$ 有定义（目标存在）</li>
                                    <li>$\\displaystyle\\lim_{x\\to x_0} f(x)$ 存在（左右隧道会师）</li>
                                    <li>极限值等于函数值（会师点正好落在目标点）</li>
                                </ol>
                            </div>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px; margin: 20px 0; text-align: center;">
                                $$\\displaystyle\\lim_{x \\to x_0} f(x) = f(x_0)$$
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-continuity-three" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "continuity_three_conditions"
            },

            // 第65页：实验室：函数连续性实验室
            {
                title: "实验室 - 函数连续性",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-11.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="函数连续性实验室"></iframe></div>`,
                animation: null
            },

            // 第66页：间断点的初步诊断
            {
                title: "5.1 间断点的初步诊断",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>5.1 诊断间断点：哪一步出了问题？</h3>
                            <div style="margin: 20px 0;">
                                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    <strong>可去间断：</strong>极限存在，但 $f(x_0)$ 没定义或不等于极限 —— "把缺口补上即可。"
                                </div>
                                <div style="background: rgba(245, 158, 11, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                    <strong>跳跃间断：</strong>左右极限存在但不相等 —— "两支队伍高度对不上。"
                                </div>
                                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px;">
                                    <strong>无穷间断：</strong>至少一侧极限为无穷 —— "隧道挖进了无底洞。"
                                </div>
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-discontinuity-diagnose" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "discontinuity_diagnose_visual"
            },

            // 第67页：5.2 函数的间断点
            {
                title: "5.2 函数的间断点",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>5.2 函数的间断点</h3>
                            <p>函数不连续的点称为<strong>间断点</strong>。有三种情形：</p>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <ol style="font-size: 18px; line-height: 2;">
                                    <li>在 $x_0$ 点无定义</li>
                                    <li>在 $x_0$ 点极限不存在</li>
                                    <li>极限存在但不等于函数值</li>
                                </ol>
                            </div>
                            <div class="note">间断点可分为<strong>可去间断点</strong>和<strong>跳跃间断点</strong>等类型。</div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-discontinuity-types" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "discontinuity_types_demo"
            },

            // 第68页：第一类间断点
            {
                title: "5.2 间断点分类 1：第一类间断点（可去、跳跃）",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>5.2 第一类间断点 (左右极限都存在)</h4>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>可去间断点</strong>：就像路上的一个<strong>小坑</strong>。左右极限相等，但该点无定义或函数值不等于极限值。
                            </div>
                            <div style="background: rgba(245, 158, 11, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>跳跃间断点</strong>：就像路上的一个<strong>台阶</strong>。左右极限存在但不相等。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-first-discontinuity" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "first_discontinuity"
            },

            // 第69页：第二类间断点
            {
                title: "5.2 间断点分类 2：第二类间断点（无穷、震荡）",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h4>5.2 第二类间断点 (至少一个极限不存在)</h4>
                            <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>无穷间断点</strong>：就像一个<strong>无底深渊</strong>。极限为无穷大，如 $y = \\tan x$ 在 $x = \\dfrac{\\pi}{2}$ 处。
                            </div>
                            <div style="background: rgba(139, 92, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>震荡间断点</strong>：就像一个<strong>地震带</strong>。函数在某点附近无限次震荡，如 $y = \\sin \\dfrac{1}{x}$ 在 $x=0$ 处。
                            </div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-second-discontinuity" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "second_discontinuity"
            },

            // 第72页：5.3 初等函数的连续性
            {
                title: "5.3 初等函数的连续性",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>5.3 初等函数的连续性</h3>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                                <strong>定理：</strong>一切初等函数在其定义区间内都是连续的。
                            </div>
                            <div class="note">这意味着对于多项式、指数、对数、三角函数等，我们只需在定义域的分界点、或可能导致分母为0的点检查连续性。</div>
                            <h4 style="margin-top: 30px;">常见初等函数的连续性</h4>
                            <ul style="font-size: 18px; line-height: 2;">
                                <li>多项式函数：在整个实数轴上连续</li>
                                <li>有理函数：在分母不为0的点连续</li>
                                <li>指数函数、对数函数：在定义域内连续</li>
                                <li>三角函数：在定义域内连续</li>
                            </ul>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-elementary" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "elementary_continuity_visual"
            },

            // 第73页：5.4 闭区间上连续函数的性质   
            {
                title: "5.4 闭区间上连续函数的性质",
                content: `
                    <div class="slide-container">
                        <div class="left-content">
                            <h3>5.4 闭区间上连续函数的性质</h3>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong>有界性定理：</strong>在闭区间 $[a,b]$ 上连续的函数必定有界。
                            </div>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong>最值定理：</strong>在闭区间 $[a,b]$ 上连续的函数必定取得最大值和最小值。
                            </div>
                            <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0;">
                                <strong>中间值定理：</strong>设函数 $f(x)$ 在闭区间 $[a,b]$ 上连续，且 $f(a) \\neq f(b)$，则对于 $f(a)$ 和 $f(b)$ 之间的任意值 $C$，必存在 $\\xi \\in (a,b)$，使得 $f(\\xi) = C$。
                            </div>
                            <div class="note">这些性质为优化问题、方程求解等提供了理论基础。</div>
                        </div>
                        <div class="right-visual">
                            <canvas id="canvas-closed-interval" width="720" height="500"></canvas>
                        </div>
                    </div>
                `,
                animation: "closed_interval_properties_visual"
            },

            // 第74页：实验室：极限与连续游戏（综合）
            {
                title: "实验室 - 极限与连续游戏",
                content: `<div class="iframe-container"><iframe data-src="../网页资源/lab 2-13.html" loading="lazy" style="width:100vw;height:100vh;border:none;" title="极限与连续游戏"></iframe></div>`,
                animation: null
            },

            // 第75页：总结与练习   
            {
                title: "总结与练习",
                content: `
                    <div class="slide-container">
                        <div style="width: 100%; padding: 40px; display: flex; flex-direction: column; justify-content: center;">
                            <h2 style="font-size: 48px; margin-bottom: 50px; text-align: center; color: #10b981;">总结与练习</h2>
                            <p style="font-size: 26px; margin-bottom: 40px; line-height: 1.8;">本章我们学习了极限的概念、性质、运算法则，以及函数的连续性理论。现在通过几道综合题来检验学习效果。</p>
                            <div style="background: rgba(59, 130, 246, 0.1); padding: 40px; border-radius: 12px; border-left: 6px solid #3b82f6;">
                                <h3 style="color: #3b82f6; margin-bottom: 30px; font-size: 32px;">本章核心概念总结</h3>
                                <ul style="font-size: 24px; line-height: 2.8; padding-left: 30px;">
                                    <li><strong>极限</strong>：函数变化的"目标值"</li>
                                    <li><strong>连续</strong>：没有"跳跃"的函数</li>
                                    <li><strong>无穷小</strong>：趋向于0的变量</li>
                                    <li><strong>两个重要极限</strong>：微积分的基石</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                `,
                animation: null
            }
        ];

        // ========================================
        // 动画基类 - 统一管理所有动画
        // 用户需求：简化代码，统一清理机制，避免重叠
        // ========================================
        class Animation {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    console.warn(`Canvas ${canvasId} 未找到`);
                    this.isValid = false;
                    return;
                }
                this.isValid = true;
                this.ctx = this.canvas.getContext('2d');
                this.animationFrame = null;
                this.isRunning = false;
                this.width = 0;
                this.height = 0;
                this.dpr = 1;

                // 延迟初始化尺寸，确保容器已渲染
                requestAnimationFrame(() => this.updateCanvasSize());
            }

            // 更新Canvas尺寸以适应容器
            updateCanvasSize() {
                if (!this.canvas || !this.isValid) return;

                const container = this.canvas.parentElement;
                if (!container) return;
                
                const rect = container.getBoundingClientRect();

                // 防止尺寸为0
                const displayWidth = Math.max(100, Math.floor(rect.width));
                const displayHeight = Math.max(100, Math.floor(rect.height));

                // 获取设备像素比以支持高DPI屏幕
                const dpr = window.devicePixelRatio || 1;

                // 设置实际尺寸（考虑设备像素比）
                this.canvas.width = displayWidth * dpr;
                this.canvas.height = displayHeight * dpr;

                // 设置CSS尺寸
                this.canvas.style.width = displayWidth + 'px';
                this.canvas.style.height = displayHeight + 'px';

                // 缩放上下文以匹配设备像素比
                if (this.ctx) {
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.scale(dpr, dpr);
                }

                // 更新宽高属性
                this.width = displayWidth;
                this.height = displayHeight;
                this.dpr = dpr;
            }

            // 清除画布
            clear() {
                if (!this.ctx) return;
                // 先用单位矩阵清除设备像素大小的画布，再恢复DPR缩放
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // 恢复到与CSS像素一致的缩放
                const scale = this.dpr || (window.devicePixelRatio || 1);
                this.ctx.setTransform(scale, 0, 0, scale, 0, 0);
                this.ctx.globalAlpha = 1.0;
                this.ctx.shadowBlur = 0;
            }

            // 启动动画
            start() {
                if (!this.isValid || this.isRunning) return;
                this.isRunning = true;
                this.updateCanvasSize();
                this.animate();
            }

            // 停止动画
            stop() {
                this.isRunning = false;
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
                // 清理画布
                if (this.ctx && this.canvas) {
                    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            // 动画循环（子类重写）
            animate() {
                if (!this.isRunning || !this.isValid) return;
                this.clear();
                this.draw();
                this.animationFrame = requestAnimationFrame(() => this.animate());
            }

            // 绘制函数（子类实现）
            draw() {
                // 子类实现具体绘制逻辑
            }
        }

        // ========================================
        // 工具函数库
        // ========================================

        // 转换数学文本为Unicode（用于Canvas显示）
        function formatMathText(text) {
            // 下标转换映射
            const subscriptMap = {
                '0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄',
                '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉',
                'n': 'ₙ', 'i': 'ᵢ', 'j': 'ⱼ', 'k': 'ₖ'
            };

            // 上标转换映射
            const superscriptMap = {
                '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴',
                '5': '⁵', '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹',
                'n': 'ⁿ', 'x': 'ˣ', '+': '⁺', '-': '⁻'
            };

            let result = text;

            // 转换下标 x_n -> xₙ
            result = result.replace(/([a-zA-Z])_([0-9nijk])/g, (match, base, sub) => {
                return base + (subscriptMap[sub] || sub);
            });

            // 转换上标 x^2 -> x²
            result = result.replace(/([a-zA-Z])\^([0-9nx+-])/g, (match, base, sup) => {
                return base + (superscriptMap[sup] || sup);
            });

            // 常见符号替换
            result = result.replace(/->|→/g, '→');
            result = result.replace(/<-|←/g, '←');
            result = result.replace(/infinity|∞/g, '∞');
            result = result.replace(/alpha|α/g, 'α');
            result = result.replace(/beta|β/g, 'β');
            result = result.replace(/delta|Δ/g, 'Δ');
            result = result.replace(/epsilon|ε/g, 'ε');
            result = result.replace(/pi|π/g, 'π');

            return result;
        }

        // 绘制坐标系
        function drawCoordinateSystem(ctx, canvas, options = {}) {
            const w = (canvas.clientWidth || parseInt(canvas.style.width) || canvas.width);
            const h = (canvas.clientHeight || parseInt(canvas.style.height) || canvas.height);
            const {
                originX = w / 2,
                originY = h / 2,
                axisColor = '#374151',
                lineWidth = 2,
                showLabels = true,
                xLabel = 'x',
                yLabel = 'y'
            } = options;

            ctx.save();
            ctx.strokeStyle = axisColor;
            ctx.lineWidth = lineWidth;

            // X轴
            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(w, originY);
            ctx.stroke();

            // Y轴
            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, h);
            ctx.stroke();

            // 箭头
            const arrowSize = 10;
            ctx.fillStyle = axisColor;
            // X轴箭头
            ctx.beginPath();
            ctx.moveTo(w - arrowSize, originY - arrowSize / 2);
            ctx.lineTo(w, originY);
            ctx.lineTo(w - arrowSize, originY + arrowSize / 2);
            ctx.fill();

            // Y轴箭头
            ctx.beginPath();
            ctx.moveTo(originX - arrowSize / 2, arrowSize);
            ctx.lineTo(originX, 0);
            ctx.lineTo(originX + arrowSize / 2, arrowSize);
            ctx.fill();

            if (showLabels) {
                ctx.fillStyle = axisColor;
                ctx.font = 'bold 18px Arial';
                ctx.fillText(xLabel, w - 25, originY + 25);
                ctx.fillText(yLabel, originX + 15, 20);
                ctx.font = '14px Arial';
                ctx.fillText('O', originX - 20, originY + 20);
            }

            ctx.restore();
        }

        // 坐标转换函数生成器
        function createCoordinateTransform(canvas, xMin, xMax, yMin, yMax, padding = 50) {
            const w = (canvas.clientWidth || parseInt(canvas.style.width) || canvas.width);
            const h = (canvas.clientHeight || parseInt(canvas.style.height) || canvas.height);
            const width = w - 2 * padding;
            const height = h - 2 * padding;

            return {
                toCanvasX: (x) => ((x - xMin) / (xMax - xMin)) * width + padding,
                toCanvasY: (y) => h - padding - ((y - yMin) / (yMax - yMin)) * height,
                originX: ((0 - xMin) / (xMax - xMin)) * width + padding,
                originY: h - padding - ((0 - yMin) / (yMax - yMin)) * height
            };
        }

        // ========================================
        // 幻灯片管理
        // ========================================

        function showSlide(n) {
            // 彻底停止当前动画
            if (activeAnimation) {
                try {
                    activeAnimation.stop();
                    activeAnimation = null;
                } catch (e) {
                    console.warn('停止动画时出错:', e);
                }
            }

            const slides = document.querySelectorAll('.slide');
            if (!slides.length) return;
            
            currentSlide = (n > totalSlides) ? 1 : (n < 1) ? totalSlides : n;

            // 更新显示
            slides.forEach((slide, index) => {
                slide.classList.toggle('active', index === currentSlide - 1);
            });

            // 更新页码
            const input = document.getElementById('slideNumberInput');
            if (input) input.value = currentSlide;

            // 安全地渲染公式
            const currentSlideEl = slides[currentSlide - 1];
            
            // iframe 懒加载 - 只有当前幻灯片的 iframe 才加载
            const iframes = currentSlideEl.querySelectorAll('iframe[data-src]');
            iframes.forEach(iframe => {
                if (!iframe.src || iframe.src === 'about:blank') {
                    iframe.src = iframe.dataset.src;
                }
            });
            
            // 卸载非当前幻灯片的 iframe 以释放内存
            slides.forEach((slide, index) => {
                if (index !== currentSlide - 1) {
                    const otherIframes = slide.querySelectorAll('iframe[data-src]');
                    otherIframes.forEach(iframe => {
                        if (iframe.src && iframe.src !== 'about:blank') {
                            iframe.src = 'about:blank';
                        }
                    });
                }
            });
            
            if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                MathJax.typesetPromise([currentSlideEl])
                    .then(() => {
                        setTimeout(() => startAnimation(currentSlide), 100);
                    })
                    .catch(err => {
                        console.warn('MathJax渲染错误:', err);
                        setTimeout(() => startAnimation(currentSlide), 100);
                    });
            } else if (window.MathJax && window.MathJax.startup && window.MathJax.startup.promise) {
                // MathJax 还未完全加载，等待
                MathJax.startup.promise.then(() => {
                    if (typeof MathJax.typesetPromise === 'function') {
                        MathJax.typesetPromise([currentSlideEl]).then(() => {
                            setTimeout(() => startAnimation(currentSlide), 100);
                        }).catch(() => {
                            setTimeout(() => startAnimation(currentSlide), 100);
                        });
                    } else {
                        setTimeout(() => startAnimation(currentSlide), 100);
                    }
                });
            } else {
                // MathJax 不可用，直接启动动画
                setTimeout(() => startAnimation(currentSlide), 100);
            }
        }

        function nextSlide() { showSlide(currentSlide + 1); }
        function prevSlide() { showSlide(currentSlide - 1); }
        function jumpToSlide(n) { showSlide(parseInt(n)); }

        // 启动动画
        function startAnimation(slideNum) {
            const slide = slidesData[slideNum - 1];
            if (!slide || !slide.animation) return;

            // 动画映射表
            const animationMap = {
                // 第一节动画
                'sequence': () => new SequenceAnimation('canvas-sequence'),
                'viewshift': () => new ViewShiftAnimation('canvas-viewshift'),
                'collatz': () => new CollatzAnimation('canvas-collatz'),
                'fibonacci': () => new FibonacciAnimation('canvas-fibonacci'),
                'depreciation': () => new DepreciationAnimation('canvas-depreciation'),
                'trend': () => new TrendAnimation('canvas-trend'),
                'terminal': () => new TerminalAnimation('canvas-terminal'),
                'limitdef': () => new LimitDefAnimation('canvas-limit-def'),
                'target': () => new TargetAnimation('canvas-target'),
                'convergence': () => new ConvergenceAnimation('canvas-convergence'),
                'example1_1': () => new Example1_1Animation('canvas-example1-1'),
                'example1_2': () => new Example1_2Animation('canvas-example1-2'),
                'example1_3': () => new Example1_3Animation('canvas-example1-3'),
                'example1_4': () => new Example1_4Animation('canvas-example1-4'),
                'sequence_function': () => new SequenceFunctionAnimation('canvas-sequence-function'),
                'limit_concept': () => new LimitConceptAnimation('canvas-limit-concept'),
                'domain_approach': () => new DomainApproachAnimation('canvas-domain-approach'),
                'function_infinity': () => new FunctionInfinityAnimation('canvas-function-infinity'),
                'one_over_x': () => new OneOverXAnimation('canvas-one-over-x'),
                'point_limit': () => new PointLimitAnimation('canvas-point-limit'),
                'left_right_limits': () => new LeftRightLimitsAnimation('canvas-left-right-limits'),
                'velocity': () => new VelocityAnimation('canvas-velocity'),
                'population': () => new PopulationAnimation('canvas-population'),
                'arctan': () => new ArctanAnimation('canvas-arctan'),
                'piecewise1': () => new Piecewise1Animation('canvas-piecewise1'),
                'piecewise2': () => new Piecewise2Animation('canvas-piecewise2'),
                'infinitesimal_definition': () => new InfinitesimalDefinitionAnimation('canvas-infinitesimal-definition'),
                'infinitesimal_process_1': () => new InfinitesimalProcess1Animation('canvas-infinitesimal-1'),
                'infinitesimal_context_dependent': () => new InfinitesimalContextAnimation('canvas-infinitesimal-2'),
                'infinitelaw': () => new InfiniteLawAnimation('canvas-infinite-law'),

                // 第二节动画
                'limit_rules': () => new LimitRulesAnimation('canvas-limit-rules'),

                // 第三节动画
                'direct_substitution': () => new DirectSubstitutionAnimation('canvas-direct-sub'),
                'zero_factor_cancellation': () => new ZeroFactorAnimation('canvas-zero-factor'),
                'rationalization_method': () => new RationalizationAnimation('canvas-rationalization'),
                'leading_term_method': () => new LeadingTermAnimation('canvas-leading-term'),

                // 第四节动画
                'two_important_limits': () => new TwoLimitsAnimation('canvas-two-limits'),
                'infinitesimal_comparison_intro': () => new InfinitesimalCompareAnimation('canvas-infinitesimal-compare'),
                'higher_order_infinitesimal': () => new HigherOrderAnimation('canvas-higher-order'),
                'lower_order_infinitesimal': () => new LowerOrderAnimation('canvas-lower-order'),
                'same_order_infinitesimal': () => new SameOrderAnimation('canvas-same-order'),
                'equivalent_infinitesimal_concept': () => new EquivalentConceptAnimation('canvas-equivalent'),
                'equivalent_infinitesimal_formulas': () => new EquivalentFormulasAnimation('canvas-equivalent-formulas'),

                // 第五节动画
                'continuity_concept': () => new ContinuityConceptAnimation('canvas-continuity-concept'),
                'continuity_three_conditions': () => new ContinuityThreeAnimation('canvas-continuity-three'),
                'discontinuity_diagnose_visual': () => new DiscontinuityDiagnoseAnimation('canvas-discontinuity-diagnose'),
                'discontinuity_types_demo': () => new DiscontinuityTypesAnimation('canvas-discontinuity-types'),
                'first_discontinuity': () => new FirstDiscontinuityAnimation('canvas-first-discontinuity'),
                'second_discontinuity': () => new SecondDiscontinuityAnimation('canvas-second-discontinuity'),
                'elementary_continuity_visual': () => new ElementaryContinuityAnimation('canvas-elementary'),
                'closed_interval_properties_visual': () => new ClosedIntervalAnimation('canvas-closed-interval')
            };

            const animationCreator = animationMap[slide.animation];
            if (animationCreator) {
                activeAnimation = animationCreator();
                if (activeAnimation) {
                    activeAnimation.start();

                    // 如果是考拉兹动画，初始化信息显示
                    if (slide.animation === 'collatz' && activeAnimation instanceof CollatzAnimation) {
                        setTimeout(() => {
                            const info = document.getElementById('collatz-info');
                            if (info && activeAnimation.sequence && activeAnimation.sequence.length > 0) {
                                const sequence = activeAnimation.sequence;
                                info.innerHTML = `
                                    <strong>序列长度：</strong>${sequence.length}<br>
                                    <strong>前20项：</strong>${sequence.slice(0, 20).join(' → ')}${sequence.length > 20 ? ' → ...' : ''}
                                `;
                            }
                        }, 50);
                    }
                }
            }
        }

        // ========================================
        // 具体动画实现
        // 用户需求：简洁代码，清晰逻辑，无重叠
        // ========================================

        // 数列动画
        class SequenceAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.n = 1;
                this.maxN = 20;
                this.sequence = [];
            }

            draw() {
                if (!this.ctx) return;

                const padding = 50;
                const width = this.width;
                const height = this.height;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: height - padding,
                    showLabels: true
                });

                // 计算数列值 x_n = n/(n+1)
                const value = this.n / (this.n + 1);
                this.sequence.push({ n: this.n, value: value });

                // 绘制点
                this.ctx.fillStyle = '#3b82f6';
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 2;

                this.sequence.forEach((point, index) => {
                    const x = padding + (point.n / this.maxN) * (width - 2 * padding);
                    const y = height - padding - point.value * (height - 2 * padding);

                    // 绘制点
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();

                    // 连线
                    if (index > 0) {
                        const prevPoint = this.sequence[index - 1];
                        const prevX = padding + (prevPoint.n / this.maxN) * (width - 2 * padding);
                        const prevY = height - padding - prevPoint.value * (height - 2 * padding);
                        this.ctx.beginPath();
                        this.ctx.moveTo(prevX, prevY);
                        this.ctx.lineTo(x, y);
                        this.ctx.stroke();
                    }
                });

                // 绘制极限线 y = 1
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding, height - padding - (height - 2 * padding));
                this.ctx.lineTo(width - padding, height - padding - (height - 2 * padding));
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 显示当前值
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.fillText(`n = ${this.n}`, width - 150, 40);
                this.ctx.fillText(`xₙ = ${value.toFixed(4)}`, width - 150, 70);

                // 更新n
                this.n++;
                if (this.n > this.maxN) {
                    this.n = 1;
                    this.sequence = [];
                }
            }

            animate() {
                if (!this.isRunning) return;
                this.clear();
                this.draw();
                this.animationFrame = requestAnimationFrame(() => {
                    setTimeout(() => this.animate(), 200); // 减慢速度
                });
            }
        }

        // 视角转变动画
        class ViewShiftAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.phase = 0;
            }

            draw() {
                if (!this.ctx) return;
                const width = this.width;
                const height = this.height;
                const centerY = height * 0.5;
                const titleY = height * 0.15;
                const dotRadius = Math.min(width, height) * 0.04;
                const fontSize = Math.min(width, height) * 0.04;
                const titleFontSize = Math.min(width, height) * 0.045;

                this.ctx.clearRect(0, 0, width, height);

                // 左侧：有限视角
                this.ctx.save();
                this.ctx.fillStyle = '#3b82f6';
                this.ctx.font = `bold ${titleFontSize}px Arial`;
                this.ctx.textAlign = 'left';
                this.ctx.fillText('高中：有限视角', width * 0.05, titleY);

                // 绘制前5项
                for (let i = 1; i <= 5; i++) {
                    const x = width * 0.05 + i * (width * 0.07);
                    const y = centerY;
                    this.ctx.fillStyle = '#3b82f6';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, dotRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = `bold ${fontSize}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(i.toString(), x, y + fontSize * 0.3);
                }

                // 说明文字
                this.ctx.fillStyle = '#374151';
                this.ctx.font = `${fontSize * 0.9}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText('只看前n项', width * 0.22, centerY + height * 0.15);
                this.ctx.restore();

                // 右侧：无限视角
                this.ctx.save();
                this.ctx.fillStyle = '#10b981';
                this.ctx.font = `bold ${titleFontSize}px Arial`;
                this.ctx.textAlign = 'left';
                this.ctx.fillText('大学：无限视角', width * 0.52, titleY);

                // 绘制趋向无穷的箭头
                const arrowStartX = width * 0.52;
                const arrowEndX = width * 0.9;
                const arrowY = centerY;

                this.ctx.strokeStyle = '#10b981';
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(arrowStartX, arrowY);
                this.ctx.lineTo(arrowEndX, arrowY);
                this.ctx.stroke();

                // 箭头头部
                const arrowHeadSize = dotRadius * 1.5;
                this.ctx.fillStyle = '#10b981';
                this.ctx.beginPath();
                this.ctx.moveTo(arrowEndX, arrowY);
                this.ctx.lineTo(arrowEndX - arrowHeadSize, arrowY - arrowHeadSize * 0.6);
                this.ctx.lineTo(arrowEndX - arrowHeadSize, arrowY + arrowHeadSize * 0.6);
                this.ctx.closePath();
                this.ctx.fill();

                // 无穷符号和说明
                this.ctx.fillStyle = '#10b981';
                this.ctx.font = `bold ${titleFontSize * 1.2}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.fillText('n → ∞', width * 0.71, arrowY - height * 0.08);

                this.ctx.fillStyle = '#374151';
                this.ctx.font = `${fontSize * 0.9}px Arial`;
                this.ctx.fillText('关注长期趋势', width * 0.71, centerY + height * 0.15);
                this.ctx.restore();
            }
        }

        // Collatz 动画（高职友好型重构版）
        // 用户输入数字后，动态展示考拉兹序列及其变化过程
        // 【可视化设计说明】
        // 1. 坐标系交点为(0,0)，x轴为步数，y轴为数值，符合高职学生直观习惯
        // 2. 颜色与字号风格统一，突出起点、终点
        // 3. 绝无emoji，语言简洁，注释清晰
        // 4. 例题/动画一页一事，界面无冗余
        // 5. 视觉焦点突出折线与关键点

        class CollatzAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.sequence = []; // 当前考拉兹序列
                this.maxValue = 0;  // 序列中的最大值，用于缩放
                this.inputValue = null; // 当前输入的起始数字
                // 默认生成27的序列
                this.setInputValue(27);
            }

            // 设置新的起始数字并生成序列
            setInputValue(n) {
                this.inputValue = n;
                this.sequence = this.generateCollatzSequence(n);
                this.maxValue = Math.max(...this.sequence, 10);
                this.draw();
            }

            // 生成考拉兹序列
            generateCollatzSequence(n) {
                const seq = [];
                let current = n;
                // 限制最大步数，防止死循环
                while (current > 1 && seq.length < 100) {
                    seq.push(current);
                    if (current % 2 === 0) {
                        current = current / 2;
                    } else {
                        current = current * 3 + 1;
                    }
                }
                seq.push(1);
                return seq;
            }

            draw() {
                if (!this.ctx) return;
                const ctx = this.ctx;
                const width = this.width;
                const height = this.height;
                ctx.clearRect(0, 0, width, height);

                const paddingX = width * 0.12;
                const paddingY = height * 0.15;
                const fontSize = Math.min(width, height) * 0.03;
                const dotRadius = Math.min(width, height) * 0.01;
                const lineWidth = Math.max(2, Math.min(width, height) * 0.003);

                // 没有输入时，显示友好提示
                if (!this.sequence || this.sequence.length === 0) {
                    ctx.fillStyle = '#374151';
                    ctx.font = `${fontSize * 1.2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText('请在左侧输入框中输入数字并点击"生成序列"', width / 2, height / 2);
                    return;
                }

                // 绘制标准坐标系（交点为(0,0)）
                drawCoordinateSystem(ctx, this.canvas, {
                    originX: paddingX,
                    originY: height - paddingY,
                    xLabel: '步数',
                    yLabel: '数值'
                });

                // 绘制考拉兹序列折线
                ctx.save();
                ctx.strokeStyle = '#f59e42';
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                const plotWidth = width - 2 * paddingX;
                const plotHeight = height - 2 * paddingY;
                this.sequence.forEach((val, idx) => {
                    // x轴：步数，y轴：数值
                    const x = paddingX + (idx / (this.sequence.length - 1)) * plotWidth;
                    const y = height - paddingY - (val / this.maxValue) * plotHeight;
                    if (idx === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                ctx.restore();

                // 标注起点
                ctx.save();
                ctx.fillStyle = '#f59e42';
                let x0 = paddingX;
                let y0 = height - paddingY - (this.sequence[0] / this.maxValue) * plotHeight;
                ctx.beginPath();
                ctx.arc(x0, y0, dotRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'left';
                ctx.fillText('起点: ' + this.sequence[0], x0 + dotRadius * 2, y0 - dotRadius * 2);
                ctx.restore();

                // 标注终点
                ctx.save();
                ctx.fillStyle = '#f59e42';
                let x1 = paddingX + ((this.sequence.length - 1) / (this.sequence.length - 1)) * plotWidth;
                let y1 = height - paddingY - (1 / this.maxValue) * plotHeight;
                ctx.beginPath();
                ctx.arc(x1, y1, dotRadius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'right';
                ctx.fillText('终点: 1', x1 - dotRadius * 2, y1 - dotRadius * 2);
                ctx.restore();

                // 步数说明（置于上方，突出信息）
                ctx.save();
                ctx.fillStyle = '#374151';
                ctx.font = `bold ${fontSize * 1.1}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(`总步数：${this.sequence.length - 1}`, width / 2, paddingY * 0.5);
                ctx.restore();
            }

            // 添加animate方法以兼容Animation基类
            animate() {
                // Collatz动画是静态的，不需要持续动画
                // 只在setInputValue时重绘
            }
        }

        // 斐波那契动画
        class FibonacciAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.fib = [1, 1];
                this.ratios = [];
                this.n = 2;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 计算下一个斐波那契数
                if (this.n < 20) {
                    const next = this.fib[this.n - 1] + this.fib[this.n - 2];
                    this.fib.push(next);
                    const ratio = this.fib[this.n] / this.fib[this.n - 1];
                    this.ratios.push(ratio);
                    this.n++;
                }

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: height - padding
                });

                // 绘制比值趋势
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();

                this.ratios.forEach((ratio, index) => {
                    const x = padding + (index / 20) * (width - 2 * padding);
                    const y = height - padding - ((ratio - 1) / 0.7) * (height - 2 * padding);

                    if (index === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();

                // 绘制黄金分割线
                const goldenRatio = 1.618;
                const goldenY = height - padding - ((goldenRatio - 1) / 0.7) * (height - 2 * padding);
                this.ctx.strokeStyle = '#f59e0b';
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding, goldenY);
                this.ctx.lineTo(width - padding, goldenY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 显示当前比值
                if (this.ratios.length > 0) {
                    const currentRatio = this.ratios[this.ratios.length - 1];
                    this.ctx.fillStyle = '#1f2937';
                    this.ctx.font = 'bold 18px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(`当前比值: ${currentRatio.toFixed(6)}`, width - 250, 40);
                    this.ctx.fillText(`黄金分割: 1.618034`, width - 250, 70);
                }
            }

            animate() {
                if (!this.isRunning) return;
                this.clear();
                this.draw();
                this.animationFrame = requestAnimationFrame(() => {
                    setTimeout(() => this.animate(), 300);
                });
            }
        }

        // 折旧动画
        class DepreciationAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.year = 0;
                this.maxYear = 30;
                this.values = [];
                this.V0 = 100000;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 计算当前价值
                const value = this.V0 * Math.pow(0.9, this.year);
                this.values.push({ year: this.year, value: value });

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: height - padding
                });

                // 绘制曲线
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                this.values.forEach((point, index) => {
                    const x = padding + (point.year / this.maxYear) * (width - 2 * padding);
                    const y = height - padding - (point.value / this.V0) * (height - 2 * padding);

                    if (index === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                });
                this.ctx.stroke();

                // 显示当前值
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`年份: ${this.year}`, width - 200, 40);
                this.ctx.fillText(`价值: ¥${value.toFixed(0)}`, width - 200, 70);

                this.year++;
                if (this.year > this.maxYear) {
                    this.year = 0;
                    this.values = [];
                }
            }

            animate() {
                if (!this.isRunning) return;
                this.clear();
                this.draw();
                this.animationFrame = requestAnimationFrame(() => {
                    setTimeout(() => this.animate(), 200);
                });
            }
        }

        // 趋势观察动画
        class TrendAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.n = 1;
                this.maxN = 100;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const width = this.width;
                const height = this.height;

                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: height - padding
                });

                // 绘制 x_n = n/(n+1) 的点
                this.ctx.fillStyle = '#3b82f6';
                for (let i = 1; i <= this.n; i++) {
                    const value = i / (i + 1);
                    const x = padding + (i / this.maxN) * (width - 2 * padding);
                    const y = height - padding - value * (height - 2 * padding);

                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 极限线 y = 1
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding, padding);
                this.ctx.lineTo(width - padding, padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = '16px Arial';
                this.ctx.fillText('极限 = 1', width - 100, padding - 10);

                this.n++;
                if (this.n > this.maxN) this.n = 1;
            }

            animate() {
                if (!this.isRunning) return;
                this.clear();
                this.draw();
                this.animationFrame = requestAnimationFrame(() => {
                    setTimeout(() => this.animate(), 100);
                });
            }
        }

        // 终点行为动画
        class TerminalAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.n = 0;
            }

            draw() {
                if (!this.ctx) return;
                const width = this.width;
                const height = this.height;
                const sectionWidth = width / 3;

                // 收敛
                this.ctx.fillStyle = '#10b981';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('收敛', sectionWidth / 2, 40);

                for (let i = 0; i <= this.n && i < 20; i++) {
                    const value = 1 / (i + 1);
                    const y = 100 + value * 200;
                    this.ctx.beginPath();
                    this.ctx.arc(sectionWidth / 2, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 发散
                this.ctx.fillStyle = '#ef4444';
                this.ctx.fillText('发散到无穷', sectionWidth + sectionWidth / 2, 40);

                for (let i = 0; i <= this.n && i < 10; i++) {
                    const value = i * i;
                    const y = 100 + Math.min(value * 2, 300);
                    this.ctx.beginPath();
                    this.ctx.arc(sectionWidth + sectionWidth / 2, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 摆动
                this.ctx.fillStyle = '#f59e0b';
                this.ctx.fillText('摆动发散', 2 * sectionWidth + sectionWidth / 2, 40);

                for (let i = 0; i <= this.n && i < 20; i++) {
                    const value = Math.pow(-1, i);
                    const y = 200 + value * 100;
                    this.ctx.beginPath();
                    this.ctx.arc(2 * sectionWidth + sectionWidth / 2, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                this.n++;
                if (this.n > 20) this.n = 0;
            }

            animate() {
                if (!this.isRunning) return;
                this.clear();
                this.draw();
                this.animationFrame = requestAnimationFrame(() => {
                    setTimeout(() => this.animate(), 300);
                });
            }
        }

        // 极限定义动画
        class LimitDefAnimation extends Animation {
            draw() {
                if (!this.ctx) return;

                this.ctx.fillStyle = '#3b82f6';
                this.ctx.font = '24px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('数列极限的几何意义', this.width / 2, this.height / 2 - 50);
                this.ctx.font = '18px Arial';
                this.ctx.fillStyle = '#6b7280';
                this.ctx.fillText('数列的项无限接近某个常数A', this.width / 2, this.height / 2);
                this.ctx.fillText('但可能永远不会等于A', this.width / 2, this.height / 2 + 30);
            }
        }

        // 靶心类比动画 - 完整实现
        class TargetAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.points = [];
                this.targetX = this.width / 2;
                this.targetY = this.height / 2;
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;

                // 绘制靶心
                const centerX = this.targetX;
                const centerY = this.targetY;

                // 绘制同心圆
                for (let i = 4; i > 0; i--) {
                    this.ctx.fillStyle = i % 2 === 0 ? '#ef4444' : '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, i * 30, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 绘制中心点
                this.ctx.fillStyle = '#fbbf24';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 添加新的射击点（随着时间越来越接近靶心）
                this.time += 0.02;
                if (this.time > 1) this.time = 0;

                const n = Math.floor(this.time * 20) + 1;
                const spread = 150 / n; // 随着n增大，散布减小

                // 绘制射击点
                this.ctx.fillStyle = 'rgba(59, 130, 246, 0.6)';
                for (let i = 1; i <= n; i++) {
                    const angle = (i * 137.5) * Math.PI / 180; // 黄金角
                    const radius = spread * Math.sqrt(i) / Math.sqrt(n);
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);

                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 绘制说明文字
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`射击次数 n = ${n}`, this.width / 2, 40);
                this.ctx.font = '16px Arial';
                this.ctx.fillStyle = '#6b7280';
                this.ctx.fillText('随着练习次数增加，落点越来越接近靶心', this.width / 2, this.height - 30);
            }
        }

        // 收敛与发散动画 - 完整实现
        class ConvergenceAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.n = 1;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const centerY = this.height / 2;
                const startX = 50;
                const endX = this.width - 50;
                const spacing = (endX - startX) / 20;

                // 绘制坐标轴
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(startX, centerY);
                this.ctx.lineTo(endX, centerY);
                this.ctx.stroke();

                // 绘制收敛数列：3 + 1/n
                this.ctx.fillStyle = '#10b981';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('收敛数列: xₙ = 3 + 1/n → 3', startX, 60);

                const limit1 = centerY - 80;
                this.ctx.strokeStyle = '#10b981';
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(startX, limit1);
                this.ctx.lineTo(endX, limit1);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.fillStyle = '#10b981';
                for (let i = 1; i <= Math.min(this.n, 20); i++) {
                    const x = startX + i * spacing;
                    const value = 3 + 1 / i;
                    const y = centerY - (value - 2) * 40;

                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 绘制发散数列：(-1)^n
                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.fillText('发散数列: xₙ = (-1)ⁿ', startX, centerY + 100);

                this.ctx.fillStyle = '#ef4444';
                for (let i = 1; i <= Math.min(this.n, 20); i++) {
                    const x = startX + i * spacing;
                    const value = Math.pow(-1, i);
                    const y = centerY + 120 + value * 30;

                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 更新n
                this.n += this.direction * 0.3;
                if (this.n >= 20) this.direction = -1;
                if (this.n <= 1) this.direction = 1;
            }
        }

        // 实例1：n/(n+1) → 1
        class Example1_1Animation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.n = 1;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const graphWidth = this.width - 2 * padding;
                const graphHeight = this.height - 2 * padding;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制极限线 y = 1
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding, padding);
                this.ctx.lineTo(this.width - padding, padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.fillText('极限 = 1', this.width - padding - 10, padding - 10);

                // 绘制数列点
                this.ctx.fillStyle = '#3b82f6';
                for (let i = 1; i <= Math.min(this.n, 30); i++) {
                    const x = padding + (i / 30) * graphWidth;
                    const value = i / (i + 1);
                    const y = this.height - padding - value * graphHeight;

                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 显示当前值
                if (this.n >= 1) {
                    const currentN = Math.floor(this.n);
                    const currentValue = currentN / (currentN + 1);
                    this.ctx.fillStyle = '#1f2937';
                    this.ctx.font = 'bold 18px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`n = ${currentN}, xₙ = ${currentValue.toFixed(4)}`, this.width / 2, this.height - 20);
                }

                // 更新n
                this.n += this.direction * 0.5;
                if (this.n >= 30) this.direction = -1;
                if (this.n <= 1) this.direction = 1;
            }
        }

        // 实例2：[1+(-1)^n]/2 摆动
        class Example1_2Animation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.n = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const graphWidth = this.width - 2 * padding;
                const graphHeight = this.height - 2 * padding;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height / 2,
                    showLabels: true
                });

                // 绘制两条参考线 y=0 和 y=1
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([3, 3]);

                const y0 = this.height / 2;
                const y1 = this.height / 2 - 100;

                this.ctx.beginPath();
                this.ctx.moveTo(padding, y0);
                this.ctx.lineTo(this.width - padding, y0);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(padding, y1);
                this.ctx.lineTo(this.width - padding, y1);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制数列点
                const maxN = Math.min(Math.floor(this.n), 20);
                for (let i = 1; i <= maxN; i++) {
                    const x = padding + (i / 20) * graphWidth;
                    const value = (1 + Math.pow(-1, i)) / 2;
                    const y = this.height / 2 - value * 100;

                    this.ctx.fillStyle = value === 0 ? '#3b82f6' : '#10b981';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 说明文字
                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('数列在 0 和 1 之间摆动，极限不存在', this.width / 2, this.height - 20);

                // 更新n
                this.n += 0.3;
                if (this.n >= 20) this.n = 1;
            }
        }

        // 实例3：1/(-3)^n → 0
        class Example1_3Animation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.n = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerY = this.height / 2;

                // 绘制坐标轴
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, centerY);
                this.ctx.lineTo(this.width - padding, centerY);
                this.ctx.stroke();

                // 绘制极限线 y = 0
                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.fillText('极限 = 0', this.width - padding - 10, centerY - 10);

                // 绘制数列点
                const maxN = Math.min(Math.floor(this.n), 15);
                for (let i = 1; i <= maxN; i++) {
                    const x = padding + (i / 15) * (this.width - 2 * padding);
                    const value = 1 / Math.pow(-3, i);
                    const y = centerY - value * 1000; // 放大显示

                    this.ctx.fillStyle = i % 2 === 0 ? '#3b82f6' : '#10b981';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 说明文字
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('正负交替，但绝对值趋向 0', this.width / 2, this.height - 20);

                // 更新n
                this.n += 0.2;
                if (this.n >= 15) this.n = 1;
            }
        }

        // 实例4：常数数列 8
        class Example1_4Animation extends Animation {
            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerY = this.height / 2;

                // 绘制坐标轴
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, centerY);
                this.ctx.lineTo(this.width - padding, centerY);
                this.ctx.stroke();

                // 绘制常数线 y = 8
                const y8 = centerY - 80;
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, y8);
                this.ctx.lineTo(this.width - padding, y8);
                this.ctx.stroke();

                // 绘制点
                this.ctx.fillStyle = '#3b82f6';
                for (let i = 1; i <= 20; i++) {
                    const x = padding + (i / 20) * (this.width - 2 * padding);
                    this.ctx.beginPath();
                    this.ctx.arc(x, y8, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 说明文字
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('xₙ = 8 (常数)', this.width / 2, 50);
                this.ctx.font = '18px Arial';
                this.ctx.fillStyle = '#6b7280';
                this.ctx.fillText('所有项都等于 8，极限也是 8', this.width / 2, this.height - 20);
            }
        }

        // 数列到函数的过渡动画
        class SequenceFunctionAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.phase = 0;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerY = this.height / 2;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: centerY,
                    showLabels: true
                });

                // 绘制离散点（数列）
                this.ctx.fillStyle = '#3b82f6';
                for (let i = 1; i <= 15; i++) {
                    const x = padding + (i / 15) * (this.width - 2 * padding);
                    const y = centerY - Math.sin(i * 0.5) * 80;

                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 5, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 绘制连续曲线（函数）- 透明度随phase变化
                this.ctx.globalAlpha = Math.abs(Math.sin(this.phase));
                this.ctx.strokeStyle = '#10b981';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = padding; x <= this.width - padding; x += 2) {
                    const t = ((x - padding) / (this.width - 2 * padding)) * 15;
                    const y = centerY - Math.sin(t * 0.5) * 80;

                    if (first) {
                        this.ctx.moveTo(x, y);
                        first = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                this.ctx.globalAlpha = 1.0;

                // 说明文字
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('蓝色点：数列（离散）', this.width / 2, 40);
                this.ctx.fillStyle = '#10b981';
                this.ctx.fillText('绿色线：函数（连续）', this.width / 2, 70);

                this.phase += 0.05;
            }
        }

        // 极限概念动画
        class LimitConceptAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const x0 = this.width / 2;
                const y0 = this.height / 2;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制函数曲线 y = x^2
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                for (let x = -3; x <= 3; x += 0.1) {
                    const canvasX = x0 + x * 60;
                    const canvasY = this.height - padding - (x * x) * 20;

                    if (x === -3) {
                        this.ctx.moveTo(canvasX, canvasY);
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 绘制动态点
                const currentX = this.x;
                const currentY = currentX * currentX;
                const canvasX = x0 + currentX * 60;
                const canvasY = this.height - padding - currentY * 20;

                this.ctx.fillStyle = '#ef4444';
                this.ctx.beginPath();
                this.ctx.arc(canvasX, canvasY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 说明文字
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`x = ${this.x.toFixed(2)}, f(x) = ${currentY.toFixed(2)}`, this.width / 2, 40);

                // 更新x
                this.x += this.direction * 0.05;
                if (this.x >= 2.5) this.direction = -1;
                if (this.x <= -2.5) this.direction = 1;
            }
        }

        // 定义域趋近方式动画
        class DomainApproachAnimation extends Animation {
            draw() {
                if (!this.ctx) return;

                const centerX = this.width / 2;
                const centerY = this.height / 2;

                // 绘制中心点
                this.ctx.fillStyle = '#3b82f6';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, 10, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('x₀', centerX, centerY - 20);

                // 绘制四个方向的箭头
                const arrows = [
                    { angle: 0, label: 'x → x₀⁺ (右)' },
                    { angle: Math.PI, label: 'x → x₀⁻ (左)' },
                    { angle: Math.PI / 4, label: 'x → +∞' },
                    { angle: -3 * Math.PI / 4, label: 'x → -∞' }
                ];

                arrows.forEach((arrow, i) => {
                    const startX = centerX + Math.cos(arrow.angle) * 80;
                    const startY = centerY + Math.sin(arrow.angle) * 80;
                    const endX = centerX + Math.cos(arrow.angle) * 20;
                    const endY = centerY + Math.sin(arrow.angle) * 20;

                    this.ctx.strokeStyle = '#10b981';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, startY);
                    this.ctx.lineTo(endX, endY);
                    this.ctx.stroke();

                    // 箭头
                    const headlen = 15;
                    const angle = Math.atan2(endY - startY, endX - startX);
                    this.ctx.beginPath();
                    this.ctx.moveTo(endX, endY);
                    this.ctx.lineTo(endX - headlen * Math.cos(angle - Math.PI / 6), endY - headlen * Math.sin(angle - Math.PI / 6));
                    this.ctx.moveTo(endX, endY);
                    this.ctx.lineTo(endX - headlen * Math.cos(angle + Math.PI / 6), endY - headlen * Math.sin(angle + Math.PI / 6));
                    this.ctx.stroke();

                    // 标签
                    const labelX = centerX + Math.cos(arrow.angle) * 120;
                    const labelY = centerY + Math.sin(arrow.angle) * 120;
                    this.ctx.fillStyle = '#6b7280';
                    this.ctx.font = '14px Arial';
                    this.ctx.fillText(arrow.label, labelX, labelY);
                });

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('函数极限的多种趋近方式', this.width / 2, 40);
            }
        }

        // x趋向无穷动画 - 完整实现
        class FunctionInfinityAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 1;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerX = this.width / 2;
                const centerY = this.height / 2;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: centerY,
                    showLabels: true
                });

                // 绘制极限线 y = 0
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding, centerY);
                this.ctx.lineTo(this.width - padding, centerY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.fillText('y = 0 (极限)', this.width - padding - 10, centerY - 10);

                // 绘制函数 y = 1/x
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = 0.5; x <= 10; x += 0.1) {
                    const y = 1 / x;
                    const canvasX = padding + (x / 10) * (this.width - 2 * padding);
                    const canvasY = centerY - y * 100;

                    if (canvasY > 0 && canvasY < this.height) {
                        if (first) {
                            this.ctx.moveTo(canvasX, canvasY);
                            first = false;
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                }
                this.ctx.stroke();

                // 绘制动态点
                const currentY = 1 / this.x;
                const currentCanvasX = padding + (this.x / 10) * (this.width - 2 * padding);
                const currentCanvasY = centerY - currentY * 100;

                this.ctx.fillStyle = '#10b981';
                this.ctx.beginPath();
                this.ctx.arc(currentCanvasX, currentCanvasY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 显示信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`x = ${this.x.toFixed(2)}, f(x) = 1/x = ${currentY.toFixed(4)}`, this.width / 2, 40);
                this.ctx.font = '16px Arial';
                this.ctx.fillStyle = '#6b7280';
                this.ctx.fillText('当 x → +∞ 时，1/x → 0', this.width / 2, 70);

                // 更新x
                this.x += this.direction * 0.1;
                if (this.x >= 10) this.direction = -1;
                if (this.x <= 1) this.direction = 1;
            }
        }

        // 1/x函数动画 - 完整实现（双向）
        class OneOverXAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = -10;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerX = this.width / 2;
                const centerY = this.height / 2;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: centerX,
                    originY: centerY,
                    showLabels: true
                });

                // 绘制渐近线
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([3, 3]);
                // x轴
                this.ctx.beginPath();
                this.ctx.moveTo(padding, centerY);
                this.ctx.lineTo(this.width - padding, centerY);
                this.ctx.stroke();
                // y轴
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, padding);
                this.ctx.lineTo(centerX, this.height - padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制 y = 1/x 曲线（正半轴）
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = 0.2; x <= 10; x += 0.1) {
                    const y = 1 / x;
                    const canvasX = centerX + x * 40;
                    const canvasY = centerY - y * 40;

                    if (canvasY > padding && canvasY < this.height - padding) {
                        if (first) {
                            this.ctx.moveTo(canvasX, canvasY);
                            first = false;
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                }
                this.ctx.stroke();

                // 绘制 y = 1/x 曲线（负半轴）
                this.ctx.beginPath();
                first = true;
                for (let x = -10; x <= -0.2; x += 0.1) {
                    const y = 1 / x;
                    const canvasX = centerX + x * 40;
                    const canvasY = centerY - y * 40;

                    if (canvasY > padding && canvasY < this.height - padding) {
                        if (first) {
                            this.ctx.moveTo(canvasX, canvasY);
                            first = false;
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                }
                this.ctx.stroke();

                // 绘制动态点
                if (Math.abs(this.x) > 0.2) {
                    const currentY = 1 / this.x;
                    const currentCanvasX = centerX + this.x * 40;
                    const currentCanvasY = centerY - currentY * 40;

                    if (currentCanvasY > padding && currentCanvasY < this.height - padding) {
                        this.ctx.fillStyle = '#ef4444';
                        this.ctx.beginPath();
                        this.ctx.arc(currentCanvasX, currentCanvasY, 8, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }

                // 显示信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                if (Math.abs(this.x) > 0.2) {
                    this.ctx.fillText(`x = ${this.x.toFixed(2)}, y = 1/x = ${(1 / this.x).toFixed(4)}`, this.width / 2, 40);
                }

                // 更新x
                this.x += this.direction * 0.15;
                if (this.x >= 10) this.direction = -1;
                if (this.x <= -10) this.direction = 1;
            }
        }

        // 点极限动画 - 完整实现
        class PointLimitAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0;
                this.direction = 1;
                this.x0 = 2;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerX = this.width / 2;
                const centerY = this.height / 2;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制函数 y = (x-2)^2 + 1
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = 0; x <= 4; x += 0.05) {
                    const y = Math.pow(x - this.x0, 2) + 1;
                    const canvasX = padding + x * 100;
                    const canvasY = this.height - padding - y * 40;

                    if (first) {
                        this.ctx.moveTo(canvasX, canvasY);
                        first = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 绘制x0处的垂直虚线
                const x0CanvasX = padding + this.x0 * 100;
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(x0CanvasX, this.height - padding);
                this.ctx.lineTo(x0CanvasX, padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制极限点（空心圆）
                const limitY = 1;
                const limitCanvasY = this.height - padding - limitY * 40;
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(x0CanvasX, limitCanvasY, 8, 0, Math.PI * 2);
                this.ctx.stroke();

                // 绘制动态点
                const currentY = Math.pow(this.x - this.x0, 2) + 1;
                const currentCanvasX = padding + this.x * 100;
                const currentCanvasY = this.height - padding - currentY * 40;

                this.ctx.fillStyle = '#10b981';
                this.ctx.beginPath();
                this.ctx.arc(currentCanvasX, currentCanvasY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                // 显示信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`x = ${this.x.toFixed(2)} → ${this.x0}, f(x) = ${currentY.toFixed(3)} → 1`, this.width / 2, 40);

                // 更新x（在x0附近摆动）
                this.x += this.direction * 0.02;
                if (this.x >= 3.5) this.direction = -1;
                if (this.x <= 0.5) this.direction = 1;
            }
        }

        // 左右极限动画 - 完整实现
        class LeftRightLimitsAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.xLeft = 0;
                this.xRight = 4;
                this.x0 = 2;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制分段函数
                // 左侧：y = x + 1 (x < 2)
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = 0; x < this.x0; x += 0.05) {
                    const y = x + 1;
                    const canvasX = padding + x * 100;
                    const canvasY = this.height - padding - y * 40;

                    if (first) {
                        this.ctx.moveTo(canvasX, canvasY);
                        first = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 右侧：y = 2x - 1 (x >= 2)
                this.ctx.strokeStyle = '#10b981';
                this.ctx.beginPath();
                first = true;
                for (let x = this.x0; x <= 4; x += 0.05) {
                    const y = 2 * x - 1;
                    const canvasX = padding + x * 100;
                    const canvasY = this.height - padding - y * 40;

                    if (first) {
                        this.ctx.moveTo(canvasX, canvasY);
                        first = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 绘制x0处的垂直虚线
                const x0CanvasX = padding + this.x0 * 100;
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(x0CanvasX, this.height - padding);
                this.ctx.lineTo(x0CanvasX, padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制左极限点
                const leftLimitY = this.x0 + 1;
                const leftLimitCanvasY = this.height - padding - leftLimitY * 40;
                this.ctx.fillStyle = '#3b82f6';
                this.ctx.beginPath();
                this.ctx.arc(x0CanvasX - 2, leftLimitCanvasY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                // 绘制右极限点
                const rightLimitY = 2 * this.x0 - 1;
                const rightLimitCanvasY = this.height - padding - rightLimitY * 40;
                this.ctx.fillStyle = '#10b981';
                this.ctx.beginPath();
                this.ctx.arc(x0CanvasX + 2, rightLimitCanvasY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                // 绘制动态点（从左侧接近）
                if (this.xLeft < this.x0) {
                    const yLeft = this.xLeft + 1;
                    const canvasXLeft = padding + this.xLeft * 100;
                    const canvasYLeft = this.height - padding - yLeft * 40;

                    this.ctx.fillStyle = 'rgba(59, 130, 246, 0.6)';
                    this.ctx.beginPath();
                    this.ctx.arc(canvasXLeft, canvasYLeft, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 绘制动态点（从右侧接近）
                if (this.xRight > this.x0) {
                    const yRight = 2 * this.xRight - 1;
                    const canvasXRight = padding + this.xRight * 100;
                    const canvasYRight = this.height - padding - yRight * 40;

                    this.ctx.fillStyle = 'rgba(16, 185, 129, 0.6)';
                    this.ctx.beginPath();
                    this.ctx.arc(canvasXRight, canvasYRight, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 显示信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`左极限: ${leftLimitY.toFixed(1)}`, this.width / 2 - 100, 40);
                this.ctx.fillText(`右极限: ${rightLimitY.toFixed(1)}`, this.width / 2 + 100, 40);

                // 更新位置
                this.xLeft += 0.02;
                this.xRight -= 0.02;
                if (this.xLeft >= this.x0 - 0.1) {
                    this.xLeft = 0;
                    this.xRight = 4;
                }
            }
        }

        // 瞬时速度动画 - 完整实现
        class VelocityAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.t = 0;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const g = 9.8;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制 s = 0.5 * g * t^2 曲线
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let t = 0; t <= 3; t += 0.05) {
                    const s = 0.5 * g * t * t;
                    const x = padding + t * 100;
                    const y = this.height - padding - s * 3;

                    if (first) {
                        this.ctx.moveTo(x, y);
                        first = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();

                // 绘制当前点
                const currentS = 0.5 * g * this.t * this.t;
                const currentX = padding + this.t * 100;
                const currentY = this.height - padding - currentS * 3;

                this.ctx.fillStyle = '#ef4444';
                this.ctx.beginPath();
                this.ctx.arc(currentX, currentY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 显示信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`t = ${this.t.toFixed(2)}s, s = ${currentS.toFixed(2)}m`, this.width / 2, 40);
                this.ctx.fillText(`v = gt = ${(g * this.t).toFixed(2)}m/s`, this.width / 2, 70);

                // 更新时间
                this.t += 0.02;
                if (this.t >= 3) this.t = 0;
            }
        }

        // 种群模型动画 - 完整实现
        class PopulationAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.t = 0;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const K = 100; // 环境容纳量

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制饱和线
                const saturationY = this.height - padding - K * 3;
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding, saturationY);
                this.ctx.lineTo(this.width - padding, saturationY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = '16px Arial';
                this.ctx.textAlign = 'right';
                this.ctx.fillText('饱和值 K = 100', this.width - padding - 10, saturationY - 10);

                // 绘制Logistic增长曲线
                this.ctx.strokeStyle = '#10b981';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let t = 0; t <= 10; t += 0.1) {
                    const P = K / (1 + 9 * Math.exp(-0.5 * t)); // P0 = 10
                    const x = padding + t * 60;
                    const y = this.height - padding - P * 3;

                    if (first) {
                        this.ctx.moveTo(x, y);
                        first = false;
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();

                // 绘制当前点
                const currentP = K / (1 + 9 * Math.exp(-0.5 * this.t));
                const currentX = padding + this.t * 60;
                const currentY = this.height - padding - currentP * 3;

                this.ctx.fillStyle = '#3b82f6';
                this.ctx.beginPath();
                this.ctx.arc(currentX, currentY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 显示信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`时间 t = ${this.t.toFixed(1)}, 种群数量 P = ${currentP.toFixed(1)}`, this.width / 2, 40);

                // 更新时间
                this.t += 0.05;
                if (this.t >= 10) this.t = 0;
            }
        }

        // 反正切函数动画 - 完整实现
        class ArctanAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = -5;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerX = this.width / 2;
                const centerY = this.height / 2;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: centerX,
                    originY: centerY,
                    showLabels: true
                });

                // 绘制渐近线
                const piOver2Y = centerY - (Math.PI / 2) * 80;
                const minusPiOver2Y = centerY + (Math.PI / 2) * 80;

                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(padding, piOver2Y);
                this.ctx.lineTo(this.width - padding, piOver2Y);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(padding, minusPiOver2Y);
                this.ctx.lineTo(this.width - padding, minusPiOver2Y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制arctan曲线
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = -5; x <= 5; x += 0.1) {
                    const y = Math.atan(x);
                    const canvasX = centerX + x * 60;
                    const canvasY = centerY - y * 80;

                    if (first) {
                        this.ctx.moveTo(canvasX, canvasY);
                        first = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 绘制动态点
                const currentY = Math.atan(this.x);
                const currentCanvasX = centerX + this.x * 60;
                const currentCanvasY = centerY - currentY * 80;

                this.ctx.fillStyle = '#10b981';
                this.ctx.beginPath();
                this.ctx.arc(currentCanvasX, currentCanvasY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 显示信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`x = ${this.x.toFixed(2)}, arctan(x) = ${currentY.toFixed(3)}`, this.width / 2, 40);

                // 更新x
                this.x += this.direction * 0.1;
                if (this.x >= 5) this.direction = -1;
                if (this.x <= -5) this.direction = 1;
            }
        }

        // 分段函数1动画 - 完整实现（左右极限相等）
        class Piecewise1Animation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const x0 = 1; // 分界点

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制分段函数
                // 左侧：y = 3x (x < 1)
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = 0; x < x0; x += 0.05) {
                    const y = 3 * x;
                    const canvasX = padding + x * 150;
                    const canvasY = this.height - padding - y * 50;

                    if (first) {
                        this.ctx.moveTo(canvasX, canvasY);
                        first = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 右侧：y = x + 2 (x >= 1)
                this.ctx.strokeStyle = '#10b981';
                this.ctx.beginPath();
                first = true;
                for (let x = x0; x <= 3; x += 0.05) {
                    const y = x + 2;
                    const canvasX = padding + x * 150;
                    const canvasY = this.height - padding - y * 50;

                    if (first) {
                        this.ctx.moveTo(canvasX, canvasY);
                        first = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 绘制x0处的垂直虚线
                const x0CanvasX = padding + x0 * 150;
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(x0CanvasX, this.height - padding);
                this.ctx.lineTo(x0CanvasX, padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制极限点（实心，因为左右极限相等）
                const limitY = 3; // 左右极限都是3
                const limitCanvasY = this.height - padding - limitY * 50;
                this.ctx.fillStyle = '#10b981';
                this.ctx.beginPath();
                this.ctx.arc(x0CanvasX, limitCanvasY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 绘制动态点
                let currentY;
                if (this.x < x0) {
                    currentY = 3 * this.x;
                    this.ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                } else {
                    currentY = this.x + 2;
                    this.ctx.fillStyle = 'rgba(16, 185, 129, 0.7)';
                }

                const currentCanvasX = padding + this.x * 150;
                const currentCanvasY = this.height - padding - currentY * 50;

                this.ctx.beginPath();
                this.ctx.arc(currentCanvasX, currentCanvasY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                // 显示信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('左右极限都等于 3，极限存在', this.width / 2, 40);
                this.ctx.font = '16px Arial';
                this.ctx.fillStyle = '#6b7280';
                this.ctx.fillText(`x = ${this.x.toFixed(2)}, f(x) = ${currentY.toFixed(2)}`, this.width / 2, 70);

                // 更新x
                this.x += this.direction * 0.02;
                if (this.x >= 2.5) this.direction = -1;
                if (this.x <= 0.2) this.direction = 1;
            }
        }

        // 分段函数2动画 - 完整实现（左右极限不等）
        class Piecewise2Animation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = -1;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerX = this.width / 2;
                const x0 = 0; // 分界点

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: centerX,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制分段函数
                // 左侧：y = x + 1 (x < 0)
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = -2; x < x0; x += 0.05) {
                    const y = x + 1;
                    const canvasX = centerX + x * 100;
                    const canvasY = this.height - padding - y * 80;

                    if (first) {
                        this.ctx.moveTo(canvasX, canvasY);
                        first = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 右侧：y = x^2 (x >= 0)
                this.ctx.strokeStyle = '#10b981';
                this.ctx.beginPath();
                first = true;
                for (let x = x0; x <= 2; x += 0.05) {
                    const y = x * x;
                    const canvasX = centerX + x * 100;
                    const canvasY = this.height - padding - y * 80;

                    if (first) {
                        this.ctx.moveTo(canvasX, canvasY);
                        first = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 绘制x0处的垂直虚线
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, this.height - padding);
                this.ctx.lineTo(centerX, padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制左极限点（空心，y=1）
                const leftLimitY = 1;
                const leftLimitCanvasY = this.height - padding - leftLimitY * 80;
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(centerX - 3, leftLimitCanvasY, 7, 0, Math.PI * 2);
                this.ctx.stroke();

                // 绘制右极限点（空心，y=0）
                const rightLimitY = 0;
                const rightLimitCanvasY = this.height - padding - rightLimitY * 80;
                this.ctx.strokeStyle = '#10b981';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(centerX + 3, rightLimitCanvasY, 7, 0, Math.PI * 2);
                this.ctx.stroke();

                // 绘制动态点
                let currentY;
                if (this.x < x0) {
                    currentY = this.x + 1;
                    this.ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                } else {
                    currentY = this.x * this.x;
                    this.ctx.fillStyle = 'rgba(16, 185, 129, 0.7)';
                }

                const currentCanvasX = centerX + this.x * 100;
                const currentCanvasY = this.height - padding - currentY * 80;

                this.ctx.beginPath();
                this.ctx.arc(currentCanvasX, currentCanvasY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                // 显示信息
                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('左极限 = 1 ≠ 0 = 右极限，极限不存在', this.width / 2, 40);
                this.ctx.font = '16px Arial';
                this.ctx.fillStyle = '#6b7280';
                this.ctx.fillText(`x = ${this.x.toFixed(2)}, f(x) = ${currentY.toFixed(2)}`, this.width / 2, 70);

                // 更新x
                this.x += this.direction * 0.03;
                if (this.x >= 1.5) this.direction = -1;
                if (this.x <= -1.5) this.direction = 1;
            }
        }

        // 无穷小定义动画 - 完整实现
        class InfinitesimalDefinitionAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerX = this.width / 2;
                const centerY = this.height / 2;

                // 左侧：无穷小示例 y = (x-1)
                const leftCenterX = this.width / 4;

                // 绘制坐标系（左）
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, centerY);
                this.ctx.lineTo(leftCenterX + 100, centerY);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(leftCenterX, centerY - 100);
                this.ctx.lineTo(leftCenterX, centerY + 100);
                this.ctx.stroke();

                // 绘制无穷小函数 y = x - 1
                this.ctx.strokeStyle = '#10b981';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = 0; x <= 2; x += 0.05) {
                    const y = x - 1;
                    const canvasX = leftCenterX + (x - 1) * 80;
                    const canvasY = centerY - y * 80;

                    if (first) {
                        this.ctx.moveTo(canvasX, canvasY);
                        first = false;
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 标题
                this.ctx.fillStyle = '#10b981';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('无穷小', leftCenterX, 40);
                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = '#6b7280';
                this.ctx.fillText('x→1时，(x-1)→0', leftCenterX, 65);

                // 右侧：无穷大示例 y = 1/(x-2)^2
                const rightCenterX = this.width * 3 / 4;

                // 绘制坐标系（右）
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(rightCenterX - 100, centerY);
                this.ctx.lineTo(this.width - padding, centerY);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(rightCenterX, centerY - 150);
                this.ctx.lineTo(rightCenterX, centerY + 100);
                this.ctx.stroke();

                // 绘制无穷大函数 y = 1/(x-2)^2
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;

                // 左半支
                this.ctx.beginPath();
                first = true;
                for (let x = 1; x < 1.95; x += 0.02) {
                    const y = 1 / Math.pow(x - 2, 2);
                    if (y < 10) {
                        const canvasX = rightCenterX + (x - 2) * 80;
                        const canvasY = centerY - y * 10;

                        if (canvasY > padding) {
                            if (first) {
                                this.ctx.moveTo(canvasX, canvasY);
                                first = false;
                            } else {
                                this.ctx.lineTo(canvasX, canvasY);
                            }
                        }
                    }
                }
                this.ctx.stroke();

                // 右半支
                this.ctx.beginPath();
                first = true;
                for (let x = 2.05; x <= 3; x += 0.02) {
                    const y = 1 / Math.pow(x - 2, 2);
                    if (y < 10) {
                        const canvasX = rightCenterX + (x - 2) * 80;
                        const canvasY = centerY - y * 10;

                        if (canvasY > padding) {
                            if (first) {
                                this.ctx.moveTo(canvasX, canvasY);
                                first = false;
                            } else {
                                this.ctx.lineTo(canvasX, canvasY);
                            }
                        }
                    }
                }
                this.ctx.stroke();

                // 标题
                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('无穷大', rightCenterX, 40);
                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = '#6b7280';
                this.ctx.fillText('x→2时，1/(x-2)²→∞', rightCenterX, 65);

                // 底部说明
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('无穷大与非零无穷小互为倒数', this.width / 2, this.height - 30);
            }
        }

        // 无穷小过程1动画 - 完整实现
        class InfinitesimalProcess1Animation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0.5;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;
                const centerX = this.width / 2;
                const x0 = 2;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制函数 y = (x-2)^2
                this.ctx.strokeStyle = '#10b981';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = 0; x <= 4; x += 0.05) {
                    const y = Math.pow(x - x0, 2);
                    const canvasX = padding + x * 100;
                    const canvasY = this.height - padding - y * 50;

                    if (canvasY > padding) {
                        if (first) {
                            this.ctx.moveTo(canvasX, canvasY);
                            first = false;
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                }
                this.ctx.stroke();

                // 绘制x0处的垂直虚线
                const x0CanvasX = padding + x0 * 100;
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(x0CanvasX, this.height - padding);
                this.ctx.lineTo(x0CanvasX, padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制动态点
                const currentY = Math.pow(this.x - x0, 2);
                const currentCanvasX = padding + this.x * 100;
                const currentCanvasY = this.height - padding - currentY * 50;

                this.ctx.fillStyle = '#ef4444';
                this.ctx.beginPath();
                this.ctx.arc(currentCanvasX, currentCanvasY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 显示信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`x = ${this.x.toFixed(2)} → 2, y = (x-2)² = ${currentY.toFixed(4)} → 0`, this.width / 2, 40);
                this.ctx.font = '16px Arial';
                this.ctx.fillStyle = '#10b981';
                this.ctx.fillText('当 x → 2 时，y 是无穷小', this.width / 2, 70);

                // 更新x（向2靠近）
                this.x += this.direction * 0.03;
                if (this.x >= 3.5) this.direction = -1;
                if (this.x <= 0.5) this.direction = 1;
            }
        }

        // 无穷小上下文依赖动画 - 完整实现
        class InfinitesimalContextAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.process = 0; // 0: x→2, 1: x→3, 2: x→∞
                this.x = 0.5;
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;

                const padding = 60;

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: padding,
                    originY: this.height - padding,
                    showLabels: true
                });

                // 绘制函数 y = (x-2)^2
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                let first = true;
                for (let x = 0; x <= 5; x += 0.05) {
                    const y = Math.pow(x - 2, 2);
                    const canvasX = padding + x * 80;
                    const canvasY = this.height - padding - y * 20;

                    if (canvasY > padding && canvasY < this.height - padding) {
                        if (first) {
                            this.ctx.moveTo(canvasX, canvasY);
                            first = false;
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                }
                this.ctx.stroke();

                // 根据当前过程绘制参考线和点
                let targetX, targetY, label, color;

                if (this.process === 0) {
                    // x → 2
                    targetX = 2;
                    targetY = 0;
                    label = 'x → 2: y → 0 (无穷小)';
                    color = '#10b981';
                } else if (this.process === 1) {
                    // x → 3
                    targetX = 3;
                    targetY = 1;
                    label = 'x → 3: y → 1 (不是无穷小)';
                    color = '#f59e0b';
                } else {
                    // x → ∞
                    targetX = 5;
                    targetY = 9;
                    label = 'x → ∞: y → ∞ (无穷大)';
                    color = '#ef4444';
                }

                // 绘制目标点
                const targetCanvasX = padding + targetX * 80;
                const targetCanvasY = this.height - padding - targetY * 20;

                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(targetCanvasX, this.height - padding);
                this.ctx.lineTo(targetCanvasX, padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(targetCanvasX, targetCanvasY, 10, 0, Math.PI * 2);
                this.ctx.fill();

                // 绘制动态点
                const currentY = Math.pow(this.x - 2, 2);
                const currentCanvasX = padding + this.x * 80;
                const currentCanvasY = this.height - padding - currentY * 20;

                if (currentCanvasY > padding && currentCanvasY < this.height - padding) {
                    this.ctx.fillStyle = 'rgba(59, 130, 246, 0.7)';
                    this.ctx.beginPath();
                    this.ctx.arc(currentCanvasX, currentCanvasY, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 显示信息
                this.ctx.fillStyle = color;
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(label, this.width / 2, 40);

                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = '16px Arial';
                this.ctx.fillText(`x = ${this.x.toFixed(2)}, y = ${currentY.toFixed(2)}`, this.width / 2, 70);

                // 更新x（向目标靠近）
                this.x += (targetX - this.x) * 0.02;

                // 切换过程
                this.time += 0.01;
                if (this.time >= 3) {
                    this.time = 0;
                    this.process = (this.process + 1) % 3;
                    this.x = 0.5;
                }
            }
        }

        // 第38页：无穷大乘积法则动画
        // 用户需求：完全重写，简洁代码，无重叠，清晰可视化
        class InfiniteLawAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 1.5;
                this.direction = 1;
                this.xMin = 0.5;
                this.xMax = 3.5;
                this.yMin = 0;
                this.yMax = 40;
                this.padding = 55;
            }

            draw() {
                if (!this.ctx) return;
                const width = this.width;
                const height = this.height;
                const canvasWidth = width - 2 * this.padding;
                const canvasHeight = height - 2 * this.padding;

                // 坐标转换
                const toX = (x) => ((x - this.xMin) / (this.xMax - this.xMin)) * canvasWidth + this.padding;
                const toY = (y) => {
                    const clamped = Math.min(Math.max(y, this.yMin), this.yMax);
                    return height - this.padding - ((clamped - this.yMin) / (this.yMax - this.yMin)) * canvasHeight;
                };

                const originX = toX(0);
                const originY = toY(0);

                // 绘制坐标系
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制三条曲线
                const curves = [
                    { fn: (x) => x * x, color: '#3b82f6', label: 'y = x²' },
                    { fn: (x) => x * x * x, color: '#10b981', label: 'y = x³' },
                    { fn: (x) => x * x * x * x * x, color: '#ef4444', label: 'y = x⁵' }
                ];

                curves.forEach(curve => {
                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    let first = true;

                    for (let x = this.xMin; x <= this.xMax; x += 0.01) {
                        const y = curve.fn(x);
                        if (y > this.yMax) continue;

                        const canvasX = toX(x);
                        const canvasY = toY(y);

                        if (first) {
                            this.ctx.moveTo(canvasX, canvasY);
                            first = false;
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                    this.ctx.stroke();
                });

                // 绘制动画点
                const y2 = this.x * this.x;
                const y3 = this.x * this.x * this.x;
                const y5 = this.x * this.x * this.x * this.x * this.x;

                // 垂直参考线
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(toX(this.x), originY);
                this.ctx.lineTo(toX(this.x), this.padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制三个点
                const points = [
                    { y: y2, color: '#3b82f6' },
                    { y: y3, color: '#10b981' },
                    { y: y5, color: '#ef4444' }
                ];

                points.forEach(point => {
                    if (point.y <= this.yMax) {
                        this.ctx.fillStyle = point.color;
                        this.ctx.beginPath();
                        this.ctx.arc(toX(this.x), toY(point.y), 6, 0, Math.PI * 2);
                        this.ctx.fill();

                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.arc(toX(this.x), toY(point.y), 6, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                });

                // 右上角信息框
                const infoX = width - this.padding - 150;
                const infoY = this.padding + 30;

                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`x = ${this.x.toFixed(2)}`, infoX, infoY);

                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = '#3b82f6';
                this.ctx.fillText(`x² = ${y2.toFixed(1)}`, infoX, infoY + 25);
                this.ctx.fillStyle = '#10b981';
                this.ctx.fillText(`x³ = ${y3.toFixed(1)}`, infoX, infoY + 50);
                this.ctx.fillStyle = '#ef4444';
                this.ctx.fillText(`x⁵ = ${y5.toFixed(1)}`, infoX, infoY + 75);

                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '13px Arial';
                this.ctx.fillText(`x² × x³ = x⁵`, infoX, infoY + 105);

                // 左下角图例
                const legendX = this.padding + 15;
                const legendY = originY - 120;

                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 15px Arial';
                this.ctx.fillText('函数对比', legendX, legendY);

                curves.forEach((curve, i) => {
                    const y = legendY + 18 + i * 28;

                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(legendX, y);
                    this.ctx.lineTo(legendX + 25, y);
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#374151';
                    this.ctx.font = '14px Arial';
                    this.ctx.fillText(curve.label, legendX + 32, y + 4);
                });

                // 底部说明
                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '13px Arial';
                this.ctx.fillText('当 x → ∞ 时，x² 和 x³ 都趋向无穷大，它们的乘积 x⁵ 增长更快', this.padding, this.padding - 3);

                // 更新动画位置
                this.x += this.direction * 0.015;
                if (this.x >= 3.2) this.direction = -1;
                if (this.x <= 1.2) this.direction = 1;
            }
        }

        // ========================================
        // 第二节、第三节、第四节、第五节动画类
        // ========================================

        // 第二节：极限运算法则动画
        class LimitRulesAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 50;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('极限的四则运算法则', width / 2, 35);

                // 四个运算法则卡片
                const rules = [
                    { op: '+', color: '#3b82f6', label: '加法' },
                    { op: '-', color: '#10b981', label: '减法' },
                    { op: '×', color: '#f59e0b', label: '乘法' },
                    { op: '÷', color: '#ef4444', label: '除法' }
                ];

                const cardWidth = 150;
                const cardHeight = 100;
                const gap = 20;
                const startX = (width - (cardWidth * 4 + gap * 3)) / 2;
                const y = height / 2 - cardHeight / 2;

                rules.forEach((rule, i) => {
                    const x = startX + i * (cardWidth + gap);

                    // 卡片背景（带动画效果）
                    const scale = 1 + 0.05 * Math.sin(this.time + i * Math.PI / 2);
                    const offsetY = 5 * Math.sin(this.time + i * Math.PI / 2);

                    this.ctx.fillStyle = rule.color + '20';
                    this.ctx.fillRect(x, y + offsetY, cardWidth, cardHeight * scale);

                    // 边框
                    this.ctx.strokeStyle = rule.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(x, y + offsetY, cardWidth, cardHeight * scale);

                    // 运算符
                    this.ctx.fillStyle = rule.color;
                    this.ctx.font = 'bold 36px Arial';
                    this.ctx.fillText(rule.op, x + cardWidth / 2, y + offsetY + cardHeight / 2);

                    // 标签
                    this.ctx.font = '14px Arial';
                    this.ctx.fillStyle = '#6b7280';
                    this.ctx.fillText(rule.label, x + cardWidth / 2, y + offsetY + cardHeight + 25);
                });

                // 底部说明
                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '15px Arial';
                this.ctx.fillText('lim[f(x) ± g(x)] = lim f(x) ± lim g(x)', width / 2, height - 30);

                this.time += 0.03;
            }
        }

        // 第三节：直接代入法动画
        class DirectSubstitutionAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = -2;
                this.targetX = 1;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 绘制坐标系
                const originX = padding;
                const originY = height - padding;
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制函数 f(x) = x^2 + 1
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                for (let x = -2; x <= 3; x += 0.01) {
                    const y = x * x + 1;
                    const canvasX = originX + (x + 2) * (width - 2 * padding) / 5;
                    const canvasY = originY - y * (height - 2 * padding) / 12;

                    if (x === -2) {
                        this.ctx.moveTo(canvasX, canvasY);
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 绘制动态点
                const y = this.x * this.x + 1;
                const canvasX = originX + (this.x + 2) * (width - 2 * padding) / 5;
                const canvasY = originY - y * (height - 2 * padding) / 12;

                // 垂直参考线
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(canvasX, originY);
                this.ctx.lineTo(canvasX, canvasY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 动态点
                this.ctx.fillStyle = '#10b981';
                this.ctx.beginPath();
                this.ctx.arc(canvasX, canvasY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(canvasX, canvasY, 8, 0, Math.PI * 2);
                this.ctx.stroke();

                // 目标点标记
                const targetY = this.targetX * this.targetX + 1;
                const targetCanvasX = originX + (this.targetX + 2) * (width - 2 * padding) / 5;
                const targetCanvasY = originY - targetY * (height - 2 * padding) / 12;

                this.ctx.fillStyle = '#ef4444';
                this.ctx.beginPath();
                this.ctx.arc(targetCanvasX, targetCanvasY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`f(x) = x² + 1`, padding + 10, 30);
                this.ctx.fillText(`x = ${this.x.toFixed(2)}`, padding + 10, 55);
                this.ctx.fillText(`f(x) = ${y.toFixed(2)}`, padding + 10, 80);

                this.ctx.fillStyle = '#ef4444';
                this.ctx.fillText(`目标: x → ${this.targetX}`, padding + 10, 110);
                this.ctx.fillText(`极限 = f(${this.targetX}) = ${targetY}`, padding + 10, 135);

                // 更新位置
                this.x += this.direction * 0.02;
                if (this.x >= 2.5) this.direction = -1;
                if (this.x <= -1.5) this.direction = 1;
            }
        }

        // 零因子消去法动画
        class ZeroFactorAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = -2;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 绘制坐标系
                const originX = padding;
                const originY = height - padding;
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制函数 f(x) = (x^2-1)/(x-1) = x+1 (x≠1)
                this.ctx.strokeStyle = '#f59e0b';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                for (let x = -2; x <= 3; x += 0.01) {
                    if (Math.abs(x - 1) < 0.05) continue; // 跳过x=1附近

                    const y = x + 1; // 化简后的函数
                    const canvasX = originX + (x + 2) * (width - 2 * padding) / 5;
                    const canvasY = originY - y * (height - 2 * padding) / 8;

                    if (x === -2) {
                        this.ctx.moveTo(canvasX, canvasY);
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 在x=1处标记空心圆（间断点）
                const holeX = originX + (1 + 2) * (width - 2 * padding) / 5;
                const holeY = originY - 2 * (height - 2 * padding) / 8;

                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(holeX, holeY, 8, 0, Math.PI * 2);
                this.ctx.stroke();

                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.arc(holeX, holeY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                // 绘制动态点
                if (Math.abs(this.x - 1) > 0.1) {
                    const y = this.x + 1;
                    const canvasX = originX + (this.x + 2) * (width - 2 * padding) / 5;
                    const canvasY = originY - y * (height - 2 * padding) / 8;

                    this.ctx.fillStyle = '#10b981';
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`f(x) = (x²-1)/(x-1)`, padding + 10, 30);
                this.ctx.fillText(`化简: f(x) = x+1 (x≠1)`, padding + 10, 55);
                this.ctx.fillText(`x = ${this.x.toFixed(2)}`, padding + 10, 85);

                this.ctx.fillStyle = '#ef4444';
                this.ctx.fillText(`lim (x→1) f(x) = 2`, padding + 10, 115);

                // 更新位置
                this.x += this.direction * 0.02;
                if (this.x >= 2.5) this.direction = -1;
                if (this.x <= 0) this.direction = 1;
            }
        }

        // 有理化法动画
        class RationalizationAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0.1;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 绘制坐标系
                const originX = width / 2;
                const originY = height - padding;
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制函数 f(x) = (√(1+x) - 1) / x
                this.ctx.strokeStyle = '#8b5cf6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                for (let x = -0.5; x <= 2; x += 0.01) {
                    if (Math.abs(x) < 0.02) continue; // 跳过x=0附近

                    const y = (Math.sqrt(1 + x) - 1) / x;
                    const canvasX = originX + x * (width - 2 * padding) / 2.5;
                    const canvasY = originY - y * (height - 2 * padding) / 1.5;

                    if (x === -0.5) {
                        this.ctx.moveTo(canvasX, canvasY);
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 在x=0处标记极限值
                const limitY = 0.5; // 极限值
                const limitX = originX;
                const limitCanvasY = originY - limitY * (height - 2 * padding) / 1.5;

                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(limitX, limitCanvasY, 8, 0, Math.PI * 2);
                this.ctx.stroke();

                // 绘制动态点
                if (Math.abs(this.x) > 0.05) {
                    const y = (Math.sqrt(1 + this.x) - 1) / this.x;
                    const canvasX = originX + this.x * (width - 2 * padding) / 2.5;
                    const canvasY = originY - y * (height - 2 * padding) / 1.5;

                    this.ctx.fillStyle = '#10b981';
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 15px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`f(x) = (√(1+x) - 1) / x`, padding + 10, 30);
                this.ctx.fillText(`有理化后: 1/(√(1+x) + 1)`, padding + 10, 55);
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, 85);

                this.ctx.fillStyle = '#ef4444';
                this.ctx.fillText(`lim (x→0) f(x) = 1/2`, padding + 10, 115);

                // 更新位置
                this.x += this.direction * 0.008;
                if (this.x >= 1.5) this.direction = -1;
                if (this.x <= -0.4) this.direction = 1;
            }
        }

        // 抓大头法则动画
        class LeadingTermAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 1;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 绘制坐标系
                const originX = padding;
                const originY = height - padding;
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制三个函数
                const functions = [
                    { fn: (x) => (3 * x * x) / (2 * x * x), color: '#3b82f6', label: '3x²/2x²' },
                    { fn: (x) => (3 * x * x + 2 * x) / (2 * x * x), color: '#10b981', label: '(3x²+2x)/2x²' },
                    { fn: (x) => (3 * x * x + 2 * x + 1) / (2 * x * x - x + 5), color: '#ef4444', label: '完整式' }
                ];

                functions.forEach(func => {
                    this.ctx.strokeStyle = func.color;
                    this.ctx.lineWidth = 2.5;
                    this.ctx.beginPath();

                    for (let x = 1; x <= 20; x += 0.1) {
                        const y = func.fn(x);
                        const canvasX = originX + (x - 1) * (width - 2 * padding) / 19;
                        const canvasY = originY - y * (height - 2 * padding) / 3;

                        if (x === 1) {
                            this.ctx.moveTo(canvasX, canvasY);
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                    this.ctx.stroke();
                });

                // 绘制动态点
                functions.forEach((func, i) => {
                    const y = func.fn(this.x);
                    const canvasX = originX + (this.x - 1) * (width - 2 * padding) / 19;
                    const canvasY = originY - y * (height - 2 * padding) / 3;

                    this.ctx.fillStyle = func.color;
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // 极限线 y = 3/2
                const limitY = 1.5;
                const limitCanvasY = originY - limitY * (height - 2 * padding) / 3;

                this.ctx.strokeStyle = '#f59e0b';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([8, 4]);
                this.ctx.beginPath();
                this.ctx.moveTo(originX, limitCanvasY);
                this.ctx.lineTo(width - padding, limitCanvasY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`x = ${this.x.toFixed(1)}`, padding + 10, 30);

                this.ctx.font = '13px Arial';
                functions.forEach((func, i) => {
                    this.ctx.fillStyle = func.color;
                    this.ctx.fillText(`${func.label} = ${func.fn(this.x).toFixed(3)}`, padding + 10, 55 + i * 25);
                });

                this.ctx.fillStyle = '#f59e0b';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.fillText(`极限 = 3/2 = 1.5`, padding + 10, 145);

                // 更新位置
                this.x += this.direction * 0.15;
                if (this.x >= 18) this.direction = -1;
                if (this.x <= 2) this.direction = 1;
            }
        }

        // 第四节：两个重要极限动画
        class TwoLimitsAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x1 = 0.1; // 第一个极限的x
                this.x2 = 2;   // 第二个极限的x
                this.direction1 = 1;
                this.direction2 = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 50;
                const width = this.width;
                const height = this.height;
                const leftWidth = width / 2;

                // 中间分隔线
                this.ctx.strokeStyle = '#e5e7eb';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(leftWidth, padding);
                this.ctx.lineTo(leftWidth, height - padding);
                this.ctx.stroke();

                // ========== 左侧：sin(x)/x → 1 ==========
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('第一个重要极限', leftWidth / 2, 30);

                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = '#3b82f6';
                this.ctx.fillText('lim (x→0) sin(x)/x = 1', leftWidth / 2, 55);

                // 左侧坐标系
                const leftOriginX = padding + 30;
                const leftOriginY = height / 2 + 50;
                const leftScale = 80;

                // 绘制左侧坐标轴
                this.ctx.strokeStyle = '#9ca3af';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                this.ctx.moveTo(leftOriginX, leftOriginY - leftScale * 1.5);
                this.ctx.lineTo(leftOriginX, leftOriginY + leftScale * 0.5);
                this.ctx.moveTo(leftOriginX - leftScale, leftOriginY);
                this.ctx.lineTo(leftOriginX + leftScale * 2, leftOriginY);
                this.ctx.stroke();

                // 绘制 sin(x)/x 曲线
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                for (let x = -1; x <= 2; x += 0.01) {
                    if (Math.abs(x) < 0.01) continue;
                    const y = Math.sin(x) / x;
                    const canvasX = leftOriginX + x * leftScale;
                    const canvasY = leftOriginY - y * leftScale;

                    if (x === -1) {
                        this.ctx.moveTo(canvasX, canvasY);
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 极限线 y=1
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(leftOriginX - leftScale, leftOriginY - leftScale);
                this.ctx.lineTo(leftOriginX + leftScale * 2, leftOriginY - leftScale);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 动态点
                if (Math.abs(this.x1) > 0.05) {
                    const y1 = Math.sin(this.x1) / this.x1;
                    const canvasX1 = leftOriginX + this.x1 * leftScale;
                    const canvasY1 = leftOriginY - y1 * leftScale;

                    this.ctx.fillStyle = '#10b981';
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX1, canvasY1, 7, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 左侧信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = '13px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`x = ${this.x1.toFixed(3)}`, padding + 10, height - 60);
                this.ctx.fillText(`sin(x)/x = ${(Math.sin(this.x1) / this.x1).toFixed(4)}`, padding + 10, height - 40);

                // ========== 右侧：(1+1/x)^x → e ==========
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('第二个重要极限', leftWidth + leftWidth / 2, 30);

                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = '#10b981';
                this.ctx.fillText('lim (x→∞) (1+1/x)ˣ = e', leftWidth + leftWidth / 2, 55);

                // 右侧坐标系
                const rightOriginX = leftWidth + padding + 30;
                const rightOriginY = height / 2 + 50;
                const rightScaleX = 15;
                const rightScaleY = 80;

                // 绘制右侧坐标轴
                this.ctx.strokeStyle = '#9ca3af';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                this.ctx.moveTo(rightOriginX, rightOriginY - rightScaleY * 1.5);
                this.ctx.lineTo(rightOriginX, rightOriginY + rightScaleY * 0.5);
                this.ctx.moveTo(rightOriginX, rightOriginY);
                this.ctx.lineTo(rightOriginX + rightScaleX * 15, rightOriginY);
                this.ctx.stroke();

                // 绘制 (1+1/x)^x 曲线
                this.ctx.strokeStyle = '#10b981';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                for (let x = 1; x <= 20; x += 0.1) {
                    const y = Math.pow(1 + 1 / x, x);
                    const canvasX = rightOriginX + (x - 1) * rightScaleX;
                    const canvasY = rightOriginY - (y - 1) * rightScaleY;

                    if (x === 1) {
                        this.ctx.moveTo(canvasX, canvasY);
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 极限线 y=e
                const e = Math.E;
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(rightOriginX, rightOriginY - (e - 1) * rightScaleY);
                this.ctx.lineTo(rightOriginX + rightScaleX * 15, rightOriginY - (e - 1) * rightScaleY);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 动态点
                const y2 = Math.pow(1 + 1 / this.x2, this.x2);
                const canvasX2 = rightOriginX + (this.x2 - 1) * rightScaleX;
                const canvasY2 = rightOriginY - (y2 - 1) * rightScaleY;

                this.ctx.fillStyle = '#3b82f6';
                this.ctx.beginPath();
                this.ctx.arc(canvasX2, canvasY2, 7, 0, Math.PI * 2);
                this.ctx.fill();

                // 右侧信息
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = '13px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`x = ${this.x2.toFixed(1)}`, leftWidth + padding + 10, height - 60);
                this.ctx.fillText(`(1+1/x)^x = ${y2.toFixed(4)}`, leftWidth + padding + 10, height - 40);
                this.ctx.fillText(`e ≈ 2.7183`, leftWidth + padding + 10, height - 20);

                // 更新动画
                this.x1 += this.direction1 * 0.005;
                if (this.x1 >= 1.5) this.direction1 = -1;
                if (this.x1 <= 0.1) this.direction1 = 1;

                this.x2 += this.direction2 * 0.1;
                if (this.x2 >= 18) this.direction2 = -1;
                if (this.x2 <= 2) this.direction2 = 1;
            }
        }

        // 无穷小比较动画
        class InfinitesimalCompareAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0.5;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 50;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('无穷小的比较（x → 0）', width / 2, 35);

                // 绘制坐标系
                const originX = padding;
                const originY = height - padding;
                const scaleX = (width - 2 * padding) / 1;
                const scaleY = (height - 2 * padding - 50) / 1;

                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制四条曲线
                const curves = [
                    { fn: (x) => x * x, color: '#3498db', label: 'x² (高阶)' },
                    { fn: (x) => x, color: '#2ecc71', label: 'x (基准)' },
                    { fn: (x) => 2 * x, color: '#9b59b6', label: '2x (同阶)' },
                    { fn: (x) => Math.sqrt(x), color: '#e74c3c', label: '√x (低阶)' }
                ];

                curves.forEach(curve => {
                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();

                    for (let x = 0.01; x <= 1; x += 0.01) {
                        const y = curve.fn(x);
                        const canvasX = originX + x * scaleX;
                        const canvasY = originY - y * scaleY;

                        if (x === 0.01) {
                            this.ctx.moveTo(canvasX, canvasY);
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                    this.ctx.stroke();
                });

                // 绘制动态垂直线
                const lineX = originX + this.x * scaleX;
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(lineX, originY);
                this.ctx.lineTo(lineX, padding + 50);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 绘制动态点
                curves.forEach(curve => {
                    const y = curve.fn(this.x);
                    const canvasX = originX + this.x * scaleX;
                    const canvasY = originY - y * scaleY;

                    this.ctx.fillStyle = curve.color;
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // 图例
                const legendX = width - 150;
                const legendY = padding + 60;

                curves.forEach((curve, i) => {
                    const y = legendY + i * 30;

                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(legendX, y);
                    this.ctx.lineTo(legendX + 30, y);
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#1f2937';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(curve.label, legendX + 40, y + 5);
                });

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, padding + 60);

                this.ctx.font = '13px Arial';
                curves.forEach((curve, i) => {
                    this.ctx.fillStyle = curve.color;
                    this.ctx.fillText(`${curve.label.split(' ')[0]} = ${curve.fn(this.x).toFixed(4)}`, padding + 10, padding + 85 + i * 22);
                });

                // 更新动画
                this.x += this.direction * 0.003;
                if (this.x >= 0.9) this.direction = -1;
                if (this.x <= 0.1) this.direction = 1;
            }
        }

        // 高阶无穷小动画
        class HigherOrderAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0.5;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('高阶无穷小：x² 比 x 小得更快', width / 2, 35);

                // 绘制坐标系
                const originX = padding;
                const originY = height - padding;
                const scaleX = (width - 2 * padding) / 1;
                const scaleY = (height - 2 * padding - 50) / 1;

                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制 x 和 x²
                const curves = [
                    { fn: (x) => x, color: '#2ecc71', label: 'α(x) = x' },
                    { fn: (x) => x * x, color: '#3498db', label: 'β(x) = x²' }
                ];

                curves.forEach(curve => {
                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();

                    for (let x = 0; x <= 1; x += 0.01) {
                        const y = curve.fn(x);
                        const canvasX = originX + x * scaleX;
                        const canvasY = originY - y * scaleY;

                        if (x === 0) {
                            this.ctx.moveTo(canvasX, canvasY);
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                    this.ctx.stroke();
                });

                // 动态垂直线
                const lineX = originX + this.x * scaleX;
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(lineX, originY);
                this.ctx.lineTo(lineX, padding + 50);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 动态点
                curves.forEach(curve => {
                    const y = curve.fn(this.x);
                    const canvasX = originX + this.x * scaleX;
                    const canvasY = originY - y * scaleY;

                    this.ctx.fillStyle = curve.color;
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 7, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 15px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, padding + 60);
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, padding + 85);
                this.ctx.fillText(`x² = ${(this.x * this.x).toFixed(4)}`, padding + 10, padding + 110);

                const ratio = (this.x * this.x) / this.x;
                this.ctx.fillStyle = '#3498db';
                this.ctx.fillText(`β/α = x²/x = ${ratio.toFixed(3)} → 0`, padding + 10, padding + 140);

                // 图例
                const legendX = width - 180;
                const legendY = padding + 60;

                curves.forEach((curve, i) => {
                    const y = legendY + i * 30;

                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(legendX, y);
                    this.ctx.lineTo(legendX + 30, y);
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#1f2937';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(curve.label, legendX + 40, y + 5);
                });

                // 更新动画
                this.x += this.direction * 0.003;
                if (this.x >= 0.9) this.direction = -1;
                if (this.x <= 0.1) this.direction = 1;
            }
        }

        // 低阶无穷小动画
        class LowerOrderAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0.5;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('低阶无穷小：x 比 x² 小得更慢', width / 2, 35);

                // 绘制坐标系
                const originX = padding;
                const originY = height - padding;
                const scaleX = (width - 2 * padding) / 1;
                const scaleY = (height - 2 * padding - 50) / 1;

                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制 x² 和 x
                const curves = [
                    { fn: (x) => x * x, color: '#3498db', label: 'α(x) = x²' },
                    { fn: (x) => x, color: '#e74c3c', label: 'β(x) = x' }
                ];

                curves.forEach(curve => {
                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();

                    for (let x = 0; x <= 1; x += 0.01) {
                        const y = curve.fn(x);
                        const canvasX = originX + x * scaleX;
                        const canvasY = originY - y * scaleY;

                        if (x === 0) {
                            this.ctx.moveTo(canvasX, canvasY);
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                    this.ctx.stroke();
                });

                // 动态垂直线
                const lineX = originX + this.x * scaleX;
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(lineX, originY);
                this.ctx.lineTo(lineX, padding + 50);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 动态点
                curves.forEach(curve => {
                    const y = curve.fn(this.x);
                    const canvasX = originX + this.x * scaleX;
                    const canvasY = originY - y * scaleY;

                    this.ctx.fillStyle = curve.color;
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 7, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 15px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, padding + 60);
                this.ctx.fillText(`x² = ${(this.x * this.x).toFixed(4)}`, padding + 10, padding + 85);
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, padding + 110);

                const ratio = this.x / (this.x * this.x);
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.fillText(`β/α = x/x² = ${ratio.toFixed(2)} → ∞`, padding + 10, padding + 140);

                // 图例
                const legendX = width - 180;
                const legendY = padding + 60;

                curves.forEach((curve, i) => {
                    const y = legendY + i * 30;

                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(legendX, y);
                    this.ctx.lineTo(legendX + 30, y);
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#1f2937';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(curve.label, legendX + 40, y + 5);
                });

                // 更新动画
                this.x += this.direction * 0.003;
                if (this.x >= 0.9) this.direction = -1;
                if (this.x <= 0.1) this.direction = 1;
            }
        }

        // 同阶无穷小动画
        class SameOrderAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0.5;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('同阶无穷小：2x 与 x 同阶', width / 2, 35);

                // 绘制坐标系
                const originX = padding;
                const originY = height - padding;
                const scaleX = (width - 2 * padding) / 1;
                const scaleY = (height - 2 * padding - 50) / 2;

                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制 x 和 2x
                const curves = [
                    { fn: (x) => x, color: '#2ecc71', label: 'α(x) = x' },
                    { fn: (x) => 2 * x, color: '#9b59b6', label: 'β(x) = 2x' }
                ];

                curves.forEach(curve => {
                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();

                    for (let x = 0; x <= 1; x += 0.01) {
                        const y = curve.fn(x);
                        const canvasX = originX + x * scaleX;
                        const canvasY = originY - y * scaleY;

                        if (x === 0) {
                            this.ctx.moveTo(canvasX, canvasY);
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                    this.ctx.stroke();
                });

                // 动态垂直线
                const lineX = originX + this.x * scaleX;
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(lineX, originY);
                this.ctx.lineTo(lineX, padding + 50);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 动态点
                curves.forEach(curve => {
                    const y = curve.fn(this.x);
                    const canvasX = originX + this.x * scaleX;
                    const canvasY = originY - y * scaleY;

                    this.ctx.fillStyle = curve.color;
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 7, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 15px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, padding + 60);
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, padding + 85);
                this.ctx.fillText(`2x = ${(2 * this.x).toFixed(3)}`, padding + 10, padding + 110);

                const ratio = (2 * this.x) / this.x;
                this.ctx.fillStyle = '#9b59b6';
                this.ctx.fillText(`β/α = 2x/x = ${ratio.toFixed(1)} (常数)`, padding + 10, padding + 140);

                // 图例
                const legendX = width - 180;
                const legendY = padding + 60;

                curves.forEach((curve, i) => {
                    const y = legendY + i * 30;

                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(legendX, y);
                    this.ctx.lineTo(legendX + 30, y);
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#1f2937';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(curve.label, legendX + 40, y + 5);
                });

                // 更新动画
                this.x += this.direction * 0.003;
                if (this.x >= 0.9) this.direction = -1;
                if (this.x <= 0.1) this.direction = 1;
            }
        }

        // 等价无穷小概念动画
        class EquivalentConceptAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0.5;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('等价无穷小：sin(x) ~ x (x → 0)', width / 2, 35);

                // 绘制坐标系
                const originX = width / 2;
                const originY = height - padding;
                const scaleX = (width - 2 * padding) / 2;
                const scaleY = (height - 2 * padding - 50) / 2;

                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制 x 和 sin(x)
                const curves = [
                    { fn: (x) => x, color: '#2ecc71', label: 'y = x', dash: false },
                    { fn: (x) => Math.sin(x), color: '#ef4444', label: 'y = sin(x)', dash: false }
                ];

                curves.forEach(curve => {
                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    if (curve.dash) this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();

                    for (let x = -1; x <= 1; x += 0.01) {
                        const y = curve.fn(x);
                        const canvasX = originX + x * scaleX;
                        const canvasY = originY - y * scaleY;

                        if (x === -1) {
                            this.ctx.moveTo(canvasX, canvasY);
                        } else {
                            this.ctx.lineTo(canvasX, canvasY);
                        }
                    }
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                });

                // 动态垂直线
                const lineX = originX + this.x * scaleX;
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 1.5;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(lineX, originY);
                this.ctx.lineTo(lineX, padding + 50);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 动态点
                curves.forEach(curve => {
                    const y = curve.fn(this.x);
                    const canvasX = originX + this.x * scaleX;
                    const canvasY = originY - y * scaleY;

                    this.ctx.fillStyle = curve.color;
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 7, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 15px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, padding + 60);
                this.ctx.fillText(`x = ${this.x.toFixed(3)}`, padding + 10, padding + 85);
                this.ctx.fillText(`sin(x) = ${Math.sin(this.x).toFixed(4)}`, padding + 10, padding + 110);

                const ratio = Math.sin(this.x) / this.x;
                this.ctx.fillStyle = '#2ecc71';
                this.ctx.fillText(`sin(x)/x = ${ratio.toFixed(4)} → 1`, padding + 10, padding + 140);

                // 图例
                const legendX = width - 180;
                const legendY = padding + 60;

                curves.forEach((curve, i) => {
                    const y = legendY + i * 30;

                    this.ctx.strokeStyle = curve.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(legendX, y);
                    this.ctx.lineTo(legendX + 30, y);
                    this.ctx.stroke();

                    this.ctx.fillStyle = '#1f2937';
                    this.ctx.font = '14px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(curve.label, legendX + 40, y + 5);
                });

                // 更新动画
                this.x += this.direction * 0.003;
                if (this.x >= 0.9) this.direction = -1;
                if (this.x <= 0.1) this.direction = 1;
            }
        }

        // 等价无穷小公式表动画
        class EquivalentFormulasAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.currentFormula = 0;
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 50;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 20px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('常用等价无穷小公式（x → 0）', width / 2, 35);

                // 公式列表
                const formulas = [
                    { text: 'sin x ~ x', color: '#3b82f6' },
                    { text: 'tan x ~ x', color: '#10b981' },
                    { text: 'arcsin x ~ x', color: '#f59e0b' },
                    { text: 'arctan x ~ x', color: '#ef4444' },
                    { text: '1 - cos x ~ x²/2', color: '#8b5cf6' },
                    { text: 'ln(1+x) ~ x', color: '#ec4899' },
                    { text: 'e^x - 1 ~ x', color: '#14b8a6' },
                    { text: '√(1+x) - 1 ~ x/2', color: '#f97316' }
                ];

                // 左右分栏显示
                const leftX = width / 4;
                const rightX = 3 * width / 4;
                const startY = 80;
                const gap = 55;

                formulas.forEach((formula, i) => {
                    const x = i < 4 ? leftX : rightX;
                    const y = startY + (i % 4) * gap;

                    // 高亮当前公式
                    const isActive = Math.floor(this.time / 60) % formulas.length === i;

                    if (isActive) {
                        this.ctx.fillStyle = formula.color + '30';
                        this.ctx.fillRect(x - 120, y - 25, 240, 45);

                        this.ctx.strokeStyle = formula.color;
                        this.ctx.lineWidth = 3;
                        this.ctx.strokeRect(x - 120, y - 25, 240, 45);
                    }

                    this.ctx.fillStyle = isActive ? formula.color : '#6b7280';
                    this.ctx.font = isActive ? 'bold 18px Arial' : '16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(formula.text, x, y);
                });

                // 底部说明
                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '14px Arial';
                this.ctx.fillText('这些公式在极限运算中可以直接互换，大大简化计算', width / 2, height - 25);

                this.time += 1;
            }
        }

        // 第五节：连续性概念动画
        class ContinuityConceptAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('连续函数：一笔画出', width / 2, 35);

                // 左右对比
                const leftX = width / 4;
                const rightX = 3 * width / 4;

                // 左侧：连续函数
                this.ctx.fillStyle = '#10b981';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.fillText('连续', leftX, 70);

                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                for (let x = padding; x < leftX + 150; x++) {
                    const y = height / 2 + 60 * Math.sin((x - padding) / 40 + this.time);
                    if (x === padding) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();

                // 笔的图标（动画）
                const penX = padding + ((leftX + 150 - padding) / 2) * (1 + Math.sin(this.time * 2)) / 2;
                const penY = height / 2 + 60 * Math.sin((penX - padding) / 40 + this.time);

                this.ctx.fillStyle = '#ef4444';
                this.ctx.beginPath();
                this.ctx.arc(penX, penY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 右侧：间断函数
                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('间断', rightX, 70);

                // 绘制间断曲线
                this.ctx.strokeStyle = '#f59e0b';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                const gapX = rightX;
                for (let x = rightX - 150; x < rightX + 150; x++) {
                    if (Math.abs(x - gapX) < 10) continue; // 制造间断

                    const y = height / 2 + 60 * Math.sin((x - (rightX - 150)) / 40);
                    if (x === rightX - 150) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();

                // 间断点标记
                const gapY = height / 2 + 60 * Math.sin((gapX - (rightX - 150)) / 40);
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(gapX, gapY, 8, 0, Math.PI * 2);
                this.ctx.stroke();

                // 说明文字
                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('笔尖不需要抬起', leftX, height - 30);
                this.ctx.fillText('笔尖需要抬起', rightX, height - 30);

                this.time += 0.02;
            }
        }

        // 连续三条件动画
        class ContinuityThreeAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('连续的三个条件', width / 2, 35);

                // 三个条件卡片
                const conditions = [
                    { text: '① f(x₀) 有定义', color: '#3b82f6', icon: '✓' },
                    { text: '② lim f(x) 存在', color: '#10b981', icon: '✓' },
                    { text: '③ 极限 = 函数值', color: '#8b5cf6', icon: '✓' }
                ];

                const cardHeight = 80;
                const gap = 20;
                const startY = 80;

                conditions.forEach((cond, i) => {
                    const y = startY + i * (cardHeight + gap);
                    const scale = 1 + 0.03 * Math.sin(this.time + i * Math.PI / 3);

                    // 卡片背景
                    this.ctx.fillStyle = cond.color + '20';
                    this.ctx.fillRect(padding, y, width - 2 * padding, cardHeight * scale);

                    // 边框
                    this.ctx.strokeStyle = cond.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(padding, y, width - 2 * padding, cardHeight * scale);

                    // 图标
                    this.ctx.fillStyle = cond.color;
                    this.ctx.font = 'bold 36px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(cond.icon, padding + 20, y + cardHeight / 2 + 12);

                    // 文字
                    this.ctx.font = 'bold 18px Arial';
                    this.ctx.fillText(cond.text, padding + 80, y + cardHeight / 2 + 8);
                });

                // 底部说明
                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '15px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('三个条件同时满足，函数在该点连续', width / 2, height - 25);

                this.time += 0.03;
            }
        }

        // 间断点诊断动画
        class DiscontinuityDiagnoseAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.currentType = 0;
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('间断点诊断', width / 2, 35);

                // 三种间断类型
                const types = [
                    { name: '可去间断', color: '#10b981', desc: '极限存在但不等于函数值' },
                    { name: '跳跃间断', color: '#f59e0b', desc: '左右极限存在但不相等' },
                    { name: '无穷间断', color: '#ef4444', desc: '至少一侧极限为无穷' }
                ];

                const currentIndex = Math.floor(this.time / 120) % types.length;

                types.forEach((type, i) => {
                    const y = 80 + i * 70;
                    const isActive = i === currentIndex;

                    // 卡片背景
                    this.ctx.fillStyle = isActive ? type.color + '30' : type.color + '10';
                    this.ctx.fillRect(padding, y, width - 2 * padding, 60);

                    // 边框
                    this.ctx.strokeStyle = type.color;
                    this.ctx.lineWidth = isActive ? 4 : 2;
                    this.ctx.strokeRect(padding, y, width - 2 * padding, 60);

                    // 标题
                    this.ctx.fillStyle = type.color;
                    this.ctx.font = isActive ? 'bold 18px Arial' : 'bold 16px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.fillText(type.name, padding + 20, y + 25);

                    // 描述
                    this.ctx.fillStyle = '#6b7280';
                    this.ctx.font = '14px Arial';
                    this.ctx.fillText(type.desc, padding + 20, y + 48);
                });

                // 底部提示
                this.ctx.fillStyle = '#9ca3af';
                this.ctx.font = '13px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('自动切换演示中...', width / 2, height - 25);

                this.time += 1;
            }
        }

        // 间断点类型演示动画
        class DiscontinuityTypesAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = -2;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('间断点示例：f(x) = (x²-1)/(x-1)', width / 2, 30);

                // 绘制坐标系
                const originX = padding;
                const originY = height - padding;
                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制函数 (x²-1)/(x-1) = x+1 (x≠1)
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                for (let x = -2; x <= 3; x += 0.01) {
                    if (Math.abs(x - 1) < 0.05) continue;

                    const y = x + 1;
                    const canvasX = originX + (x + 2) * (width - 2 * padding) / 5;
                    const canvasY = originY - y * (height - 2 * padding) / 8;

                    if (x === -2) {
                        this.ctx.moveTo(canvasX, canvasY);
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 可去间断点标记
                const holeX = originX + 3 * (width - 2 * padding) / 5;
                const holeY = originY - 2 * (height - 2 * padding) / 8;

                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(holeX, holeY, 8, 0, Math.PI * 2);
                this.ctx.stroke();

                this.ctx.fillStyle = '#ffffff';
                this.ctx.beginPath();
                this.ctx.arc(holeX, holeY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                // 动态点
                if (Math.abs(this.x - 1) > 0.1) {
                    const y = this.x + 1;
                    const canvasX = originX + (this.x + 2) * (width - 2 * padding) / 5;
                    const canvasY = originY - y * (height - 2 * padding) / 8;

                    this.ctx.fillStyle = '#10b981';
                    this.ctx.beginPath();
                    this.ctx.arc(canvasX, canvasY, 7, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 信息
                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('可去间断点 x=1', padding + 10, padding + 20);
                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '13px Arial';
                this.ctx.fillText('lim (x→1) f(x) = 2', padding + 10, padding + 40);

                this.x += this.direction * 0.02;
                if (this.x >= 2.5) this.direction = -1;
                if (this.x <= -1.5) this.direction = 1;
            }
        }

        // 第一类间断点动画
        class FirstDiscontinuityAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('第一类间断点', width / 2, 35);

                // 左右分屏
                const leftX = width / 4;
                const rightX = 3 * width / 4;

                // 左侧：可去间断
                this.ctx.fillStyle = '#10b981';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.fillText('可去间断', leftX, 70);

                const leftOriginY = height / 2;
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, leftOriginY + 50);
                this.ctx.lineTo(leftX - 10, leftOriginY);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(leftX + 10, leftOriginY);
                this.ctx.lineTo(leftX + 150, leftOriginY - 50);
                this.ctx.stroke();

                // 空心圆
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(leftX, leftOriginY, 8, 0, Math.PI * 2);
                this.ctx.stroke();

                // 右侧：跳跃间断
                this.ctx.fillStyle = '#f59e0b';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('跳跃间断', rightX, 70);

                const rightOriginY = height / 2;
                this.ctx.strokeStyle = '#8b5cf6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(rightX - 150, rightOriginY + 50);
                this.ctx.lineTo(rightX, rightOriginY + 20);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(rightX, rightOriginY - 20);
                this.ctx.lineTo(rightX + 150, rightOriginY - 50);
                this.ctx.stroke();

                // 两个空心圆
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.beginPath();
                this.ctx.arc(rightX, rightOriginY + 20, 6, 0, Math.PI * 2);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.arc(rightX, rightOriginY - 20, 6, 0, Math.PI * 2);
                this.ctx.stroke();

                // 说明
                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '13px Arial';
                this.ctx.fillText('左右极限相等', leftX, height - 30);
                this.ctx.fillText('左右极限不等', rightX, height - 30);

                this.time += 0.02;
            }
        }

        // 第二类间断点动画
        class SecondDiscontinuityAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('第二类间断点', width / 2, 35);

                // 左右分屏
                const leftX = width / 4;
                const rightX = 3 * width / 4;

                // 左侧：无穷间断
                this.ctx.fillStyle = '#ef4444';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.fillText('无穷间断', leftX, 70);

                const leftOriginY = height / 2;
                this.ctx.strokeStyle = '#ef4444';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(padding, leftOriginY + 100);
                this.ctx.lineTo(leftX - 5, leftOriginY + 10);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(leftX + 5, leftOriginY - 10);
                this.ctx.lineTo(leftX + 150, leftOriginY - 100);
                this.ctx.stroke();

                // 渐近线
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(leftX, padding + 50);
                this.ctx.lineTo(leftX, height - padding);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                // 右侧：震荡间断
                this.ctx.fillStyle = '#8b5cf6';
                this.ctx.font = 'bold 16px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('震荡间断', rightX, 70);

                const rightOriginY = height / 2;
                this.ctx.strokeStyle = '#8b5cf6';
                this.ctx.lineWidth = 2.5;
                this.ctx.beginPath();

                for (let x = rightX - 150; x < rightX; x += 1) {
                    const freq = 1 / (rightX - x + 1);
                    const y = rightOriginY + 30 * Math.sin(freq * 500 + this.time * 5);
                    if (x === rightX - 150) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();

                // 说明
                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '13px Arial';
                this.ctx.fillText('极限为无穷', leftX, height - 30);
                this.ctx.fillText('无限次震荡', rightX, height - 30);

                this.time += 0.05;
            }
        }

        // 初等函数连续性动画
        class ElementaryContinuityAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.currentFunc = 0;
                this.time = 0;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('初等函数在定义域内连续', width / 2, 35);

                // 函数列表
                const functions = [
                    { name: '多项式', example: 'x² + 2x + 1', color: '#3b82f6' },
                    { name: '指数函数', example: 'e^x', color: '#10b981' },
                    { name: '对数函数', example: 'ln(x)', color: '#f59e0b' },
                    { name: '三角函数', example: 'sin(x)', color: '#ef4444' }
                ];

                const currentIndex = Math.floor(this.time / 90) % functions.length;

                // 绘制函数卡片
                const cardWidth = 150;
                const cardHeight = 100;
                const gap = 20;
                const startX = (width - (cardWidth * 4 + gap * 3)) / 2;
                const y = height / 2 - cardHeight / 2;

                functions.forEach((func, i) => {
                    const x = startX + i * (cardWidth + gap);
                    const isActive = i === currentIndex;

                    // 卡片背景
                    this.ctx.fillStyle = isActive ? func.color + '30' : func.color + '10';
                    this.ctx.fillRect(x, y, cardWidth, cardHeight);

                    // 边框
                    this.ctx.strokeStyle = func.color;
                    this.ctx.lineWidth = isActive ? 4 : 2;
                    this.ctx.strokeRect(x, y, cardWidth, cardHeight);

                    // 函数名
                    this.ctx.fillStyle = func.color;
                    this.ctx.font = isActive ? 'bold 16px Arial' : 'bold 14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(func.name, x + cardWidth / 2, y + 35);

                    // 示例
                    this.ctx.font = '13px Arial';
                    this.ctx.fillStyle = '#6b7280';
                    this.ctx.fillText(func.example, x + cardWidth / 2, y + 65);
                });

                // 底部说明
                this.ctx.fillStyle = '#6b7280';
                this.ctx.font = '14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('这些函数在定义域内都是连续的，可以直接代入求极限', width / 2, height - 25);

                this.time += 1;
            }
        }

        // 闭区间性质动画
        class ClosedIntervalAnimation extends Animation {
            constructor(canvasId) {
                super(canvasId);
                this.x = 0;
                this.direction = 1;
            }

            draw() {
                if (!this.ctx) return;
                const padding = 60;
                const width = this.width;
                const height = this.height;

                // 标题
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 18px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('闭区间上连续函数的性质', width / 2, 35);

                // 绘制坐标系
                const originX = padding;
                const originY = height - padding;
                const scaleX = (width - 2 * padding) / 4;
                const scaleY = (height - 2 * padding - 50) / 6;

                drawCoordinateSystem(this.ctx, this.canvas, {
                    originX: originX,
                    originY: originY,
                    showLabels: true
                });

                // 绘制连续函数 f(x) = -x² + 4x + 1
                this.ctx.strokeStyle = '#3b82f6';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();

                for (let x = 0; x <= 4; x += 0.01) {
                    const y = -x * x + 4 * x + 1;
                    const canvasX = originX + x * scaleX;
                    const canvasY = originY - y * scaleY;

                    if (x === 0) {
                        this.ctx.moveTo(canvasX, canvasY);
                    } else {
                        this.ctx.lineTo(canvasX, canvasY);
                    }
                }
                this.ctx.stroke();

                // 区间端点
                const a = 0, b = 4;
                const fa = -a * a + 4 * a + 1;
                const fb = -b * b + 4 * b + 1;

                this.ctx.fillStyle = '#10b981';
                this.ctx.beginPath();
                this.ctx.arc(originX + a * scaleX, originY - fa * scaleY, 7, 0, Math.PI * 2);
                this.ctx.fill();

                this.ctx.beginPath();
                this.ctx.arc(originX + b * scaleX, originY - fb * scaleY, 7, 0, Math.PI * 2);
                this.ctx.fill();

                // 最大值点
                const xMax = 2;
                const yMax = -xMax * xMax + 4 * xMax + 1;

                this.ctx.fillStyle = '#ef4444';
                this.ctx.beginPath();
                this.ctx.arc(originX + xMax * scaleX, originY - yMax * scaleY, 8, 0, Math.PI * 2);
                this.ctx.fill();

                // 动态点
                const fx = -this.x * this.x + 4 * this.x + 1;
                const canvasX = originX + this.x * scaleX;
                const canvasY = originY - fx * scaleY;

                this.ctx.fillStyle = '#f59e0b';
                this.ctx.beginPath();
                this.ctx.arc(canvasX, canvasY, 6, 0, Math.PI * 2);
                this.ctx.fill();

                // 信息框
                this.ctx.fillStyle = '#1f2937';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.fillText('区间: [0, 4]', padding + 10, padding + 20);

                this.ctx.fillStyle = '#ef4444';
                this.ctx.fillText(`最大值: ${yMax.toFixed(1)} (x=${xMax})`, padding + 10, padding + 45);

                this.ctx.fillStyle = '#10b981';
                this.ctx.fillText(`f(0) = ${fa.toFixed(1)}`, padding + 10, padding + 70);
                this.ctx.fillText(`f(4) = ${fb.toFixed(1)}`, padding + 10, padding + 95);

                // 更新动画
                this.x += this.direction * 0.02;
                if (this.x >= 3.8) this.direction = -1;
                if (this.x <= 0.2) this.direction = 1;
            }
        }

        // 考拉兹序列生成函数
        function updateCollatz() {
            const input = document.getElementById('collatz-input');
            const info = document.getElementById('collatz-info');
            if (!input || !info) return;

            let n = parseInt(input.value);
            if (isNaN(n) || n < 1) {
                info.textContent = '请输入一个正整数';
                return;
            }

            // 调用CollatzAnimation的setInputValue方法
            if (activeAnimation && activeAnimation instanceof CollatzAnimation) {
                activeAnimation.setInputValue(n);

                // 更新信息显示
                const sequence = activeAnimation.sequence;
                info.innerHTML = `
                    <strong>序列长度：</strong>${sequence.length}<br>
                    <strong>前20项：</strong>${sequence.slice(0, 20).join(' → ')}${sequence.length > 20 ? ' → ...' : ''}
                `;
            } else {
                // 如果当前没有CollatzAnimation实例，生成序列并显示信息
                const sequence = [n];
                let steps = 0;
                const maxSteps = 1000;

                while (n !== 1 && steps < maxSteps) {
                    if (n % 2 === 0) {
                        n = n / 2;
                    } else {
                        n = 3 * n + 1;
                    }
                    sequence.push(n);
                    steps++;
                }

                info.innerHTML = `
                    <strong>序列长度：</strong>${sequence.length}<br>
                    <strong>前20项：</strong>${sequence.slice(0, 20).join(' → ')}${sequence.length > 20 ? ' → ...' : ''}
                `;
            }
        }

        // ========================================
        // 键盘导航
        // 用户需求：支持键盘左右方向键切换幻灯片
        // ========================================
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') prevSlide();
            if (e.key === 'ArrowRight') nextSlide();
        });

        // ========================================
        // 鼠标滚轮导航
        // 用户需求：支持鼠标滚轮循环切换幻灯片
        // ========================================
        let wheelTimeout;
        document.addEventListener('wheel', (e) => {
            clearTimeout(wheelTimeout);
            wheelTimeout = setTimeout(() => {
                if (e.deltaY > 0) nextSlide();
                else prevSlide();
            }, 100);
        });

        // ========================================
        // 触摸手势导航
        // 用户需求：移动设备支持滑动切换幻灯片
        // ========================================
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        }, { passive: true });

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 50;

            // 判断是否为有效的水平滑动（水平距离大于垂直距离）
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                if (deltaX > 0) {
                    // 向右滑动 - 上一页
                    prevSlide();
                } else {
                    // 向左滑动 - 下一页
                    nextSlide();
                }
            }
        }

        // ========================================
        // 窗口大小调整处理
        // 用户需求：窗口大小改变时重新绘制动画，优化Canvas尺寸
        // ========================================
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // 重新绘制当前幻灯片的动画
                if (activeAnimation) {
                    // 更新Canvas尺寸
                    activeAnimation.updateCanvasSize();
                    // 停止并重新启动动画
                    activeAnimation.stop();
                    startAnimation(currentSlide);
                }
            }, 300);
        });

        // ========================================
        // 屏幕方向改变处理
        // 用户需求：设备旋转时优化布局
        // ========================================
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                if (activeAnimation) {
                    activeAnimation.updateCanvasSize();
                    activeAnimation.stop();
                    startAnimation(currentSlide);
                }
            }, 300);
        });

        // ========================================
        // 防止双指缩放（可选）
        // 用户需求：在移动设备上保持固定缩放比例
        // ========================================
        document.addEventListener('gesturestart', (e) => {
            e.preventDefault();
        });

        document.addEventListener('gesturechange', (e) => {
            e.preventDefault();
        });

        document.addEventListener('gestureend', (e) => {
            e.preventDefault();
        });


        // ========================================
        // 初始化
        // 用户需求：优化加载体验，显示加载进度
        // ========================================
        window.addEventListener('load', () => {
            // 生成幻灯片
            const slideWrapper = document.getElementById('slideWrapper');
            slidesData.forEach((slideData, index) => {
                const slideDiv = document.createElement('div');
                slideDiv.className = 'slide';
                slideDiv.id = `slide${index + 1}`;
                slideDiv.innerHTML = slideData.content;
                slideWrapper.appendChild(slideDiv);
            });

            totalSlides = slidesData.length;
            document.getElementById('slideNumberTotal').textContent = totalSlides;
            document.getElementById('slideNumberInput').max = totalSlides;

            // 初始化悬浮菜单及关闭逻辑
            initFloatingControl();
            // 构建目录
            try { buildChapterMenu(); } catch (e) { console.warn('构建目录失败', e); }
            try { buildLabMenu(); } catch (e) { console.warn('构建实验室目录失败', e); }
            ['lab-submenu', 'chapter-submenu', 'course-submenu'].forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                const content = el.querySelector('.submenu-content');
                if (content) content.addEventListener('click', ev => ev.stopPropagation());
            });
            document.addEventListener('click', () => {
                closeAllSubmenus();
                const floatingBtn = document.getElementById('floating-control-btn');
                const floatingMenu = document.getElementById('floating-menu-items');
                if (floatingBtn && floatingMenu) {
                    floatingBtn.classList.remove('active');
                    floatingMenu.classList.remove('active');
                }
            });
            document.addEventListener('keydown', (ev) => {
                if (ev.key === 'Escape') {
                    closeAllSubmenus();
                    const floatingBtn = document.getElementById('floating-control-btn');
                    const floatingMenu = document.getElementById('floating-menu-items');
                    if (floatingBtn && floatingMenu) {
                        floatingBtn.classList.remove('active');
                        floatingMenu.classList.remove('active');
                    }
                }
            });

            // 等待MathJax加载完成后显示第一页
            function initPage() {
                showSlide(1);
                hideLoadingOverlay();
            }

            if (window.MathJax && window.MathJax.startup && window.MathJax.startup.promise) {
                MathJax.startup.promise
                    .then(initPage)
                    .catch(err => {
                        console.warn('MathJax加载失败:', err);
                        initPage();
                    });
            } else {
                // 给 MathJax 一些加载时间
                setTimeout(initPage, 1000);
            }
        });

        // ========================================
        // 隐藏加载指示器
        // ========================================
        function hideLoadingOverlay() {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.classList.add('hidden');
                // 完全移除元素以释放资源
                setTimeout(() => {
                    overlay.remove();
                }, 500);
            }
        }

        // ========================================
        // 性能监控（开发用）
        // ========================================
        if (window.performance && window.performance.timing) {
            window.addEventListener('load', () => {
                setTimeout(() => {
                    const perfData = window.performance.timing;
                    const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
                    console.log(`<i class="fa-solid fa-chart-bar"></i> 页面加载时间: ${pageLoadTime}ms`);
                }, 0);
            });
        }
    </script>
</body>

</html>
