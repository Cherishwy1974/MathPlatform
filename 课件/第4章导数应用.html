<!DOCTYPE html>

<html lang="zh-CN">
<head>
    <link rel="stylesheet" href="../common-assets/css/fontawesome.min.css">
    <link rel="stylesheet" href="../common-assets/css/solid.min.css">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>第四章：导数应用 (交互式课件)</title>
<script src="../common-assets/js/d3-7.8.5.min.js"></script>
<!-- 使用统一的MathJax配置文件，避免配置冲突 -->
<script src="../common-assets/js/mathjax-config.js"></script>
<script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready!');
                    });
                }
            }
        };
    </script>
<script async="" id="MathJax-script" src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js" type="text/javascript">
</script>
<style>
        /* === RESET AND BASE STYLES === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
            height: 100%;
        }

        body {
            font-family: 'Inter', 'Source Han Sans SC', 'Noto Sans SC', 'Microsoft YaHei', system-ui, -apple-system, sans-serif;
            background: #FAFAFA;
            overflow: hidden;
            color: #1a1a1a;
            height: 100%;
            line-height: 1.6;
            font-weight: 400;
        }

        /* === SLIDE LAYOUT === */
        .slide-container {
            width: 100%;
            height: 100vh;
            display: flex;
            position: relative;
            gap: 0;
            padding: 0;
        }

        /* Left Content Area - Academic Journal Style */
        .left-content {
            width: 50%;
            height: 100vh;
            padding: 60px 80px 60px 60px;
            background: #FBFBFB;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.6;
            border: none;
            box-shadow: none;
            border-radius: 0;
        }

        /* Right Visualization Area - Subtle Contrast */
        .right-visual {
            width: 50%;
            height: 100vh;
            background: #F8F9FA;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            border: none;
            box-shadow: none;
            border-radius: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        
        /* 确保图表容器充分利用空间 */
        .right-visual > div {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
        }

        /* === SLIDE TRANSITIONS === */
        .slide {
            display: none;
            animation: slideIn 0.5s ease-out;
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .slide.active {
            display: flex;
        }
        
        /* 嵌入的交互式页面特殊样式 */
        .slide.active.extremum-interactive-slide,
        .slide.active.concavity-interactive-slide,
        .slide.active.derivatives-relation-slide {
            display: block !important;
        }
        
        /* iframe嵌入页面特殊样式 - 直接显示iframe，不使用flex布局 */
        .slide.active:has(iframe) {
            display: block;
        }
        
        .slide iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* === 统一的字体系统 === */
        h1 {
            color: #003366;
            font-size: 32px;
            line-height: 1.2;
            font-weight: 700;
            margin: 0 0 16px 0;
            padding: 0;
            letter-spacing: -0.02em;
        }

        h2 {
            color: #008080;
            font-size: 28px;
            line-height: 1.3;
            font-weight: 600;
            margin: 20px 0 12px 0;
            position: relative;
            padding-left: 0;
        }

        h2::before {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #008080;
            border-radius: 2px;
        }

        h3 {
            color: #1a1a1a;
            font-size: 26px;
            line-height: 1.3;
            font-weight: 600;
            margin: 16px 0 8px 0;
        }

        h4 {
            color: #333333;
            font-size: 24px;
            line-height: 1.3;
            font-weight: 500;
            margin: 12px 0 6px 0;
        }

        h5 {
            color: #555555;
            font-size: 22px;
            line-height: 1.3;
            font-weight: 500;
            margin: 10px 0 6px 0;
        }

        p {
            margin-bottom: 12px;
            color: #2d2d2d;
            font-weight: 400;
            font-size: 20px;
            line-height: 2;
        }

        ul, ol {
            margin: 0 0 12px 0;
            line-height: 1.5;
            padding-left: 20px;
            font-size: 15px;
        }

        li {
            margin-bottom: 6px;
            color: #2d2d2d;
            font-size: 15px;
            line-height: 1.5;
        }

        /* === CONTENT MODULES - 去框化设计 === */
        .definition, .theorem, .example, .note {
            background: transparent;
            border: none;
            border-left: 4px solid;
            padding: 12px 0 12px 16px;
            margin: 16px 0;
        }

        .definition {
            border-left-color: #1e40af;
        }

        .theorem {
            border-left-color: #059669;
        }

        .example {
            border-left-color: #dc2626;
        }

        .note {
            border-left-color: #6b7280;
            font-style: italic;
            color: #4b5563;
        }

        .formula-highlight, .math-formula {
            background: transparent;
            padding: 16px 0;
            margin: 16px 0;
            text-align: center;
            font-size: 16px;
            border: none;
            box-shadow: none;
        }

        /* === MathJax 3.x 行内公式样式（mjx-container） === */
        /* 确保.left-content中的行内公式使用inline显示 */
        .left-content mjx-container:not([display="true"]) {
            display: inline !important;
            margin: 0 0.05em !important;
            padding: 0 !important;
            vertical-align: baseline !important;
        }

        .left-content p mjx-container:not([display="true"]) {
            display: inline !important;
            margin: 0 0.05em !important;
            padding: 0 !important;
            vertical-align: baseline !important;
        }
        
        /* 确保mjx-container内部的元素也是行内显示 */
        .left-content mjx-container:not([display="true"]) mjx-math,
        .left-content mjx-container:not([display="true"]) mjx-annotation,
        .left-content mjx-container:not([display="true"]) svg {
            display: inline !important;
            vertical-align: baseline !important;
        }

        .left-content p mjx-container:not([display="true"]) mjx-math,
        .left-content p mjx-container:not([display="true"]) mjx-annotation,
        .left-content p mjx-container:not([display="true"]) svg {
            display: inline !important;
            vertical-align: baseline !important;
        }
        
        /* MathJax 2.x 兼容样式 - 行内公式 */
        .left-content .MathJax:not(.MathJax_Display), 
        .left-content .MathJax_SVG:not(.MathJax_Display),
        .left-content span[class*="MathJax"]:not(.MathJax_Display) {
            display: inline !important;
            margin: 0 0.1em !important;
            padding: 0 !important;
            vertical-align: baseline !important;
        }
        
        .left-content p .MathJax:not(.MathJax_Display), 
        .left-content p .MathJax_SVG:not(.MathJax_Display),
        .left-content p span[class*="MathJax"]:not(.MathJax_Display) {
            margin-left: 0.05em !important;
            margin-right: 0.05em !important;
            padding: 0 !important;
            display: inline !important;
        }
        
        /* 确保行内公式和文字紧密排列 */
        .left-content p {
            word-spacing: normal;
            letter-spacing: normal;
            line-height: 1.5;
            white-space: normal;
        }

        /* 针对MathJax SVG的特定样式 */
        .left-content .MathJax_SVG:not(.MathJax_Display) svg {
            display: inline-block;
            vertical-align: middle;
        }
        
        /* === 块级公式样式（保持居中显示） === */
        /* MathJax 3.x 块级公式 - 只在明确标记为display="true"时居中 */
        .left-content mjx-container[display="true"],
        .formula-highlight mjx-container[display="true"],
        .math-formula mjx-container[display="true"] {
            display: block !important;
            text-align: center !important;
            margin: 16px 0 !important;
            padding: 0 !important;
        }
        
        /* MathJax 2.x 块级公式 */
        .left-content .MathJax_Display,
        .formula-highlight .MathJax_Display,
        .math-formula .MathJax_Display {
            display: block !important;
            text-align: center !important;
            margin: 16px 0 !important;
            padding: 0 !important;
        }
        
        /* .formula-highlight和.math-formula中的行内公式保持行内显示 */
        .formula-highlight p mjx-container:not([display="true"]),
        .math-formula p mjx-container:not([display="true"]) {
            display: inline !important;
            margin: 0 0.05em !important;
            padding: 0 !important;
            vertical-align: baseline !important;
        }

        .formula-highlight p mjx-container:not([display="true"]) mjx-math,
        .math-formula p mjx-container:not([display="true"]) mjx-math {
            display: inline !important;
            vertical-align: baseline !important;
        }
        
        .formula-highlight p .MathJax:not(.MathJax_Display),
        .formula-highlight p .MathJax_SVG:not(.MathJax_Display),
        .math-formula p .MathJax:not(.MathJax_Display),
        .math-formula p .MathJax_SVG:not(.MathJax_Display) {
            display: inline !important;
            margin: 0 0.05em !important;
            padding: 0 !important;
        }
        
        /* .definition、.theorem、.example中的行内公式 */
        .definition mjx-container:not([display="true"]),
        .theorem mjx-container:not([display="true"]),
        .example mjx-container:not([display="true"]),
        .note mjx-container:not([display="true"]) {
            display: inline !important;
            margin: 0 0.05em !important;
            padding: 0 !important;
            vertical-align: baseline !important;
        }

        .definition p mjx-container:not([display="true"]),
        .theorem p mjx-container:not([display="true"]),
        .example p mjx-container:not([display="true"]),
        .note p mjx-container:not([display="true"]) {
            display: inline !important;
            margin: 0 0.05em !important;
            padding: 0 !important;
            vertical-align: baseline !important;
        }

        .definition mjx-container:not([display="true"]) mjx-math,
        .theorem mjx-container:not([display="true"]) mjx-math,
        .example mjx-container:not([display="true"]) mjx-math,
        .note mjx-container:not([display="true"]) mjx-math {
            display: inline !important;
            vertical-align: baseline !important;
        }
        
        .definition .MathJax:not(.MathJax_Display),
        .theorem .MathJax:not(.MathJax_Display),
        .example .MathJax:not(.MathJax_Display),
        .note .MathJax:not(.MathJax_Display) {
            display: inline !important;
            margin: 0 0.1em !important;
            padding: 0 !important;
        }
        
        .definition p .MathJax:not(.MathJax_Display),
        .theorem p .MathJax:not(.MathJax_Display),
        .example p .MathJax:not(.MathJax_Display),
        .note p .MathJax:not(.MathJax_Display) {
            display: inline !important;
            margin: 0 0.05em !important;
            padding: 0 !important;
        }

        .highlight {
            color: #008080;
            font-weight: 600;
        }

        /* === 导航控制 - 第二章极简设计 === */
        .nav-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 1000;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.15);
            color: transparent;
            border: none;
            padding: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0;
            transition: all 0.2s;
            position: relative;
        }

        .nav-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-top: 2px solid rgba(0, 0, 0, 0.5);
            border-right: 2px solid rgba(0, 0, 0, 0.5);
        }

        .nav-btn:first-child::before {
            transform: translate(-40%, -50%) rotate(-135deg);
        }

        .nav-btn:last-child::before {
            transform: translate(-60%, -50%) rotate(45deg);
        }

        .nav-btn:hover {
            background: rgba(0, 0, 0, 0.25);
        }

        .nav-btn:hover::before {
            border-color: rgba(0, 0, 0, 0.7);
        }

        .slide-number {
            font-size: 11px;
            color: #9ca3af;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 0;
            opacity: 0.6;
        }

        .slide-number input {
            width: 50px;
            text-align: right;
            border: none;
            background: transparent;
            font-size: 11px;
            padding: 0 2px;
            margin: 0;
            color: #000000;
            font-weight: 700;
        }

        .slide-number input::-webkit-outer-spin-button,
        .slide-number input::-webkit-inner-spin-button {
            display: none;
        }

        .slide-number input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .slide-number input:focus {
            outline: none;
            color: #000000;
        }

        #slideNumberTotal {
            color: #9ca3af;
        }

        /* === CANVAS STYLING === */
        canvas {
            max-width: 95%;
            max-height: 95%;
            border-radius: 0;
            box-shadow: none;
        }

        /* === CLEAN SCROLLBAR === */
        .left-content::-webkit-scrollbar {
            width: 6px;
        }

        .left-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .left-content::-webkit-scrollbar-thumb {
            background: #E5E7EB;
            border-radius: 3px;
        }

        .left-content::-webkit-scrollbar-thumb:hover {
            background: #D1D5DB;
        }

        @media print {
            body {
                overflow: visible;
            }
            .slide {
                display: block !important;
                page-break-after: always;
            }
            .nav-container {
                display: none !important;
            }
        }
    </style>
    <style>
        /* 悬浮主按钮与二级按钮（统一样式） */
        .floating-control-btn {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.08);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            z-index: 1100;
            transition: all 0.25s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            font-size: 24px;
            font-weight: 700;
            color: #1f2937;
        }
        .floating-control-btn:hover { transform: translateY(-2px); box-shadow: 0 12px 32px rgba(0,0,0,0.18); }
        .floating-control-btn.active .btn-icon { transform: rotate(45deg); }
        .floating-control-btn .btn-icon { transition: transform 0.25s ease; }

        .floating-menu-items {
            position: fixed;
            bottom: 30px;
            left: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-left: 70px;
            z-index: 1099;
            pointer-events: none;
        }
        .floating-menu-item {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 10px 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            transition: all 0.25s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 110px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            opacity: 0;
            transform: scale(0.98);
            pointer-events: none;
        }
        .floating-menu-items.active .floating-menu-item { opacity: 1; transform: scale(1); pointer-events: auto; }
        .floating-menu-item:hover { transform: translateY(-2px); box-shadow: 0 12px 32px rgba(0,0,0,0.18); background: rgba(59,130,246,0.06); }
        .floating-menu-item .item-icon { font-size: 16px; min-width: 20px; }
        .floating-menu-item .item-text { font-size: 13px; font-weight: 500; color: #374151; white-space: nowrap; }

        /* 弹层（实验室/本章目录/全部目录） */
        .lab-submenu {
            display: none;
            position: fixed;
            top: 12%;
            left: 50%;
            transform: translateX(-50%);
            width: 92vw;
            max-width: 1000px;
            max-height: 76vh;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 18px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.25);
            z-index: 2000;
            overflow: hidden;
        }
        .submenu-content { display: flex; flex-direction: column; height: 100%; position: relative; }
        .submenu-title { background: linear-gradient(135deg, #4a90e2, #9b59b6); color: #fff; padding: 16px 24px; font-size: 18px; font-weight: 600; text-align: center; }
        .submenu-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 14px; padding: 20px; overflow-y: auto; max-height: calc(76vh - 96px); }
        .submenu-item { background: rgba(59, 130, 246, 0.06); border: 1px solid rgba(59,130,246,0.18); border-radius: 10px; padding: 12px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 10px; }
        .submenu-item:hover { background: rgba(59,130,246,0.12); border-color: rgba(59,130,246,0.35); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(59,130,246,0.18); }
        .submenu-icon { font-size: 18px; min-width: 22px; }
        .submenu-text { font-size: 14px; color: #374151; font-weight: 500; }
        .submenu-close { position: absolute; top: 10px; right: 14px; width: 36px; height: 36px; border-radius: 50%; border: none; background: rgba(255,255,255,0.3); color: #fff; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .submenu-close:hover { background: rgba(255,255,255,0.45); transform: rotate(90deg); }
    </style>
    <!-- 凹凸性交互式演示样式 -->
    <style>
        /* 凹凸性交互式演示专用样式 */
        .concavity-interactive-slide {
            background: #FAFAFA;
        }
        
        .concavity-slide-container {
            width: 100%;
            height: 100vh;
            display: flex;
            position: relative;
            gap: 0;
            padding: 0;
        }
        
        .concavity-slide-container-inner {
            width: 100%;
            height: 100vh;
            display: flex;
            position: relative;
            gap: 0;
            padding: 0;
        }
        
        .concavity-slide {
            display: none;
            width: 100%;
            height: 100%;
        }
        
        .concavity-slide.active {
            display: flex;
        }
        
        .concavity-left-content {
            width: 50%;
            height: 100vh;
            padding: 60px 80px 60px 60px;
            background: #FBFBFB;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.6;
        }
        
        .concavity-right-visual {
            width: 50%;
            height: 100vh;
            background: #F8F9FA;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 40px;
        }
        
        .concavity-graph-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
            padding: 30px;
        }
        
        .concavity-graph-container canvas {
            flex: 1;
            width: 100%;
            cursor: pointer;
            display: block;
            border-radius: 8px;
            background: #fafafa;
        }
        
        .concavity-control-panel {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .concavity-slider-container {
            flex: 1;
        }
        
        .concavity-slider-label {
            font-size: 14px;
            color: #4b5563;
            margin-bottom: 8px;
            display: block;
        }
        
        .concavity-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #e5e7eb;
            border-radius: 3px;
            outline: none;
        }
        
        .concavity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .concavity-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .concavity-slider-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 12px;
            color: #9ca3af;
        }
        
        .concavity-data-panel {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .concavity-data-card {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s;
        }
        
        .concavity-data-card.concavity-highlight-positive {
            background: #f0f9ff;
            border-color: #3b82f6;
        }
        
        .concavity-data-card.concavity-highlight-negative {
            background: #fef3c7;
            border-color: #f59e0b;
        }
        
        .concavity-data-card.concavity-highlight-zero {
            background: #f3f4f6;
            border-color: #9ca3af;
        }
        
        .concavity-data-label {
            font-size: 14px;
            color: #6b7280;
            margin-bottom: 4px;
        }
        
        .concavity-data-value {
            font-size: 24px;
            font-weight: 700;
            color: #1f2937;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        
        .concavity-data-description {
            font-size: 13px;
            color: #6b7280;
            margin-top: 4px;
        }
        
        .concavity-indicator {
            text-align: center;
            padding: 20px;
            background: #f9fafb;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .concavity-icon {
            font-size: 48px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }
        
        .concavity-icon.concavity-concave-up {
            color: #3b82f6;
        }
        
        .concavity-icon.concavity-concave-down {
            color: #f59e0b;
        }
        
        .concavity-icon.concavity-inflection {
            color: #6b7280;
        }
        
        .concavity-text {
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
        }
        
        .concavity-hint-text {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            color: #9ca3af;
            background: rgba(255, 255, 255, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
        }
    </style>
    <style>
        /* 统一封面样式（与第1/2/3章一致） */
        .slide-container.cover {
            align-items: stretch;
        }
        .cover-left {
            padding: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .cover-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(90deg, #4a90e2, #9b59b6);
            color: #fff;
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 14px;
            width: fit-content;
            box-shadow: 0 6px 16px rgba(74,144,226,0.35);
        }
        .cover-title {
            font-size: 4rem;
            line-height: 1.1;
            margin: 18px 0 8px 0;
            color: #1a1a2e;
            background: linear-gradient(90deg, #1a1a2e 0%, #4a90e2 60%, #9b59b6 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .cover-subtitle {
            font-size: 1.6rem;
            color: #4f5b6a;
            margin: 10px 0 18px 0;
        }
        /* 第四章·目录页（简洁列表风格，无卡片） */
        .ch4-toc-title {
            font-size: 2.6rem;
            line-height: 1.1;
            text-align: center;
            background: linear-gradient(90deg, #1f2937 0%, #4a90e2 60%, #9b59b6 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .ch4-toc-grid { display: grid; gap: 12px; margin: 0 auto; max-width: 1100px; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); }
        .ch4-toc-section { padding: 8px 12px; border-left: 3px solid rgba(59,130,246,0.3); }
        .ch4-toc-titleline { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
        .ch4-toc-num { display: inline-flex; align-items: center; justify-content: center; width: 28px; height: 28px; border-radius: 999px; background: rgba(59,130,246,0.12); color: #1f2937; font-size: 14px; font-weight: 700; }
        .ch4-toc-h3 { font-size: 1.18rem; margin: 0; color: #111827; cursor: pointer; }
        .ch4-toc-items { display: grid; gap: 4px; font-size: 0.95rem; color: #4b5563; }
        .ch4-toc-link { cursor: pointer; }
        .ch4-toc-link:hover { text-decoration: underline; }
        /* 右侧目录可视化容器背景（柔和，不喧宾夺主） */
        #vis-contents { position: relative; background:
            radial-gradient(900px 600px at 80% 20%, rgba(99,102,241,0.08), transparent 60%),
            radial-gradient(700px 500px at 20% 80%, rgba(59,130,246,0.08), transparent 60%),
            linear-gradient(135deg, #ffffff 0%, #f8fbff 50%, #faf7ff 100%);
        }
        /* 目录页样式 */
        .toc-header {
            font-size: 3rem;
            line-height: 1.1;
            text-align: center;
            background: linear-gradient(90deg, #1f2937 0%, #4a90e2 60%, #9b59b6 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 1.5rem 0;
            height: 8rem;
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        .toc-grid {
            display: grid;
            gap: 16px;
            margin: 0 auto;
            max-width: 1200px;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        }
        .toc-card {
            position: relative;
            padding: 18px 18px;
            border-radius: 14px;
            background: linear-gradient(180deg, rgba(59,130,246,0.04), rgba(155,89,182,0.04));
            border: 1px solid rgba(0,0,0,0.06);
            box-shadow: 0 6px 16px rgba(0,0,0,0.06);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
        }
        .toc-card:hover { transform: translateY(-2px); box-shadow: 0 12px 24px rgba(59,130,246,0.14); }
        .toc-title { font-size: 1.2rem; font-weight: 700; margin-bottom: 10px; color: #111827; display: flex; align-items: center; gap: 8px; }
        .toc-title .num { display: inline-flex; align-items: center; justify-content: center; width: 28px; height: 28px; border-radius: 999px; background: rgba(59,130,246,0.12); color: #1f2937; font-size: 14px; font-weight: 700; }
        .toc-list { display: grid; gap: 6px; font-size: 0.98rem; color: #4b5563; }
        .toc-actions { margin-top: 12px; display: flex; gap: 8px; }
        .toc-btn { border: 1px solid rgba(59,130,246,0.25); background: rgba(59,130,246,0.06); color: #1f2937; border-radius: 999px; padding: 6px 12px; font-size: 13px; cursor: pointer; }
        .toc-btn:hover { background: rgba(59,130,246,0.12); }
        .cover-meta {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            color: #6b7b8c;
            font-size: 0.95rem;
        }
        .cover-meta span { display: inline-flex; align-items: center; gap: 6px; }
        .cover-actions {
            display: flex;
            gap: 14px;
            margin-top: 26px;
            flex-wrap: wrap;
        }
        .cover-right {
            position: relative;
            overflow: hidden;
        }
        .cover-visual {
            position: relative;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(1200px 800px at 80% 20%, rgba(155, 89, 182, 0.18), transparent 60%),
                radial-gradient(900px 700px at 20% 80%, rgba(74, 144, 226, 0.18), transparent 60%),
                linear-gradient(135deg, #ffffff 0%, #f7faff 50%, #f9f6ff 100%);
        }
        .cover-visual::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(600px 300px at 50% -10%, rgba(255,255,255,0.7), transparent 70%);
            pointer-events: none;
        }
        .math-badge {
            position: absolute;
            padding: 8px 12px;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(0,0,0,0.06);
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            color: #34495e;
            font-weight: 600;
            animation: floatY 6s ease-in-out infinite;
            backdrop-filter: blur(4px);
        }
        .math-badge.b1 { left: 12%; top: 22%; animation-delay: 0s; }
        .math-badge.b2 { right: 14%; top: 30%; animation-delay: 0.8s; }
        .math-badge.b3 { left: 20%; bottom: 18%; animation-delay: 1.5s; }
        .math-badge.b4 { right: 18%; bottom: 22%; animation-delay: 2.2s; }
        @keyframes floatY {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-12px); }
            100% { transform: translateY(0px); }
        }
        .orbit {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 320px;
            height: 320px;
            margin-left: -160px;
            margin-top: -160px;
            border-radius: 50%;
            border: 1px dashed rgba(52, 152, 219, 0.35);
            animation: spin 18s linear infinite;
        }
        .orbit .dot {
            position: absolute;
            top: -6px;
            left: 50%;
            width: 12px;
            height: 12px;
            margin-left: -6px;
            background: #4a90e2;
            border-radius: 50%;
            box-shadow: 0 0 0 6px rgba(74,144,226,0.15);
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
<style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.15);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
    <style>
        /* 返回按钮样式（统一为第1/2章风格） */
        .return-home-panel {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 9999;
            display: flex;
            gap: 10px;
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }
        .return-home-panel:hover { opacity: 1; }
        .return-home-panel .return-link {
            padding: 6px 12px;
            background: rgba(15, 23, 42, 0.7);
            color: #f8fafc;
            text-decoration: none;
            border-radius: 999px;
            font-size: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .return-home-panel .return-link:hover {
            background: rgba(15, 23, 42, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(15, 23, 42, 0.3);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.7);
        }
        .return-home-panel .return-link.return-main:hover {
            background: rgba(79, 70, 229, 0.9);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.3);
        }
    </style>
    <style>
        /* 可视化组件样式 */
        .value-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 14px;
            z-index: 10;
        }

        .value-item {
            margin: 8px 0;
            display: flex;
            align-items: center;
        }

        .value-label {
            font-weight: 600;
            color: #555;
            margin-right: 10px;
        }

        .value-number {
            color: #3498db;
            font-weight: bold;
            font-size: 16px;
        }

        .slider-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
            z-index: 10;
        }

        .slider {
            width: 300px;
            margin-top: 10px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }

        /* 动画效果 */
        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* 确保可视化容器有正确的尺寸 */
        .right-visual > div {
            position: relative;
            min-height: 100%;
        }
    </style>
</head>
<body>
    <div class="return-home-panel">
        <a class="return-link" href="../index.html"><i class="fa-solid fa-house"></i> 返回主站</a>
        <a class="return-link return-main" href="javascript:void(0)" onclick="event.stopPropagation(); toggleCourseSubmenu()"><i class="fa-solid fa-arrow-left"></i> 返回目录</a>
    </div>
<div id="slidesContainer">
<!-- 第1页：标题页 -->
<div class="slide active"><div class="slide-container cover"><div class="left-content tex2jax_process cover-left">
<div class="cover-badge"><i class="fa-solid fa-seedling"></i><span> 第四章</span></div>
<h1 class="cover-title">导数应用</h1>
<p class="cover-subtitle">从理论到实践的桥梁</p>
<div class="cover-meta">
<span><i class="fa-solid fa-book-open"></i> 基础篇</span>
<span><i class="fa-solid fa-bolt"></i> 关键概念速览</span>
</div>
<div class="cover-actions">
<a class="home-link-btn" href="../index.html"><span>主页</span></a>
<a class="home-link-btn" href="../故事书/第四章/侯爵的交易.html"><span>故事书</span></a>
<a class="home-link-btn" href="../习题/assets/derivative-application.html"><span>习题</span></a>
<a class="home-link-btn" href="https://ai.projectmath.xyz/project/index.html"><span>产教融合</span></a>
</div>
</div><div class="right-visual cover-right"><div class="cover-visual">
<div class="math-badge b1">MVT</div>
<div class="math-badge b2">f'(x)=0</div>
<div class="math-badge b3">max/min</div>
<div class="orbit"><span class="dot"></span></div>
<div id="vis-title"></div>
</div></div></div></div>
<!-- 第2页：目录 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<div class="ch4-toc-title">目录</div>
<div class="ch4-toc-grid">
    <div class="ch4-toc-section">
        <div class="ch4-toc-titleline" onclick="try{ goToSlide(2);}catch(_){ }">
            <span class="ch4-toc-num">01</span>
            <h3 class="ch4-toc-h3">微分中值定理</h3>
        </div>
        <div class="ch4-toc-items">
            <div class="ch4-toc-link" onclick="try{ goToSlide(4);}catch(_){ }">• 罗尔定理</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(5);}catch(_){ }">• 拉格朗日中值定理</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(6);}catch(_){ }">• 柯西中值定理</div>
        </div>
    </div>
    <div class="ch4-toc-section">
        <div class="ch4-toc-titleline" onclick="try{ goToSlide(7);}catch(_){ }">
            <span class="ch4-toc-num">02</span>
            <h3 class="ch4-toc-h3">利用导数求极限（洛必达）</h3>
        </div>
        <div class="ch4-toc-items">
            <div class="ch4-toc-link" onclick="try{ goToSlide(8);}catch(_){ }">• 法则内容与条件</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(9);}catch(_){ }">• 解题步骤</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(10);}catch(_){ }">• 典型例题</div>
        </div>
    </div>
    <div class="ch4-toc-section">
        <div class="ch4-toc-titleline" onclick="try{ goToSlide(10);}catch(_){ }">
            <span class="ch4-toc-num">03</span>
            <h3 class="ch4-toc-h3">函数的单调性与极值</h3>
        </div>
        <div class="ch4-toc-items">
            <div class="ch4-toc-link" onclick="try{ goToSlide(12);}catch(_){ }">• 导数与单调性</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(14);}catch(_){ }">• 单调区间求法</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(16);}catch(_){ }">• 极值的概念</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(17);}catch(_){ }">• 为什么f'(x)=0只是嫌疑点</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(18);}catch(_){ }">• 极值判定与求法</div>
        </div>
    </div>
    <div class="ch4-toc-section">
        <div class="ch4-toc-titleline" onclick="try{ goToSlide(28);}catch(_){ }">
            <span class="ch4-toc-num">04</span>
            <h3 class="ch4-toc-h3">曲线的凹凸性与拐点</h3>
        </div>
        <div class="ch4-toc-items">
            <div class="ch4-toc-link" onclick="try{ goToSlide(29);}catch(_){ }">• 凹凸性判定</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(30);}catch(_){ }">• 二阶导数与凹凸性（交互式）</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(31);}catch(_){ }">• 拐点求法</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(33);}catch(_){ }">• 应用实例</div>
        </div>
    </div>
    <div class="ch4-toc-section">
        <div class="ch4-toc-titleline" onclick="try{ goToSlide(20);}catch(_){ }">
            <span class="ch4-toc-num">05</span>
            <h3 class="ch4-toc-h3">利用导数求最值</h3>
        </div>
        <div class="ch4-toc-items">
            <div class="ch4-toc-link" onclick="try{ goToSlide(24);}catch(_){ }">• 最值求法</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(22);}catch(_){ }">• 优化问题</div>
            <div class="ch4-toc-link" onclick="try{ goToSlide(23);}catch(_){ }">• 实际应用</div>
        </div>
    </div>
 </div>
 </div><div class="right-visual"><div id="vis-contents"></div></div></div></div>
<!-- 第3页：第一部分过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center;">
<h1 style="font-size: 3rem; color: #008080; margin-bottom: 2rem;">第一部分</h1>
<h2 style="font-size: 2.5rem; color: #003366; margin-bottom: 1rem;">微分中值定理</h2>
<p style="font-size: 1.5rem; color: #666;">连接函数局部性质与整体性质的桥梁</p>
<div style="margin-top: 3rem; padding: 1.5rem; background: #f0f8ff; border-left: 5px solid #008080; border-radius: 8px;">
<p style="font-size: 1.2rem; color: #2c3e50; margin: 0;">本章内容：罗尔定理、拉格朗日中值定理、柯西中值定理</p>
</div>
</div>
</div><div class="right-visual"><div id="vis-section1"></div></div></div></div>
<!-- 第4页：中值定理概述 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>微分中值定理</h2>
<h3>连接局部与整体的桥梁</h3>
<p>中值定理是微积分中最重要的理论基础之一，它建立了函数在区间上的整体性质与某点导数（局部性质）之间的联系。</p>
<div class="math-formula">
<p style="font-size: 1.3rem; color: #008080; margin: 20px 0;">
三大中值定理：
</p>
</div>
<div style="display: grid; gap: 1rem; margin-top: 20px;">
<div style="padding: 15px; border-left: 4px solid #059669;">
<strong>1. 罗尔定理（Rolle's Theorem）</strong>
<p style="margin-top: 8px;">端点相等 → 中间存在水平切线</p>
</div>
<div style="padding: 15px; border-left: 4px solid #dc2626;">
<strong>2. 拉格朗日中值定理（Lagrange's MVT）</strong>
<p style="margin-top: 8px;">平均变化率 = 某点瞬时变化率</p>
</div>
<div style="padding: 15px; border-left: 4px solid #9333ea;">
<strong>3. 柯西中值定理（Cauchy's MVT）</strong>
<p style="margin-top: 8px;">两函数比值的推广形式</p>
</div>
</div>
</div><div class="right-visual"><div id="vis-mvt-overview"></div></div></div></div>
<!-- 第5页：罗尔定理 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>罗尔定理</h2>
<div class="formula-highlight">
<p><strong>定理内容：</strong>若函数 $f(x)$ 满足以下条件，则至少存在一点 $\xi \in (a,b)$，使得 $f'(\xi) = 0$。</p>
<p><strong>① 连续性：</strong>在闭区间 $[a,b]$ 上连续</p>
<p><strong>② 可导性：</strong>在开区间 $(a,b)$ 内可导</p>
<p><strong>③ 端点相等：</strong>$f(a) = f(b)$（端点函数值相等）</p>
</div>
<h3>几何意义</h3>
<p>如果一条光滑曲线的两端在同一水平高度，那么在中间某处<span class="highlight">必定存在水平切线</span>。</p>
<div class="note">
<p><strong>应用：</strong>证明方程根的存在性、函数零点问题</p>
</div>
</div><div class="right-visual"><div id="vis-rolle"></div></div></div></div>
<!-- 第6页：拉格朗日中值定理 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>拉格朗日中值定理</h2>
<div class="formula-highlight">
<p><strong>定理内容：</strong>若函数 $f(x)$ 满足以下条件，则至少存在一点 $\xi \in (a,b)$，使得 $f'(\xi) = \frac{f(b) - f(a)}{b - a}$。</p>
<p><strong>① 连续性：</strong>在闭区间 $[a,b]$ 上连续</p>
<p><strong>② 可导性：</strong>在开区间 $(a,b)$ 内可导</p>
</div>
<h3>几何意义</h3>
<p>曲线上<span class="highlight">两点连线的斜率</span>（平均变化率）等于曲线在<span class="highlight">某一点的切线斜率</span>（瞬时变化率）。</p>
<div class="note">
<p><strong>物理意义：</strong>平均速度必等于某时刻的瞬时速度</p>
<p><strong>重要性：</strong>是微分学中最重要的定理，很多其他定理都由此导出</p>
</div>
</div><div class="right-visual"><div id="vis-lagrange"></div></div></div></div>
<!-- 第7页：柯西中值定理 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>柯西中值定理</h2>
<div class="formula-highlight">
<p><strong>定理内容：</strong>若函数 $f(x)$ 和 $g(x)$ 满足以下条件，则至少存在一点 $\xi \in (a,b)$，使得 $\frac{f'(\xi)}{g'(\xi)} = \frac{f(b) - f(a)}{g(b) - g(a)}$。</p>
<p><strong>① 同时连续：</strong>$f(x)$、$g(x)$ 在闭区间 $[a,b]$ 上连续</p>
<p><strong>② 同时可导：</strong>$f(x)$、$g(x)$ 在开区间 $(a,b)$ 内可导</p>
<p><strong>③ 分母有意义：</strong>$g'(x) \neq 0$ 在 $(a,b)$ 内成立</p>
</div>
<h3>与拉格朗日定理的关系</h3>
<p>当 $g(x) = x$ 时，柯西中值定理就退化为<span class="highlight">拉格朗日中值定理</span>。</p>
<div class="note">
<p><strong>应用：</strong>洛必达法则的理论基础</p>
</div>
</div><div class="right-visual"><div id="vis-cauchy"></div></div></div></div>
<!-- 第7.5页：微分中值定理三合一可视化 -->
<div class="slide"><div class="slide-container" style="display: flex;"><div class="left-content" style="width: 0; flex-shrink: 0; padding: 0; margin: 0; overflow: hidden; display: none; border: none;"></div><div class="right-visual" style="width: 100%; flex: 1; height: 100vh; padding: 0; overflow: hidden;">
<div id="mvt-interactive-vis" style="width: 100%; height: 100%; overflow: auto; background: #FAFAFA; padding: 20px;">
<!-- 引入Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<style>
    #mvt-interactive-vis {
        font-family: 'Inter', 'Helvetica Neue', 'Arial', 'sans-serif';
        overscroll-behavior: none;
    }
    /* 自定义滑块样式 */
    #mvt-interactive-vis input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        background: #4F46E5;
        cursor: pointer;
        border-radius: 50%;
        margin-top: -6px;
    }
    #mvt-interactive-vis input[type=range]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        background: #4F46E5;
        cursor: pointer;
        border-radius: 50%;
    }
    #mvt-interactive-vis canvas {
        touch-action: none;
    }
    /* 选项卡激活样式 */
    #mvt-interactive-vis .tab-btn.active {
        background-color: #4F46E5;
        color: white;
        font-weight: 600;
    }
</style>
<div class="bg-gray-100 text-gray-800 flex flex-col items-center justify-center min-h-full p-4">

    <div class="w-full max-w-4xl bg-white shadow-2xl rounded-2xl p-6 md:p-10">



        <!-- 1. 选项卡按钮 -->
        <div class="flex justify-center rounded-lg shadow-sm mb-6" role="tablist">
            <button id="tab-lagrange" class="tab-btn active w-1/3 p-3 text-sm md:text-base font-medium text-gray-700 bg-gray-100 rounded-l-lg hover:bg-gray-200 transition-all" role="tab">
                拉格朗日 (标准)
            </button>
            <button id="tab-rolle" class="tab-btn w-1/3 p-3 text-sm md:text-base font-medium text-gray-700 bg-gray-100 border-l border-r border-gray-200 hover:bg-gray-200 transition-all" role="tab">
                罗尔 (特殊)
            </button>
            <button id="tab-cauchy" class="tab-btn w-1/3 p-3 text-sm md:text-base font-medium text-gray-700 bg-gray-100 rounded-r-lg hover:bg-gray-200 transition-all" role="tab">
                柯西 (加强)
            </button>
        </div>

        <!-- 2. 可视化区域 -->
        <div class="w-full aspect-[4/3] bg-gray-50 border-2 border-gray-200 rounded-lg overflow-hidden shadow-inner relative">
            <canvas id="mvtCanvas" style="width: 100%; height: 100%; display: block;"></canvas>
        </div>

        <!-- 3. 控制区域 (Lagrange 和 Cauchy 共用) -->
        <div id="controls-sliders" class="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
            <!-- A点控制 -->
            <div class="bg-blue-50 p-4 rounded-lg shadow">
                <label for="sliderA" class="text-lg font-medium text-blue-800 flex justify-between">
                    起点 A (蓝色)
                    <span id="labelA" class="font-bold">0.5</span>
                </label>
                <input type="range" id="sliderA" min="0.1" max="4.5" value="0.5" step="0.01" class="w-full h-2 bg-blue-200 rounded-lg appearance-none cursor-pointer mt-2">
            </div>
            
            <!-- B点控制 -->
            <div class="bg-green-50 p-4 rounded-lg shadow">
                <label for="sliderB" class="text-lg font-medium text-green-800 flex justify-between">
                    终点 B (绿色)
                    <span id="labelB" class="font-bold">8.0</span>
                </label>
                <input type="range" id="sliderB" min="5.0" max="9.5" value="8.0" step="0.01" class="w-full h-2 bg-green-200 rounded-lg appearance-none cursor-pointer mt-2">
            </div>
        </div>

        <!-- 4. 柯西定理的专属数据显示 -->
        <div id="cauchy-display" class="hidden mt-6 p-4 bg-purple-50 rounded-lg shadow text-center">
            <h3 class="text-xl font-semibold text-purple-800">柯西 (Cauchy) - "两车"比值</h3>
            <div class="grid grid-cols-2 gap-4 mt-2">
                <div class="p-3 bg-white rounded shadow-sm">
                    <div class="text-sm text-gray-500">平均比值 (全程)</div>
                    <div id="cauchy-avg-ratio" class="text-2xl font-bold text-purple-700">0.00</div>
                </div>
                <div class="p-3 bg-white rounded shadow-sm">
                    <div class="text-sm text-gray-500">瞬时比值 (在 C 点)</div>
                    <div id="cauchy-inst-ratio" class="text-2xl font-bold text-red-600">0.00</div>
                </div>
            </div>
        </div>

        <!-- 5. 解释区域 -->
        <div class="mt-6 p-4 bg-gray-50 rounded-lg border border-gray-200">
            <!-- 解释内容会由 JS 动态插入 -->
            <div id="explanation-content"></div>
            
            <div id="matchMessage" class="text-center text-2xl font-bold text-green-600 mt-3 h-8 transition-opacity duration-300 opacity-0">
                <!-- 消息会由 JS 动态插入 -->
            </div>
        </div>

    </div>

    <script>
            // 等待DOM加载完成
            (function() {
                let initialized = false;
                
                function initMVT() {
                    // 防止重复初始化
                    if (initialized) return;
                    
                    // --- 1. 初始化 ---
                    const canvas = document.getElementById('mvtCanvas');
                    if (!canvas) {
                        return;
                    }
                    
                    const slide = canvas.closest('.slide');
                    if (!slide || !slide.classList.contains('active')) {
                        return;
                    }
                    
                    initialized = true;
                const ctx = canvas.getContext('2d');
                const sliderA = document.getElementById('sliderA');
                const sliderB = document.getElementById('sliderB');
                const labelA = document.getElementById('labelA');
                const labelB = document.getElementById('labelB');
                const matchMessage = document.getElementById('matchMessage');
                
                const controlsSliders = document.getElementById('controls-sliders');
                const cauchyDisplay = document.getElementById('cauchy-display');
                const explanationContent = document.getElementById('explanation-content');
                
                const tabLagrange = document.getElementById('tab-lagrange');
                const tabRolle = document.getElementById('tab-rolle');
                const tabCauchy = document.getElementById('tab-cauchy');
                const tabs = [tabLagrange, tabRolle, tabCauchy];

                var w, h; // Canvas 宽高
                var c = 0; // 红色切线 (瞬时) 的 x 坐标
                var cDirection = 1; // 扫描方向
                var lastA = -1, lastB = -1;

                var currentTheorem = 'lagrange'; // 'lagrange', 'rolle', 'cauchy'

                // --- 2. 数学函数定义 ---
                
                // Lagrange (f)
                const f_lag = (x) => Math.sin(x * 0.8) * 3 + x * 0.5 + 5;
                const f_lag_prime = (x) => Math.cos(x * 0.8) * 0.8 * 3 + 0.5;
                
                // Rolle (g)
                const f_rolle = (x) => Math.cos(x) * 5 + 10;
                const f_rolle_prime = (x) => -Math.sin(x) * 5;
                const rolle_a = 1.0;
                const rolle_b = 1.0 + 2 * Math.PI; // 约 7.28
                
                // Cauchy (f & g)
                const f_cauchy = f_lag; // f(x)
                const f_cauchy_prime = f_lag_prime; // f'(x)
                const g_cauchy = (x) => x * x * 0.1 + 2; // g(x)
                const g_cauchy_prime = (x) => x * 0.2; // g'(x)

                // --- 3. 坐标转换 ---
                const minX = 0, maxX = 10;
                const minY = 0, maxY = 20;
                const mapX = (x) => w * (x - minX) / (maxX - minX);
                const mapY = (y) => h * (1 - (y - minY) / (maxY - minY));

                // --- 4. 核心绘图函数 ---

                function resizeCanvas() {
                    const container = canvas.parentElement;
                    if (!container || container.clientWidth === 0 || container.clientHeight === 0) {
                        setTimeout(resizeCanvas, 100);
                        return;
                    }
                    w = container.clientWidth;
                    h = container.clientHeight;
                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = w * dpr;
                    canvas.height = h * dpr;
                    ctx.scale(dpr, dpr);
                    canvas.style.width = w + 'px';
                    canvas.style.height = h + 'px';
                }

                function drawAxes() {
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(mapX(minX), mapY(minY)); ctx.lineTo(mapX(minX), mapY(maxY));
                    ctx.moveTo(mapX(minX), mapY(minY)); ctx.lineTo(mapX(maxX), mapY(minY));
                    ctx.stroke();
                }

                // 通用：画函数曲线
                function drawFunction(f, color = '#333', lineWidth = 3) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    ctx.beginPath();
                    ctx.moveTo(mapX(minX), mapY(f(minX)));
                    for (let x = minX; x <= maxX; x += 0.1) {
                        ctx.lineTo(mapX(x), mapY(f(x)));
                    }
                    ctx.stroke();
                }

                // 通用：画点
                function drawPoint(x, y, color = 'red', radius = 8) {
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(mapX(x), mapY(y), radius, 0, 2 * Math.PI);
                    ctx.fill();
                }

                // 通用：画割线
                function drawSecant(f, a, b, color = 'rgba(37, 99, 235, 0.8)', lineWidth = 5) {
                    const pA = { x: mapX(a), y: mapY(f(a)) };
                    const pB = { x: mapX(b), y: mapY(f(b)) };
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    ctx.beginPath();
                    ctx.moveTo(pA.x, pA.y);
                    ctx.lineTo(pB.x, pB.y);
                    ctx.stroke();
                    drawPoint(a, f(a), '#2563EB', 8);
                    drawPoint(b, f(b), '#16A34A', 8);
                }

                // 通用：画切线
                function drawTangent(f, f_prime_val, c, color = 'red', lineWidth = 2) {
                    const pC = { x: mapX(c), y: mapY(f(c)) };
                    const m_inst = f_prime_val;
                    const x1 = c - 2, y1 = f(c) + m_inst * (x1 - c);
                    const x2 = c + 2, y2 = f(c) + m_inst * (x2 - c);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = lineWidth;
                    ctx.beginPath();
                    ctx.moveTo(mapX(x1), mapY(y1));
                    ctx.lineTo(mapX(x2), mapY(y2));
                    ctx.stroke();
                    drawPoint(c, f(c), color, 6);
                }

                // --- 5. UI 更新 (切换选项卡) ---
                
                const explanations = {
                    lagrange: `
                        <h3 class="text-xl font-semibold mb-3 text-gray-700">拉格朗日 (标准版)</h3>
                        <div class="flex items-center mb-2">
                            <div class="w-10 h-1 bg-blue-500 rounded-full mr-3"></div>
                            <span class="text-gray-600"><strong>蓝色粗线:</strong> 代表"<strong>平均速度</strong>"。</span>
                        </div>
                        <div class="flex items-center">
                            <div class="w-10 h-1 bg-red-500 rounded-full mr-3"></div>
                            <span class="text-gray-600"><strong>红色细线:</strong> 代表"<strong>瞬时速度</strong>"。</span>
                        </div>
                        <p class="mt-4 text-center text-lg font-medium text-indigo-600">
                            拖动滑块！红线在扫描时，总有某一刻会和蓝线<strong>完全平行</strong>。
                        </p>`,
                    rolle: `
                        <h3 class="text-xl font-semibold mb-3 text-gray-700">罗尔 (特殊版)</h3>
                        <p class="text-gray-600 mb-2">这是"拉格朗日"的特殊情况：当起点 A 和终点 B 一样高时（回到原地）。</p>
                        <div class="flex items-center mb-2">
                            <div class="w-10 h-1 bg-blue-500 rounded-full mr-3"></div>
                            <span class="text-gray-600"><strong>蓝色粗线:</strong> "平均速度" 为 0 (因为没位移)。</span>
                        </div>
                        <div class="flex items-center">
                            <div class="w-10 h-1 bg-red-500 rounded-full mr-3"></div>
                            <span class="text-gray-600"><strong>红色细线:</strong> "瞬时速度"在扫描。</span>
                        </div>
                        <p class="mt-4 text-center text-lg font-medium text-indigo-600">
                            定理说：红线在扫描时，一定有某一刻也会是<strong>水平的（速度为0）</strong>。
                        </p>`,
                    cauchy: `
                        <h3 class="text-xl font-semibold mb-3 text-gray-700">柯西 (加强版)</h3>
                        <p class="text-gray-600 mb-2">这是"两辆车"(黑色曲线f, 紫色曲线g)的比赛。我们比较的是它们速度的<strong>比值</strong>。</p>
                        <div class="flex items-center mb-2">
                            <div class="w-10 h-1 bg-purple-700 rounded-full mr-3"></div>
                            <span class="text-gray-600"><strong>平均比值:</strong> <code>(f(b)-f(a)) / (g(b)-g(a))</code></span>
                        </div>
                        <div class="flex items-center">
                            <div class="w-10 h-1 bg-red-500 rounded-full mr-3"></div>
                            <span class="text-gray-600"><strong>瞬时比值:</strong> <code>f'(c) / g'(c)</code> (在C点)</span>
                        </div>
                        <p class="mt-4 text-center text-lg font-medium text-indigo-600">
                            拖动滑块！在 C 点扫描时，看下面的数字，总有某一刻<strong>两个比值会相等</strong>。
                        </p>`
                };

                const matchMessages = {
                    lagrange: "✨ 平行了！平均速度 = 瞬时速度 ✨",
                    rolle: "✨ 水平了！瞬时速度为 0 ✨",
                    cauchy: "✨ 比值相等了！ ✨"
                };

                function updateUI(theorem) {
                    currentTheorem = theorem;
                    tabs.forEach(tab => tab.classList.remove('active'));
                    
                    if (theorem === 'lagrange') {
                        tabLagrange.classList.add('active');
                        controlsSliders.style.display = 'grid';
                        cauchyDisplay.style.display = 'none';
                    } else if (theorem === 'rolle') {
                        tabRolle.classList.add('active');
                        controlsSliders.style.display = 'none';
                        cauchyDisplay.style.display = 'none';
                        c = rolle_a; // 重置扫描
                    } else if (theorem === 'cauchy') {
                        tabCauchy.classList.add('active');
                        controlsSliders.style.display = 'grid';
                        cauchyDisplay.style.display = 'block';
                    }
                    
                    explanationContent.innerHTML = explanations[theorem];
                    matchMessage.innerHTML = matchMessages[theorem];
                    matchMessage.style.opacity = '0';
                }

                // --- 6. 动画循环 ---
                function animate() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawAxes();

                    let a = parseFloat(sliderA.value);
                    let b = parseFloat(sliderB.value);
                    if (b <= a + 0.5) { // 确保 b > a
                        b = a + 0.5;
                        sliderB.value = b;
                    }
                    if (a !== lastA || b !== lastB) { // 重置扫描
                        c = a;
                        cDirection = 1;
                        lastA = a;
                        lastB = b;
                    }
                    labelA.textContent = a.toFixed(1);
                    labelB.textContent = b.toFixed(1);

                    let isMatch = false;

                    switch (currentTheorem) {
                        case 'lagrange':
                            drawFunction(f_lag);
                            const m_avg_lag = (f_lag(b) - f_lag(a)) / (b - a);
                            const m_inst_lag = f_lag_prime(c);
                            
                            drawSecant(f_lag, a, b);
                            drawTangent(f_lag, m_inst_lag, c, 'rgba(239, 68, 68, 0.9)');
                            
                            if (Math.abs(m_avg_lag - m_inst_lag) < 0.03) {
                                isMatch = true;
                                drawTangent(f_lag, m_inst_lag, c, '#16A34A', 6); // 绿色高亮
                            }
                            c += (cDirection * 0.05);
                            if (c > b || c < a) cDirection *= -1;
                            c = Math.max(a, Math.min(b, c));
                            break;
                        
                        case 'rolle':
                            drawFunction(f_rolle);
                            const m_avg_rolle = (f_rolle(rolle_b) - f_rolle(rolle_a)) / (rolle_b - rolle_a); // (值为 0)
                            const m_inst_rolle = f_rolle_prime(c);

                            drawSecant(f_rolle, rolle_a, rolle_b); // 会画一条水平线
                            drawTangent(f_rolle, m_inst_rolle, c, 'rgba(239, 68, 68, 0.9)');

                            if (Math.abs(m_inst_rolle) < 0.05) { // 检查瞬时斜率是否接近 0
                                isMatch = true;
                                drawTangent(f_rolle, m_inst_rolle, c, '#16A34A', 6);
                            }
                            c += (cDirection * 0.05);
                            if (c > rolle_b || c < rolle_a) cDirection *= -1;
                            c = Math.max(rolle_a, Math.min(rolle_b, c));
                            break;
                        
                        case 'cauchy':
                            // 画两条曲线
                            drawFunction(f_cauchy, '#333', 3); // f(x)
                            drawFunction(g_cauchy, '#7E22CE', 2); // g(x)

                            // 画 A, B 点
                            drawPoint(a, f_cauchy(a), '#2563EB', 8);
                            drawPoint(b, f_cauchy(b), '#16A34A', 8);
                            drawPoint(a, g_cauchy(a), '#2563EB', 8);
                            drawPoint(b, g_cauchy(b), '#16A34A', 8);

                            // 画 C 点
                            drawPoint(c, f_cauchy(c), 'red', 6);
                            drawPoint(c, g_cauchy(c), 'red', 6);
                            
                            // 计算比值
                            const avg_ratio = (f_cauchy(b) - f_cauchy(a)) / (g_cauchy(b) - g_cauchy(a));
                            const inst_ratio = f_cauchy_prime(c) / g_cauchy_prime(c); // g'(c) 不为 0 (因为 a > 0.1)

                            // 更新数字显示
                            document.getElementById('cauchy-avg-ratio').textContent = avg_ratio.toFixed(3);
                            document.getElementById('cauchy-inst-ratio').textContent = inst_ratio.toFixed(3);
                            
                            if (Math.abs(avg_ratio - inst_ratio) < 0.05) {
                                isMatch = true;
                                // 高亮 C 点
                                drawPoint(c, f_cauchy(c), '#16A34A', 10);
                                drawPoint(c, g_cauchy(c), '#16A34A', 10);
                            }
                            c += (cDirection * 0.05);
                            if (c > b || c < a) cDirection *= -1;
                            c = Math.max(a, Math.min(b, c));
                            break;
                    }
                    
                    matchMessage.style.opacity = isMatch ? '1' : '0';
                    requestAnimationFrame(animate);
                }

                // --- 7. 启动 ---
                tabLagrange.addEventListener('click', () => updateUI('lagrange'));
                tabRolle.addEventListener('click', () => updateUI('rolle'));
                tabCauchy.addEventListener('click', () => updateUI('cauchy'));
                
                window.addEventListener('resize', resizeCanvas);

                resizeCanvas();
                updateUI('lagrange'); // 默认显示拉格朗日
                c = parseFloat(sliderA.value); // 初始化 c
                animate();
            }
            
            // 等待DOM加载完成后再初始化
            function tryInit() {
                const canvas = document.getElementById('mvtCanvas');
                if (!canvas) {
                    setTimeout(tryInit, 200);
                    return;
                }
                
                const slide = canvas.closest('.slide');
                if (!slide) {
                    setTimeout(tryInit, 200);
                    return;
                }
                
                // 如果slide已激活，初始化
                if (slide.classList.contains('active')) {
                    initMVT();
                } else {
                    // 否则等待激活
                    setTimeout(tryInit, 200);
                }
            }
            
            // 监听slide激活事件
            function observeSlideActivation() {
                const canvas = document.getElementById('mvtCanvas');
                if (!canvas) {
                    setTimeout(observeSlideActivation, 100);
                    return;
                }
                
                const slide = canvas.closest('.slide');
                if (slide) {
                    // 使用MutationObserver监听slide的class变化
                    const observer = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                                if (slide.classList.contains('active')) {
                                    setTimeout(() => {
                                        if (!initialized) {
                                            initMVT();
                                        }
                                    }, 100);
                                }
                            }
                        });
                    });
                    observer.observe(slide, { attributes: true, attributeFilter: ['class'] });
                }
                
                // 如果slide已经激活，立即初始化
                if (slide && slide.classList.contains('active')) {
                    setTimeout(tryInit, 100);
                } else {
                    setTimeout(tryInit, 200);
                }
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', observeSlideActivation);
            } else {
                observeSlideActivation();
            }
        })();
    </script>
</div>
</div>
</div></div></div>
<!-- 第8页：第二部分过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center;">
<h1 style="font-size: 3rem; color: #008080; margin-bottom: 2rem;">第二部分</h1>
<h2 style="font-size: 2.5rem; color: #003366; margin-bottom: 1rem;">利用导数求极限</h2>
<p style="font-size: 1.5rem; color: #666;">洛必达法则</p>
<div style="margin-top: 3rem; padding: 1.5rem; background: #f0f8ff; border-left: 5px solid #008080; border-radius: 8px;">
<p style="font-size: 1.2rem; color: #2c3e50; margin: 0;">解决未定式极限问题的强大工具</p>
</div>
</div>
</div><div class="right-visual"><div id="vis-section2"></div></div></div></div>
<!-- 第9页：洛必达法则 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>洛必达法则</h2>
<p>用于求解<span class="highlight">未定式极限</span>的重要工具。</p>
<div class="formula-highlight">
<p><strong>定理：</strong>若 $\lim\limits_{x \to a} f(x) = \lim\limits_{x \to a} g(x) = 0$ 或 $\pm\infty$，且 $g'(x) \neq 0$，则 $\lim_{x \to a} \frac{f(x)}{g(x)} = \lim_{x \to a} \frac{f'(x)}{g'(x)}$</p>
</div>
<h3>适用的未定式类型</h3>
<p>$\frac{0}{0}$ 型；$\frac{\infty}{\infty}$ 型；$0 \cdot \infty$ 型（转化后使用）；$\infty - \infty$ 型（转化后使用）；$1^{\infty}$、$0^0$、$\infty^0$ 型（取对数后使用）</p>
<div class="note">
<p><strong>注意：</strong>使用前必须验证条件，可能需要多次应用</p>
</div>
</div><div class="right-visual"><div id="vis-lhopital"></div></div></div></div>
<!-- 第10页：洛必达法则解题步骤 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>洛必达法则解题步骤</h2>
<h3>标准解题流程</h3>
<p><strong>第一步：验证未定式</strong> 检查是否为 $\frac{0}{0}$ 或 $\frac{\infty}{\infty}$ 型</p>
<p><strong>第二步：求导</strong> 分别对分子和分母求导，得到 $\frac{f'(x)}{g'(x)}$</p>
<p><strong>第三步：计算极限</strong> 若仍为未定式，则继续重复应用洛必达法则</p>
<h3>常见题型解法</h3>
<p><strong>$\frac{0}{0}$ 型：</strong>直接应用法则；<strong>$0 \cdot \infty$ 型：</strong>化为 $\frac{0}{\frac{1}{\infty}} = \frac{0}{0}$；<strong>$\infty - \infty$ 型：</strong>通分化为 $\frac{0}{0}$ 或 $\frac{\infty}{\infty}$；<strong>$1^{\infty}$ 型：</strong>取对数后应用</p>
</div><div class="right-visual"><div id="vis-lhopital-examples"></div></div></div></div>
<!-- 第11页：第三部分过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center;">
<h1 style="font-size: 3rem; color: #008080; margin-bottom: 2rem;">第三部分</h1>
<h2 style="font-size: 2.5rem; color: #003366; margin-bottom: 1rem;">函数的单调性与极值</h2>
<p style="font-size: 1.5rem; color: #666;">利用导数研究函数性质</p>
<div style="margin-top: 3rem; padding: 1.5rem; background: #f0f8ff; border-left: 5px solid #008080; border-radius: 8px;">
<p style="font-size: 1.2rem; color: #2c3e50; margin: 0;">本章内容：单调性判断、单调区间求法、极值判定</p>
</div>
</div>
</div><div class="right-visual"><div id="vis-section3"></div></div></div></div>
<!-- 第12页：导数直观理解 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>导数是什么？</h2>
<h3>瞬时变化率</h3>
<p>导数就是函数在某一点的<span class="highlight">瞬时变化率</span>。速度是位置的变化率；加速度是速度的变化率；成本变化率告诉我们增产的代价。</p>
<div class="math-formula">
                $f'(x) = \lim\limits_{\Delta x \to 0} \frac{f(x+\Delta x) - f(x)}{\Delta x}$
            </div>
<p>通俗地说：导数告诉我们函数在某一点变化的<span class="highlight">快慢</span>和<span class="highlight">方向</span>。</p>
</div><div class="right-visual"><div id="vis-derivative-intro"></div></div></div></div>
<!-- 第13页：切线的几何意义 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>导数的几何意义</h2>
<p>导数 $f'(x_0)$ 是曲线 $y=f(x)$ 在点 $(x_0, f(x_0))$ 处的<span class="highlight">切线斜率</span>。</p>
<div class="math-formula">
                切线方程：$y - f(x_0) = f'(x_0)(x - x_0)$
            </div>
<h3>斜率与函数行为</h3>
<p>$f'(x) &gt; 0$：切线向上倾斜，函数上升；$f'(x) &lt; 0$：切线向下倾斜，函数下降；$f'(x) = 0$：切线水平，可能是极值点</p>
</div><div class="right-visual"><div id="vis-tangent-line"></div></div></div></div>
<!-- 第14页：导数与单调性 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>用导数判断单调性</h2>
<p>导数的符号决定了函数的<span class="highlight">增减性</span>：</p>
<div class="formula-rule">
<p>若 $f'(x) &gt; 0$，则 $f(x)$ 在该区间<span class="highlight">单调递增 ↗</span>；若 $f'(x) &lt; 0$，则 $f(x)$ 在该区间<span class="highlight">单调递减 ↘</span></p>
</div>
<h3>判断步骤</h3>
<p><strong>① 求导数：</strong>先求出 $f'(x)$ 的表达式</p>
<p><strong>② 判断符号：</strong>解不等式 $f'(x) &gt; 0$ 或 $f'(x) &lt; 0$</p>
<p><strong>③ 列出结论：</strong>根据导数符号写出对应的单调区间</p>
</div><div class="right-visual"><div id="vis-monotonicity"></div></div></div></div>
<!-- 第15页：单调性实例 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>单调性判断实例</h2>
<p>例：判断 $f(x) = x^3 - 3x$ 的单调性</p>
<h3>解题步骤</h3>
<p><strong>步骤1：</strong>求导得到 $f'(x) = 3x^2 - 3 = 3(x^2 - 1)$</p>
<p><strong>步骤2：</strong>令 $f'(x) = 0$，可得驻点 $x = \pm 1$</p>
<p><strong>步骤3：</strong>判断导数符号：$x &lt; -1$ 时 $f'(x) &gt; 0$ 为递增；$-1 &lt; x &lt; 1$ 时 $f'(x) &lt; 0$ 为递减；$x &gt; 1$ 时 $f'(x) &gt; 0$ 为递增</p>
</div><div class="right-visual"><div id="vis-monotonicity-example"></div></div></div></div>
<!-- 第16页：求单调区间的方法与例题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>求单调区间的方法</h2>
<h3>标准步骤</h3>
<p><strong>第一步：</strong>求导数 $f'(x)$</p>
<p><strong>第二步：</strong>求驻点，令 $f'(x) = 0$</p>
<p><strong>第三步：</strong>通过列表判断导数符号</p>
<p><strong>第四步：</strong>写出对应的单调区间</p>
<h3>例题：求 $f(x) = x^3 - 6x^2 + 9x + 1$ 的单调区间</h3>
<div class="example">
<p><strong>解：</strong>$f'(x) = 3x^2 - 12x + 9 = 3(x^2 - 4x + 3) = 3(x-1)(x-3)$；令 $f'(x) = 0$，得 $x = 1$ 或 $x = 3$；列表分析：</p>
<table style="margin: 10px 0; border-collapse: collapse;">
<tr><td style="border: 1px solid #ccc; padding: 5px;">$x$</td><td style="border: 1px solid #ccc; padding: 5px;">$(-\infty, 1)$</td><td style="border: 1px solid #ccc; padding: 5px;">$(1, 3)$</td><td style="border: 1px solid #ccc; padding: 5px;">$(3, +\infty)$</td></tr>
<tr><td style="border: 1px solid #ccc; padding: 5px;">$f'(x)$</td><td style="border: 1px solid #ccc; padding: 5px;">$+$</td><td style="border: 1px solid #ccc; padding: 5px;">$-$</td><td style="border: 1px solid #ccc; padding: 5px;">$+$</td></tr>
<tr><td style="border: 1px solid #ccc; padding: 5px;">$f(x)$</td><td style="border: 1px solid #ccc; padding: 5px;">↗</td><td style="border: 1px solid #ccc; padding: 5px;">↘</td><td style="border: 1px solid #ccc; padding: 5px;">↗</td></tr>
</table>
<p><strong>答：</strong>单调递增区间：$(-\infty, 1)$ 和 $(3, +\infty)$；单调递减区间：$(1, 3)$</p>
</div>
</div><div class="right-visual"><div id="vis-monotonic-intervals"></div></div></div></div>
<!-- 第17页：极值的概念 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>极值</h2>
<h3>什么是极值？</h3>
<p><span class="highlight">极值</span>是函数在局部范围内的最大值或最小值。<strong>极大值</strong>：比周围所有点都大；<strong>极小值</strong>：比周围所有点都小</p>
<div class="formula-rule">
                极值点处：$f'(x) = 0$ 或 $f'(x)$ 不存在
            </div>
<p>注意：$f'(x) = 0$ 的点不一定是极值点！</p>
</div><div class="right-visual"><div id="vis-extremum-concept"></div></div></div></div>
<!-- 第17.5页：为什么f'(x)=0只是嫌疑点 - 交互式演示 -->
<div class="slide extremum-interactive-slide" style="display: none; width: 100vw; height: 100vh; margin: 0; padding: 0; overflow: hidden; position: relative;">
<style>
/* 极值点交互式演示 - 作用域样式 */
.extremum-interactive-slide {
    font-family: 'Inter', 'Source Han Sans SC', 'Noto Sans SC', 'Microsoft YaHei', system-ui, -apple-system, sans-serif;
    background: #FAFAFA;
    overflow: hidden;
    color: #1a1a1a;
}
.extremum-interactive-slide .extremum-slide-container {
    width: 100%;
    height: 100vh;
    display: flex;
    position: relative;
    gap: 0;
    padding: 0;
}
.extremum-interactive-slide .extremum-left-content {
    width: 50%;
    height: 100vh;
    padding: 60px 80px 60px 60px;
    background: #FBFBFB;
    overflow-y: auto;
    font-size: 16px;
    line-height: 1.6;
}
.extremum-interactive-slide .extremum-right-visual {
    width: 50%;
    height: 100vh;
    background: #F8F9FA;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    padding: 40px;
}
.extremum-interactive-slide .extremum-slide {
    display: none;
}
.extremum-interactive-slide .extremum-slide.active {
    display: flex;
}
.extremum-interactive-slide h1 {
    color: #003366;
    font-size: 24px;
    line-height: 1.2;
    font-weight: 700;
    margin: 0 0 16px 0;
}
.extremum-interactive-slide h2 {
    color: #008080;
    font-size: 20px;
    line-height: 1.3;
    font-weight: 600;
    margin: 20px 0 12px 0;
    position: relative;
    padding-left: 20px;
}
.extremum-interactive-slide h2::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 4px;
    background: #008080;
    border-radius: 2px;
}
.extremum-interactive-slide h3 {
    color: #1a1a1a;
    font-size: 18px;
    line-height: 1.3;
    font-weight: 600;
    margin: 16px 0 8px 0;
}
.extremum-interactive-slide p {
    margin-bottom: 12px;
    color: #2d2d2d;
    font-weight: 400;
    font-size: 15px;
    line-height: 1.5;
}
.extremum-interactive-slide .highlight {
    background: rgba(59, 130, 246, 0.1);
    padding: 2px 4px;
    border-radius: 3px;
    color: #2563eb;
    font-weight: 500;
}
.extremum-interactive-slide .formula-highlight {
    background: #f0f9ff;
    border-left: 4px solid #3b82f6;
    padding: 16px;
    margin: 20px 0;
    border-radius: 4px;
}
.extremum-interactive-slide .graph-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    background: white;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
    padding: 20px;
}
.extremum-interactive-slide canvas {
    flex: 1;
    width: 100%;
    cursor: crosshair;
    display: block;
    border-radius: 8px;
}
.extremum-interactive-slide .controls-panel {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 20px;
    flex-wrap: wrap;
}
.extremum-interactive-slide .control-button {
    background: #3b82f6;
    color: white;
    border: none;
    padding: 8px 16px;
    font-size: 14px;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 6px;
}
.extremum-interactive-slide .control-button:hover {
    background: #2563eb;
    transform: translateY(-1px);
}
.extremum-interactive-slide .control-button.active {
    background: #10b981;
}
.extremum-interactive-slide .info-panel {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(255, 255, 255, 0.95);
    padding: 12px 16px;
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    font-size: 14px;
    min-width: 150px;
}
.extremum-interactive-slide .key-point {
    background: #fef3c7;
    border: 1px solid #fbbf24;
    padding: 12px 16px;
    border-radius: 6px;
    margin: 16px 0;
    font-size: 14px;
    color: #92400e;
}
</style>
<div class="extremum-slide-counter" style="position: fixed; top: 30px; right: 30px; font-size: 16px; color: #64748b; background: white; padding: 8px 16px; border-radius: 20px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06); z-index: 1000;"><span id="extremumCurrentSlide">1</span> / 3</div>
<!-- 内部子页导航按钮（不影响外层课件导航） -->
<div class="extremum-slide-nav" style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 1000;">
    <button type="button" class="control-button" onclick="extremumPrevSlide(event)">上一页</button>
    <button type="button" class="control-button" onclick="extremumNextSlide(event)">下一页</button>
</div>
<div class="extremum-tooltip" id="extremumTooltip" style="position: absolute; background: rgba(0, 0, 0, 0.8); color: white; padding: 6px 10px; border-radius: 4px; font-size: 13px; pointer-events: none; display: none; z-index: 1000;"></div>
<div class="extremum-slide active">
    <div class="extremum-slide-container">
        <div class="extremum-left-content">
            <h1>为什么 f'(x)=0 只是"嫌疑点"？</h1>
            <h2>1. 局部最大值 (山顶)</h2>
            <p>想象你在爬山，当你到达<span class="highlight">山顶</span>时，会发生什么？</p>
            <h3>关键观察</h3>
            <p>在山顶的那一刻，你既不是在上坡，也不是在下坡——你处于<strong>水平状态</strong>。</p>
            <div class="formula-highlight">
                <p><strong>数学表达：</strong>在极大值点 $x_0$ 处，有 $f'(x_0) = 0$</p>
                <p><strong>几何意义：</strong>切线是水平的（斜率为0）</p>
            </div>
            <h3>判断极大值的方法</h3>
            <p>在 $x_0$ 附近：</p>
            <p>• 左侧：$f'(x) > 0$（函数递增，像上坡）</p>
            <p>• 右侧：$f'(x) < 0$（函数递减，像下坡）</p>
            <div class="key-point">
                <strong>记忆口诀：</strong>"左增右减是山顶"——这是真正的极大值点！
            </div>
            <p style="color: #3b82f6; margin-top: 20px;">
                <i class="fas fa-hand-pointer"></i> 
                <strong>互动提示：</strong>点击右侧图形查看任意点的切线和导数值
            </p>
        </div>
        <div class="extremum-right-visual">
            <div class="graph-container">
                <canvas id="extremumMaxCanvas"></canvas>
                <div class="info-panel" id="extremumMaxInfo" style="display: none;">
                    <strong>点击信息</strong><br>
                    x = <span id="extremumMaxX">0</span><br>
                    y = <span id="extremumMaxY">0</span><br>
                    f'(x) = <span id="extremumMaxDerivative">0</span>
                </div>
                <div class="controls-panel">
                    <button class="control-button" onclick="extremumToggleAnimation('max')">
                        <i class="fas fa-play"></i>
                        <span>播放动画</span>
</button>
                    <button class="control-button active" onclick="extremumToggleTangent('max')">
                        <i class="fas fa-ruler-horizontal"></i>
                        <span>显示切线</span>
                    </button>
                    <button class="control-button" onclick="extremumToggleDerivative('max')">
                        <i class="fas fa-chart-line"></i>
                        <span>显示导数</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="extremum-slide">
    <div class="extremum-slide-container">
        <div class="extremum-left-content">
            <h1>为什么 f'(x)=0 只是"嫌疑点"？</h1>
            <h2>2. 局部最小值 (谷底)</h2>
            <p>现在想象你在<span class="highlight">山谷</span>的最低处，情况又如何？</p>
            <h3>关键观察</h3>
            <p>在谷底，你同样处于<strong>水平状态</strong>——既不是下坡，也不是上坡。</p>
            <div class="formula-highlight">
                <p><strong>数学表达：</strong>在极小值点 $x_0$ 处，有 $f'(x_0) = 0$</p>
                <p><strong>几何意义：</strong>切线是水平的（斜率为0）</p>
            </div>
            <h3>判断极小值的方法</h3>
            <p>在 $x_0$ 附近：</p>
            <p>• 左侧：$f'(x) < 0$（函数递减，像下坡）</p>
            <p>• 右侧：$f'(x) > 0$（函数递增，像上坡）</p>
            <div class="key-point">
                <strong>记忆口诀：</strong>"左减右增是谷底"——这是真正的极小值点！
            </div>
            <h3>实际应用</h3>
            <p>极小值在优化问题中非常重要，比如：</p>
            <p>• 最小成本</p>
            <p>• 最短路径</p>
            <p>• 最少时间</p>
            <p style="color: #3b82f6; margin-top: 20px;">
                <i class="fas fa-hand-pointer"></i> 
                <strong>互动提示：</strong>试试点击动画按钮，观察导数如何变化
            </p>
        </div>
        <div class="extremum-right-visual">
            <div class="graph-container">
                <canvas id="extremumMinCanvas"></canvas>
                <div class="info-panel" id="extremumMinInfo" style="display: none;">
                    <strong>点击信息</strong><br>
                    x = <span id="extremumMinX">0</span><br>
                    y = <span id="extremumMinY">0</span><br>
                    f'(x) = <span id="extremumMinDerivative">0</span>
                </div>
                <div class="controls-panel">
                    <button class="control-button" onclick="extremumToggleAnimation('min')">
                        <i class="fas fa-play"></i>
                        <span>播放动画</span>
                    </button>
                    <button class="control-button active" onclick="extremumToggleTangent('min')">
                        <i class="fas fa-ruler-horizontal"></i>
                        <span>显示切线</span>
                    </button>
                    <button class="control-button" onclick="extremumToggleDerivative('min')">
                        <i class="fas fa-chart-line"></i>
                        <span>显示导数</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
<div class="extremum-slide">
    <div class="extremum-slide-container">
        <div class="extremum-left-content">
            <h1>为什么 f'(x)=0 只是"嫌疑点"？</h1>
            <h2>3. 拐点 (半山腰平台)</h2>
            <p>但是！不是所有 $f'(x) = 0$ 的点都是极值点。看看这个<span class="highlight">特殊情况</span>：</p>
            <h3>拐点的特征</h3>
            <p>在某些点，虽然切线是水平的，但函数<strong>一直在增加</strong>（或一直在减少）。</p>
            <div class="formula-highlight">
                <p><strong>例子：</strong>$f(x) = x^3$ 在 $x = 0$ 处</p>
                <p>• $f'(0) = 0$（切线水平）</p>
                <p>• 但 $x < 0$ 时 $f'(x) > 0$，$x > 0$ 时 $f'(x) > 0$</p>
                <p>• 函数始终递增，<strong>不是极值点！</strong></p>
            </div>
            <h3>为什么会这样？</h3>
            <p>想象在爬山途中遇到一个<strong>平台</strong>：</p>
            <p>• 你暂时走在水平路上（$f'(x) = 0$）</p>
            <p>• 但整体趋势仍是上山（函数递增）</p>
            <p>• 这只是一个"喘息点"，不是山顶或谷底</p>
            <div class="key-point">
                <strong>重要结论：</strong>$f'(x) = 0$ 只是极值点的<strong>必要条件</strong>，不是充分条件。
                这就是为什么我们称它为"嫌疑点"——需要进一步检验！
            </div>
            <h3>判断方法总结</h3>
            <p><strong>第一步：</strong>找出所有 $f'(x) = 0$ 的点（嫌疑点）</p>
            <p><strong>第二步：</strong>检查每个点两侧导数的符号变化</p>
            <p><strong>第三步：</strong>只有符号发生变化的点才是真正的极值点</p>
        </div>
        <div class="extremum-right-visual">
            <div class="graph-container">
                <canvas id="extremumInflectionCanvas"></canvas>
                <div class="info-panel" id="extremumInflectionInfo" style="display: none;">
                    <strong>点击信息</strong><br>
                    x = <span id="extremumInflectionX">0</span><br>
                    y = <span id="extremumInflectionY">0</span><br>
                    f'(x) = <span id="extremumInflectionDerivative">0</span>
                </div>
                <div class="controls-panel">
                    <button class="control-button" onclick="extremumToggleAnimation('inflection')">
                        <i class="fas fa-play"></i>
                        <span>播放动画</span>
                    </button>
                    <button class="control-button active" onclick="extremumToggleTangent('inflection')">
                        <i class="fas fa-ruler-horizontal"></i>
                        <span>显示切线</span>
                    </button>
                    <button class="control-button" onclick="extremumToggleDerivative('inflection')">
                        <i class="fas fa-chart-line"></i>
                        <span>显示导数</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
<script>
(function() {
    'use strict';
    let extremumCurrentSlide = 1;
    const extremumTotalSlides = 3;
    const extremumGraphStates = {
        max: { animation: false, tangent: true, derivative: false, clickPoint: null },
        min: { animation: false, tangent: true, derivative: false, clickPoint: null },
        inflection: { animation: false, tangent: true, derivative: false, clickPoint: null }
    };
    let extremumAnimationFrames = {};
    let extremumAnimationProgress = {};

    function extremumSetupCanvas(canvas) {
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        return ctx;
    }

    function extremumShowSlide(n) {
        const container = document.querySelector('.extremum-interactive-slide');
        if (!container) return;
        const slides = container.querySelectorAll('.extremum-slide');
        if (slides.length === 0) return;
        if (n > extremumTotalSlides) extremumCurrentSlide = extremumTotalSlides;
        if (n < 1) extremumCurrentSlide = 1;
        slides.forEach(slide => slide.classList.remove('active'));
        if (slides[extremumCurrentSlide - 1]) {
            slides[extremumCurrentSlide - 1].classList.add('active');
        }
        const currentSlideEl = document.getElementById('extremumCurrentSlide');
        if (currentSlideEl) currentSlideEl.textContent = extremumCurrentSlide;
        Object.keys(extremumAnimationFrames).forEach(key => {
            if (extremumAnimationFrames[key]) {
                cancelAnimationFrame(extremumAnimationFrames[key]);
                extremumAnimationFrames[key] = null;
            }
        });
        setTimeout(() => extremumDrawCurrentSlide(), 100);
    }

    function extremumDrawCurrentSlide() {
        if (extremumCurrentSlide === 1) extremumDrawMaximum();
        if (extremumCurrentSlide === 2) extremumDrawMinimum();
        if (extremumCurrentSlide === 3) extremumDrawInflection();
    }

    function extremumDrawMaximum() {
        const canvas = document.getElementById('extremumMaxCanvas');
        if (!canvas) return;
        const ctx = extremumSetupCanvas(canvas);
        const rect = canvas.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        ctx.clearRect(0, 0, width, height);
        const padding = 40;
        const centerX = width / 2;
        const centerY = height / 2;
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(padding, centerY);
        ctx.lineTo(width - padding, centerY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX, padding);
        ctx.lineTo(centerX, height - padding);
        ctx.stroke();
        ctx.fillStyle = '#9ca3af';
        ctx.beginPath();
        ctx.moveTo(width - padding, centerY);
        ctx.lineTo(width - padding - 8, centerY - 4);
        ctx.lineTo(width - padding - 8, centerY + 4);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(centerX, padding);
        ctx.lineTo(centerX - 4, padding + 8);
        ctx.lineTo(centerX + 4, padding + 8);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let px = padding; px < width - padding; px++) {
            const x = ((px - centerX) / (width - 2 * padding)) * 6;
            const y = -x * x + 2;
            const py = centerY - y * 50;
            if (px === padding) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();
        const state = extremumGraphStates.max;
        const targetX = state.clickPoint ? state.clickPoint.x : 0;
        const targetY = -targetX * targetX + 2;
        const targetPx = centerX + targetX * (width - 2 * padding) / 6;
        const targetPy = centerY - targetY * 50;
        ctx.fillStyle = state.clickPoint ? '#f59e0b' : '#ef4444';
        ctx.beginPath();
        ctx.arc(targetPx, targetPy, 6, 0, Math.PI * 2);
        ctx.fill();
        if (state.tangent) {
            const derivative = -2 * targetX;
            const xScale = (width - 2 * padding) / 6;
            const adjustedSlope = -derivative * 50 / xScale;
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(targetPx - 150, targetPy + adjustedSlope * -150);
            ctx.lineTo(targetPx + 150, targetPy + adjustedSlope * 150);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        if (state.clickPoint) {
            const maxInfo = document.getElementById('extremumMaxInfo');
            if (maxInfo) maxInfo.style.display = 'block';
            const maxX = document.getElementById('extremumMaxX');
            const maxY = document.getElementById('extremumMaxY');
            const maxDerivative = document.getElementById('extremumMaxDerivative');
            if (maxX) maxX.textContent = targetX.toFixed(2);
            if (maxY) maxY.textContent = targetY.toFixed(2);
            if (maxDerivative) maxDerivative.textContent = (-2 * targetX).toFixed(2);
        }
    }

    function extremumDrawMinimum() {
        const canvas = document.getElementById('extremumMinCanvas');
        if (!canvas) return;
        const ctx = extremumSetupCanvas(canvas);
        const rect = canvas.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        ctx.clearRect(0, 0, width, height);
        const padding = 40;
        const centerX = width / 2;
        const centerY = height / 2;
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(padding, centerY);
        ctx.lineTo(width - padding, centerY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX, padding);
        ctx.lineTo(centerX, height - padding);
        ctx.stroke();
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let px = padding; px < width - padding; px++) {
            const x = ((px - centerX) / (width - 2 * padding)) * 6;
            const y = x * x - 2;
            const py = centerY - y * 50;
            if (px === padding) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();
        const state = extremumGraphStates.min;
        const targetX = state.clickPoint ? state.clickPoint.x : 0;
        const targetY = targetX * targetX - 2;
        const targetPx = centerX + targetX * (width - 2 * padding) / 6;
        const targetPy = centerY - targetY * 50;
        ctx.fillStyle = state.clickPoint ? '#f59e0b' : '#ef4444';
        ctx.beginPath();
        ctx.arc(targetPx, targetPy, 6, 0, Math.PI * 2);
        ctx.fill();
        if (state.tangent) {
            const derivative = 2 * targetX;
            const xScale = (width - 2 * padding) / 6;
            const adjustedSlope = -derivative * 50 / xScale;
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(targetPx - 150, targetPy + adjustedSlope * -150);
            ctx.lineTo(targetPx + 150, targetPy + adjustedSlope * 150);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        if (state.clickPoint) {
            const minInfo = document.getElementById('extremumMinInfo');
            if (minInfo) minInfo.style.display = 'block';
            const minX = document.getElementById('extremumMinX');
            const minY = document.getElementById('extremumMinY');
            const minDerivative = document.getElementById('extremumMinDerivative');
            if (minX) minX.textContent = targetX.toFixed(2);
            if (minY) minY.textContent = targetY.toFixed(2);
            if (minDerivative) minDerivative.textContent = (2 * targetX).toFixed(2);
        }
    }

    function extremumDrawInflection() {
        const canvas = document.getElementById('extremumInflectionCanvas');
        if (!canvas) return;
        const ctx = extremumSetupCanvas(canvas);
        const rect = canvas.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        ctx.clearRect(0, 0, width, height);
        const padding = 40;
        const centerX = width / 2;
        const centerY = height / 2;
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(padding, centerY);
        ctx.lineTo(width - padding, centerY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX, padding);
        ctx.lineTo(centerX, height - padding);
        ctx.stroke();
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for (let px = padding; px < width - padding; px++) {
            const x = ((px - centerX) / (width - 2 * padding)) * 4;
            const y = x * x * x;
            const py = centerY - y * 30;
            if (px === padding) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();
        const state = extremumGraphStates.inflection;
        const targetX = state.clickPoint ? state.clickPoint.x : 0;
        const targetY = targetX * targetX * targetX;
        const targetPx = centerX + targetX * (width - 2 * padding) / 4;
        const targetPy = centerY - targetY * 30;
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(targetPx, targetPy, 6, 0, Math.PI * 2);
        ctx.fill();
        if (state.tangent) {
            const derivative = 3 * targetX * targetX;
            const xScale = (width - 2 * padding) / 4;
            const adjustedSlope = -derivative * 30 / xScale;
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(targetPx - 150, targetPy + adjustedSlope * -150);
            ctx.lineTo(targetPx + 150, targetPy + adjustedSlope * 150);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        if (state.clickPoint) {
            const inflectionInfo = document.getElementById('extremumInflectionInfo');
            if (inflectionInfo) inflectionInfo.style.display = 'block';
            const inflectionX = document.getElementById('extremumInflectionX');
            const inflectionY = document.getElementById('extremumInflectionY');
            const inflectionDerivative = document.getElementById('extremumInflectionDerivative');
            if (inflectionX) inflectionX.textContent = targetX.toFixed(2);
            if (inflectionY) inflectionY.textContent = targetY.toFixed(2);
            if (inflectionDerivative) inflectionDerivative.textContent = (3 * targetX * targetX).toFixed(2);
        }
    }

    function extremumSetupInteraction() {
        ['extremumMaxCanvas', 'extremumMinCanvas', 'extremumInflectionCanvas'].forEach((canvasId, index) => {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const type = ['max', 'min', 'inflection'][index];
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const centerX = rect.width / 2;
                const padding = 40;
                const range = type === 'inflection' ? 4 : 6;
                const fx = ((x - centerX) / (rect.width - 2 * padding)) * range;
                if (Math.abs(fx) <= range/2) {
                    extremumGraphStates[type].clickPoint = { x: fx };
                    extremumDrawCurrentSlide();
                }
            });
        });
    }

    window.extremumToggleAnimation = function(type) {
        extremumGraphStates[type].animation = !extremumGraphStates[type].animation;
        if (extremumGraphStates[type].animation) {
            if (!extremumAnimationProgress[type]) {
                extremumAnimationProgress[type] = type === 'inflection' ? -2 : -3;
            }
            function animate() {
                const range = type === 'inflection' ? 2 : 3;
                extremumAnimationProgress[type] += 0.02;
                if (extremumAnimationProgress[type] > range) {
                    extremumAnimationProgress[type] = -range;
                }
                extremumGraphStates[type].clickPoint = { x: extremumAnimationProgress[type] };
                extremumDrawCurrentSlide();
                if (extremumGraphStates[type].animation) {
                    extremumAnimationFrames[type] = requestAnimationFrame(animate);
                }
            }
            animate();
        } else if (extremumAnimationFrames[type]) {
            cancelAnimationFrame(extremumAnimationFrames[type]);
            extremumAnimationFrames[type] = null;
        }
    };

    window.extremumToggleTangent = function(type) {
        extremumGraphStates[type].tangent = !extremumGraphStates[type].tangent;
        extremumDrawCurrentSlide();
    };

    window.extremumToggleDerivative = function(type) {
        extremumGraphStates[type].derivative = !extremumGraphStates[type].derivative;
        extremumDrawCurrentSlide();
    };

    window.extremumNextSlide = function(evt) {
        if (evt) {
            evt.stopPropagation();
            evt.preventDefault();
        }
        extremumCurrentSlide++;
        extremumShowSlide(extremumCurrentSlide);
    };
    window.extremumPrevSlide = function(evt) {
        if (evt) {
            evt.stopPropagation();
            evt.preventDefault();
        }
        extremumCurrentSlide--;
        extremumShowSlide(extremumCurrentSlide);
    };

    let extremumKeyHandler = null;
    let extremumInitialized = false;
    const extremumSlide = document.querySelector('.extremum-interactive-slide');
    if (extremumSlide) {
        // 确保所有内部slide初始状态正确
        const internalSlides = extremumSlide.querySelectorAll('.extremum-slide');
        internalSlides.forEach((slide, index) => {
            if (index === 0) {
                slide.classList.add('active');
            } else {
                slide.classList.remove('active');
            }
        });
        
        const checkAndInit = () => {
            const isActive = extremumSlide.classList.contains('active');
            if (isActive) {
                if (!extremumInitialized) {
                    extremumInitialized = true;
                    extremumCurrentSlide = 1;
                    extremumShowSlide(1);
                    extremumSetupInteraction();
                    setTimeout(() => extremumDrawCurrentSlide(), 200);
                    // 添加键盘导航（只添加一次）
                    if (!extremumKeyHandler) {
                        extremumKeyHandler = (e) => {
                            if (extremumSlide.classList.contains('active')) {
                                if (e.key === 'ArrowLeft') {
                                    e.stopPropagation();
                                    extremumPrevSlide();
                                } else if (e.key === 'ArrowRight') {
                                    e.stopPropagation();
                                    extremumNextSlide();
                                }
                            }
                        };
                        document.addEventListener('keydown', extremumKeyHandler, true);
                    }
                } else {
                    // 如果已经初始化，确保当前slide正确显示
                    extremumShowSlide(extremumCurrentSlide);
                }
            } else {
                extremumInitialized = false;
            }
        };
        // 初始检查
        setTimeout(checkAndInit, 100);
        // 监听主课件的slide切换
        const observer = new MutationObserver(checkAndInit);
        observer.observe(extremumSlide, { attributes: true, attributeFilter: ['class'] });
        // 监听所有slide的变化，以便在主课件切换时也能检测到
        const allSlides = document.querySelectorAll('.slide');
        allSlides.forEach(slide => {
            const slideObserver = new MutationObserver(() => {
                if (slide.classList.contains('active') && slide === extremumSlide) {
                    checkAndInit();
                }
            });
            slideObserver.observe(slide, { attributes: true, attributeFilter: ['class'] });
        });
    }
})();
</script>
</div>
<!-- 第18页：极值判断方法 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>极值判断方法</h2>
<h3>第一判别法（导数符号法）</h3>
<p>在 $x = x_0$ 处，如果：$f'(x)$ 由正变负 → <span class="highlight">极大值</span>；$f'(x)$ 由负变正 → <span class="highlight">极小值</span>；$f'(x)$ 不变号 → 无极值</p>
<h3>步骤</h3>
<p><strong>① 求驻点：</strong>先求解 $f'(x) = 0$</p>
<p><strong>② 判符号：</strong>观察每个候选点两侧的导数符号</p>
<p><strong>③ 判极值：</strong>只有符号发生变化的点才是真正的极值点</p>
</div><div class="right-visual"><div id="vis-extremum-test"></div></div></div></div>
<!-- 第19页：极值例题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>求函数极值例题</h2>
<h3>例题：求 $f(x) = x^3 - 12x + 5$ 的极值</h3>
<div class="example">
<p><strong>解：</strong></p>
<p><strong>第一步：求导数</strong> $f'(x) = 3x^2 - 12 = 3(x^2 - 4) = 3(x-2)(x+2)$</p>
<p><strong>第二步：求驻点</strong> 令 $f'(x) = 0$，得 $x = -2$ 或 $x = 2$</p>
<p><strong>第三步：判断极值（第一判别法）</strong> 结合导数符号确定极大极小</p>
<table style="margin: 10px 0; border-collapse: collapse; width: 100%;">
<tr><td style="border: 1px solid #ccc; padding: 5px;">$x$</td><td style="border: 1px solid #ccc; padding: 5px;">$(-\infty, -2)$</td><td style="border: 1px solid #ccc; padding: 5px;">$-2$</td><td style="border: 1px solid #ccc; padding: 5px;">$(-2, 2)$</td><td style="border: 1px solid #ccc; padding: 5px;">$2$</td><td style="border: 1px solid #ccc; padding: 5px;">$(2, +\infty)$</td></tr>
<tr><td style="border: 1px solid #ccc; padding: 5px;">$f'(x)$</td><td style="border: 1px solid #ccc; padding: 5px;">$+$</td><td style="border: 1px solid #ccc; padding: 5px;">$0$</td><td style="border: 1px solid #ccc; padding: 5px;">$-$</td><td style="border: 1px solid #ccc; padding: 5px;">$0$</td><td style="border: 1px solid #ccc; padding: 5px;">$+$</td></tr>
<tr><td style="border: 1px solid #ccc; padding: 5px;">$f(x)$</td><td style="border: 1px solid #ccc; padding: 5px;">↗</td><td style="border: 1px solid #ccc; padding: 5px;">极大</td><td style="border: 1px solid #ccc; padding: 5px;">↘</td><td style="border: 1px solid #ccc; padding: 5px;">极小</td><td style="border: 1px solid #ccc; padding: 5px;">↗</td></tr>
</table>
<p><strong>第四步：计算极值</strong>$f(-2) = (-2)^3 - 12(-2) + 5 = -8 + 24 + 5 = 21$（极大值）；$f(2) = 2^3 - 12(2) + 5 = 8 - 24 + 5 = -11$（极小值）<strong>答：</strong>极大值为 $21$（在 $x = -2$ 处），极小值为 $-11$（在 $x = 2$ 处）</p>
</div>
</div><div class="right-visual"><div id="vis-extremum-example"></div></div></div></div>
<!-- 第20页：第五部分过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center;">
<h1 style="font-size: 3rem; color: #008080; margin-bottom: 2rem;">第五部分</h1>
<h2 style="font-size: 2.5rem; color: #003366; margin-bottom: 1rem;">利用导数求最值</h2>
<p style="font-size: 1.5rem; color: #666;">导数在优化问题中的应用</p>
<div style="margin-top: 3rem; padding: 1.5rem; background: #f0f8ff; border-left: 5px solid #008080; border-radius: 8px;">
<p style="font-size: 1.2rem; color: #2c3e50; margin: 0;">本章内容：最值求法、优化问题、实际应用</p>
</div>
</div>
</div><div class="right-visual"><div id="vis-section5"></div></div></div></div>
<!-- 第21页：最值问题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>最大值与最小值</h2>
<p>在闭区间 $[a, b]$ 上，连续函数必有<span class="highlight">最大值</span>和<span class="highlight">最小值</span>。</p>
<h3>最值可能出现在：</h3>
<p>区间内的极值点；区间端点</p>
<h3>求最值步骤</h3>
<p><strong>① 列候选：</strong>求出区间内所有极值点</p>
<p><strong>② 算函数值：</strong>计算极值点与区间端点处的函数值</p>
<p><strong>③ 比较大小：</strong>对比所有结果以确定最大值和最小值</p>
</div><div class="right-visual"><div id="vis-max-min"></div></div></div></div>
<!-- 第22页：最值例题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>求最值例题</h2>
<h3>例题：求 $f(x) = 2x^3 - 3x^2 - 12x + 5$ 在 $[-2, 3]$ 上的最值</h3>
<div class="example">
<p><strong>解：</strong></p>
<p><strong>第一步：求导数</strong> $f'(x) = 6x^2 - 6x - 12 = 6(x^2 - x - 2) = 6(x-2)(x+1)$</p>
<p><strong>第二步：求区间内的驻点</strong> 令 $f'(x) = 0$，得 $x = -1$ 或 $x = 2$（均在 $[-2, 3]$ 内）</p>
<p><strong>第三步：计算关键点的函数值</strong> $f(-2) = 1$，$f(-1) = 12$，$f(2) = -15$，$f(3) = -4$</p>
<p><strong>第四步：比较确定最值</strong> <strong>答：</strong>最大值为 $12$（在 $x = -1$ 处），最小值为 $-15$（在 $x = 2$ 处）</p>
</div>
</div><div class="right-visual"><div id="vis-maxmin-example"></div></div></div></div>
<!-- 第23页：利用导数求最值的方法 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>利用导数求最值</h2>
<h3>闭区间上连续函数的最值</h3>
<div class="theorem">
<p><strong>定理：</strong>闭区间 $[a,b]$ 上的连续函数必有最大值和最小值</p>
</div>
<h3>求最值的完整步骤</h3>
<p><strong>第一步：</strong>求导数 $f'(x)$</p>
<p><strong>第二步：</strong>求驻点，令 $f'(x) = 0$</p>
<p><strong>第三步：</strong>找出不可导点</p>
<p><strong>第四步：</strong>计算关键点和端点的函数值</p>
<p><strong>第五步：</strong>比较所有函数值，确定最值</p>
<h3>例题：求 $f(x) = x^3 - 3x$ 在 $[-2, 2]$ 上的最值</h3>
<div class="example">
<p><strong>解：</strong>$f'(x) = 3x^2 - 3 = 3(x^2 - 1) = 3(x-1)(x+1)$；驻点：$x = \pm 1$；计算函数值：$f(-2) = -2$；$f(-1) = 2$；$f(1) = -2$；$f(2) = 2$<strong>答：</strong>最大值为 $2$（在 $x = -1, 2$ 处），最小值为 $-2$（在 $x = -2, 1$ 处）</p>
</div>
</div><div class="right-visual"><div id="vis-max-value-method"></div></div></div></div>
<!-- 第24页：实际应用-成本最小化 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>应用：成本最小化</h2>
<h3>问题</h3>
<p>某工厂生产成本函数为：$C(x) = x^2 - 10x + 100$，其中 $x$ 是产量（百件），$C$ 是成本（万元）。求：最小成本是多少？对应产量是多少？</p>
<h3>解答</h3>
<p><strong>步骤1：</strong>求导得到 $C'(x) = 2x - 10$</p>
<p><strong>步骤2：</strong>令 $C'(x) = 0$，解得 $x = 5$</p>
<p><strong>步骤3：</strong>计算最小成本：$C(5) = 75$ 万元</p>
</div><div class="right-visual"><div id="vis-cost-optimization"></div></div></div></div>
<!-- 第25页：实际应用-利润最大化 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>应用：利润最大化</h2>
<h3>问题</h3>
<p>某产品的利润函数为：$P(x) = -x^2 + 12x - 20$，其中 $x$ 是销售量（千件），$P$ 是利润（万元）。求：最大利润是多少？</p>
<h3>解答</h3>
<p><strong>步骤1：</strong>求导得到 $P'(x) = -2x + 12$</p>
<p><strong>步骤2：</strong>令 $P'(x) = 0$，得到 $x = 6$</p>
<p><strong>步骤3：</strong>计算最大利润：$P(6) = 16$ 万元</p>
</div><div class="right-visual"><div id="vis-profit-optimization"></div></div></div></div>
<!-- 第26页：实际应用-容器设计 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>应用：容器设计</h2>
<h3>问题</h3>
<p>用一张边长为 20cm 的正方形铁皮，四角各剪去相同的小正方形，做成无盖容器。问：剪去多大的正方形，容器容积最大？</p>
<h3>解答</h3>
<p>设剪去边长为 $x$ cm，则：容积 $V(x) = x(20-2x)^2$；求导后得：$x = \frac{10}{3}$ cm；最大容积：$V(\frac{10}{3}) \approx 592.6$ cm³</p>
</div><div class="right-visual"><div id="vis-container-design"></div></div></div></div>
<!-- 第28页：相关变化率 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>相关变化率</h2>
<p>当几个变量之间存在函数关系时，它们的<span class="highlight">变化率之间也存在关系</span>。</p>
<h3>解题步骤</h3>
<p><strong>第一步：</strong>设定变量，建立函数关系式</p>
<p><strong>第二步：</strong>对时间 $t$ 求导（隐函数求导）</p>
<p><strong>第三步：</strong>代入已知条件和数值</p>
<p><strong>第四步：</strong>求解未知的变化率</p>
<h3>常见题型</h3>
<p><strong>几何问题：</strong>面积、体积、长度的变化；<strong>物理问题：</strong>速度、加速度、距离的变化；<strong>经济问题：</strong>成本、收益、利润的变化</p>
<h3>解题要点</h3>
<p>正确建立变量间的函数关系；注意变化率的正负号含义；代入数值时要对应具体时刻</p>
</div><div class="right-visual"><div id="vis-related-rates"></div></div></div></div>
<!-- 第29页：第四部分过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center;">
<h1 style="font-size: 3rem; color: #008080; margin-bottom: 2rem;">第四部分</h1>
<h2 style="font-size: 2.5rem; color: #003366; margin-bottom: 1rem;">曲线的凹凸性与拐点</h2>
<p style="font-size: 1.5rem; color: #666;">二阶导数的应用</p>
<div style="margin-top: 3rem; padding: 1.5rem; background: #f0f8ff; border-left: 5px solid #008080; border-radius: 8px;">
<p style="font-size: 1.2rem; color: #2c3e50; margin: 0;">本章内容：凹凸性判定、拐点求法、曲线描绘</p>
</div>
</div>
</div><div class="right-visual"><div id="vis-section4"></div></div></div></div>
<!-- 第30页：曲线的凹凸性 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>曲线的凹凸性</h2>
<p>二阶导数 $f''(x)$ 决定曲线的<span class="highlight">弯曲方向</span>：</p>
<div class="formula-rule">
<p>$f''(x) &gt; 0$：曲线<span class="highlight">凹向上 ∪</span>；$f''(x) &lt; 0$：曲线<span class="highlight">凹向下 ∩</span></p>
</div>
<h3>拐点</h3>
<p>凹凸性改变的点叫<span class="highlight">拐点</span>。在拐点处：$f''(x) = 0$ 或不存在</p>
</div><div class="right-visual"><div id="vis-concavity"></div></div></div></div>
<!-- 第30.5页：二阶导数与凹凸性 - 交互式演示 -->
<div class="slide concavity-interactive-slide" style="display: none; width: 100vw; height: 100vh; margin: 0; padding: 0; overflow: hidden; position: relative;">
<!-- 内部子页页码与导航（固定定位，避免影响版式） -->
<div class="concavity-slide-counter" style="position: fixed; top: 30px; right: 30px; font-size: 16px; color: #64748b; background: white; padding: 8px 16px; border-radius: 20px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06); z-index: 1000;"><span id="concavityCurrentSlide">1</span> / 3</div>
<div class="concavity-slide-nav" style="position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); display: flex; gap: 12px; z-index: 1000;">
    <button type="button" class="concavity-nav-btn" onclick="concavityPrevSlide(event)" style="background:#3b82f6;color:#fff;border:none;padding:8px 16px;font-size:14px;border-radius:6px;cursor:pointer;">上一页</button>
    <button type="button" class="concavity-nav-btn" onclick="concavityNextSlide(event)" style="background:#3b82f6;color:#fff;border:none;padding:8px 16px;font-size:14px;border-radius:6px;cursor:pointer;">下一页</button>
</div>
<!-- 嵌入的凹凸性交互式演示内容 -->
<div class="concavity-slide-container" style="width: 100%; height: 100vh; display: flex; position: relative; gap: 0; padding: 0;">
<!-- 幻灯片 1: 凹向上 -->
<div class="concavity-slide active" id="concavity-slide-1">
    <div class="concavity-slide-container-inner">
        <div class="concavity-left-content">
            <h1>二阶导数与凹凸性</h1>
            <h2>1. 凹向上（开口向上）</h2>
            <p>当函数图形像一个<span class="highlight">微笑</span>或<span class="highlight">碗</span>的形状时，我们说它是凹向上的。</p>
            <div class="formula-highlight">
                <p><strong>数学定义：</strong>当 $f''(x) > 0$ 时，函数在该区间凹向上</p>
                <p><strong>几何意义：</strong>切线斜率递增，函数向上弯曲</p>
            </div>
            <h3>直观理解</h3>
            <p>想象你在滑雪：</p>
            <p>• 如果坡道越来越陡（加速下滑），这就是凹向上</p>
            <p>• 切线的斜率在增加：从负变得更正</p>
            <h3>实际例子</h3>
            <p>• 抛物线 $y = x^2$ 在整个定义域上都是凹向上的</p>
            <p>• 指数函数 $y = e^x$ 也是凹向上的</p>
            <p>• 成本函数通常是凹向上的（边际成本递增）</p>
            <div class="key-point">
                <strong>记忆技巧：</strong>凹向上像个笑脸 ⌣，二阶导数为正
            </div>
            <p style="color: #3b82f6; margin-top: 20px;">
                <i class="fas fa-hand-pointer"></i> 
                <strong>互动提示：</strong>拖动滑块观察函数的凹凸性变化
            </p>
        </div>
        <div class="concavity-right-visual">
            <div class="concavity-graph-container">
                <div class="concavity-control-panel">
                    <div class="concavity-slider-container">
                        <label class="concavity-slider-label" for="concavity-xSlider1">选择 x 的值：</label>
                        <input type="range" id="concavity-xSlider1" class="concavity-slider" min="-2" max="2" step="0.01" value="1">
                        <div class="concavity-slider-marks">
                            <span>-2</span>
                            <span>0</span>
                            <span>2</span>
                        </div>
                    </div>
                </div>
                <div class="concavity-data-panel">
                    <div class="concavity-data-card">
                        <div class="concavity-data-label">$x$</div>
                        <div class="concavity-data-value" id="concavity-xValue1">1.00</div>
                    </div>
                    <div class="concavity-data-card">
                        <div class="concavity-data-label">$f'(x)$ (斜率)</div>
                        <div class="concavity-data-value" id="concavity-fpValue1">2.00</div>
                        <div class="concavity-data-description" id="concavity-fpDesc1">递增</div>
                    </div>
                    <div class="concavity-data-card concavity-highlight-positive">
                        <div class="concavity-data-label">$f''(x)$ (凹凸性)</div>
                        <div class="concavity-data-value" id="concavity-fppValue1">2.00</div>
                        <div class="concavity-data-description">凹向上</div>
                    </div>
                </div>
                <canvas id="concavity-canvas1"></canvas>
                <div class="concavity-hint-text">点击图形可选择 x 值</div>
                <div class="concavity-indicator">
                    <div class="concavity-icon concavity-concave-up">⌣</div>
                    <div class="concavity-text">凹向上 (f'' > 0)</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 幻灯片 2: 凹向下 -->
<div class="concavity-slide" id="concavity-slide-2">
    <div class="concavity-slide-container-inner">
        <div class="concavity-left-content">
            <h1>二阶导数与凹凸性</h1>
            <h2>2. 凹向下（开口向下）</h2>
            <p>当函数图形像一个<span class="highlight">倒置的碗</span>或<span class="highlight">山峰</span>的形状时，我们说它是凹向下的。</p>
            <div class="formula-highlight">
                <p><strong>数学定义：</strong>当 $f''(x) < 0$ 时，函数在该区间凹向下</p>
                <p><strong>几何意义：</strong>切线斜率递减，函数向下弯曲</p>
            </div>
            <h3>直观理解</h3>
            <p>继续想象滑雪的例子：</p>
            <p>• 如果坡道越来越平缓（减速下滑），这就是凹向下</p>
            <p>• 切线的斜率在减少：从正变得更负</p>
            <h3>实际例子</h3>
            <p>• 抛物线 $y = -x^2$ 在整个定义域上都是凹向下的</p>
            <p>• 对数函数 $y = \ln x$ 是凹向下的</p>
            <p>• 效用函数通常是凹向下的（边际效用递减）</p>
            <div class="key-point">
                <strong>记忆技巧：</strong>凹向下像个哭脸 ⌢，二阶导数为负
            </div>
            <p style="color: #3b82f6; margin-top: 20px;">
                <i class="fas fa-lightbulb"></i> 
                <strong>经济学应用：</strong>边际效用递减定律就体现在效用函数的凹向下特性
            </p>
        </div>
        <div class="concavity-right-visual">
            <div class="concavity-graph-container">
                <div class="concavity-control-panel">
                    <div class="concavity-slider-container">
                        <label class="concavity-slider-label" for="concavity-xSlider2">选择 x 的值：</label>
                        <input type="range" id="concavity-xSlider2" class="concavity-slider" min="-2" max="2" step="0.01" value="-1">
                        <div class="concavity-slider-marks">
                            <span>-2</span>
                            <span>0</span>
                            <span>2</span>
                        </div>
                    </div>
                </div>
                <div class="concavity-data-panel">
                    <div class="concavity-data-card">
                        <div class="concavity-data-label">$x$</div>
                        <div class="concavity-data-value" id="concavity-xValue2">-1.00</div>
                    </div>
                    <div class="concavity-data-card">
                        <div class="concavity-data-label">$f'(x)$ (斜率)</div>
                        <div class="concavity-data-value" id="concavity-fpValue2">2.00</div>
                        <div class="concavity-data-description" id="concavity-fpDesc2">递增</div>
                    </div>
                    <div class="concavity-data-card concavity-highlight-negative">
                        <div class="concavity-data-label">$f''(x)$ (凹凸性)</div>
                        <div class="concavity-data-value" id="concavity-fppValue2">-2.00</div>
                        <div class="concavity-data-description">凹向下</div>
                    </div>
                </div>
                <canvas id="concavity-canvas2"></canvas>
                <div class="concavity-hint-text">点击图形可选择 x 值</div>
                <div class="concavity-indicator">
                    <div class="concavity-icon concavity-concave-down">⌢</div>
                    <div class="concavity-text">凹向下 (f'' < 0)</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- 幻灯片 3: 拐点 -->
<div class="concavity-slide" id="concavity-slide-3">
    <div class="concavity-slide-container-inner">
        <div class="concavity-left-content">
            <h1>二阶导数与凹凸性</h1>
            <h2>3. 拐点（凹凸性改变）</h2>
            <p><span class="highlight">拐点</span>是函数凹凸性发生改变的点，是凹向上与凹向下的分界点。</p>
            <div class="formula-highlight">
                <p><strong>数学定义：</strong>当 $f''(x) = 0$ 且两侧符号相反时，该点为拐点</p>
                <p><strong>几何意义：</strong>函数从凹向上变为凹向下，或相反</p>
            </div>
            <h3>拐点的特征</h3>
            <p>• 二阶导数为零：$f''(x_0) = 0$</p>
            <p>• 二阶导数在该点两侧变号</p>
            <p>• 函数图形在该点改变弯曲方向</p>
            <h3>典型例子：$f(x) = x^3$</h3>
            <p>• $f'(x) = 3x^2$（一阶导数）</p>
            <p>• $f''(x) = 6x$（二阶导数）</p>
            <p>• 当 $x = 0$ 时，$f''(0) = 0$</p>
            <p>• $x < 0$ 时凹向下，$x > 0$ 时凹向上</p>
            <div class="key-point">
                <strong>注意：</strong>$f''(x) = 0$ 只是拐点的必要条件，还需要检查两侧符号是否相反。
                类似于 $f'(x) = 0$ 对于极值点的关系！
            </div>
            <h3>拐点的应用</h3>
            <p>• 成本分析：找到规模经济的转折点</p>
            <p>• 增长模型：确定增长速度的变化点</p>
            <p>• 工程设计：优化曲线的平滑过渡</p>
        </div>
        <div class="concavity-right-visual">
            <div class="concavity-graph-container">
                <div class="concavity-control-panel">
                    <div class="concavity-slider-container">
                        <label class="concavity-slider-label" for="concavity-xSlider3">选择 x 的值：</label>
                        <input type="range" id="concavity-xSlider3" class="concavity-slider" min="-2" max="2" step="0.01" value="0.5">
                        <div class="concavity-slider-marks">
                            <span>-2</span>
                            <span>0</span>
                            <span>2</span>
                        </div>
                    </div>
                </div>
                <div class="concavity-data-panel">
                    <div class="concavity-data-card">
                        <div class="concavity-data-label">$x$</div>
                        <div class="concavity-data-value" id="concavity-xValue3">0.50</div>
                    </div>
                    <div class="concavity-data-card">
                        <div class="concavity-data-label">$f'(x)$ (斜率)</div>
                        <div class="concavity-data-value" id="concavity-fpValue3">0.75</div>
                        <div class="concavity-data-description" id="concavity-fpDesc3">递增</div>
                    </div>
                    <div class="concavity-data-card" id="concavity-fppCard3">
                        <div class="concavity-data-label">$f''(x)$ (凹凸性)</div>
                        <div class="concavity-data-value" id="concavity-fppValue3">3.00</div>
                        <div class="concavity-data-description" id="concavity-fppDesc3">凹向上</div>
                    </div>
                </div>
                <canvas id="concavity-canvas3"></canvas>
                <div class="concavity-hint-text">点击图形可选择 x 值</div>
                <div class="concavity-indicator">
                    <div class="concavity-icon" id="concavity-concavityIcon3">⌣</div>
                    <div class="concavity-text" id="concavity-concavityText3">凹向上 (f'' > 0)</div>
                </div>
            </div>
        </div>
    </div>
        </div>
    </div>
</div>
</div>
</div>
<!-- 第30.6页：f'(x)与f''(x)的关系 - 交互式演示 -->
<div class="slide derivatives-relation-slide" style="display: none; width: 100vw; height: 100vh; margin: 0; padding: 0; overflow: hidden; position: relative;">
<!-- 嵌入的导数关系可视化内容 -->
<style>
/* 导数关系可视化专用样式 */
.derivatives-relation-slide {
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #f9fafb;
}
.derivatives-relation-slide * {
    box-sizing: border-box;
}
.derivatives-relation-slide .container-wrapper {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
}
.derivatives-relation-slide .main-container {
    width: 100%;
    max-width: 1400px;
    height: 100%;
    max-height: 900px;
    background: white;
    border-radius: 16px;
    box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
    overflow: hidden;
}
.derivatives-relation-slide .content-area {
    padding: 40px;
    height: 100%;
    display: flex;
    flex-direction: column;
}
.derivatives-relation-slide h1 {
    font-size: 32px;
    font-weight: bold;
    color: #1f2937;
    margin-bottom: 10px;
}
.derivatives-relation-slide .subtitle {
    font-size: 18px;
    color: #6b7280;
    margin-bottom: 30px;
}
.derivatives-relation-slide .main-layout {
    display: flex;
    gap: 40px;
    flex: 1;
    min-height: 0;
}
.derivatives-relation-slide .charts-section {
    flex: 2;
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.derivatives-relation-slide .control-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 20px;
}
.derivatives-relation-slide .chart-container {
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    padding: 20px;
    position: relative;
}
.derivatives-relation-slide .chart-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
}
.derivatives-relation-slide .chart-title {
    font-size: 20px;
    font-weight: bold;
}
.derivatives-relation-slide .value-badge {
    font-size: 14px;
    padding: 4px 12px;
    border-radius: 6px;
    font-family: monospace;
    font-weight: 500;
}
.derivatives-relation-slide .blue-badge {
    background: #dbeafe;
    color: #1e40af;
}
.derivatives-relation-slide .green-badge {
    background: #d1fae5;
    color: #064e3b;
}
.derivatives-relation-slide .purple-badge {
    background: #ede9fe;
    color: #5b21b6;
}
.derivatives-relation-slide .canvas-wrapper {
    background: white;
    border-radius: 8px;
    overflow: hidden;
    position: relative;
    width: 100%;
    height: 220px;
}
.derivatives-relation-slide .canvas-wrapper.tall {
    height: 280px;
}
.derivatives-relation-slide canvas {
    width: 100%;
    height: 100%;
    display: block;
}
.derivatives-relation-slide .slider-container {
    margin-bottom: 30px;
}
.derivatives-relation-slide .slider-label {
    font-size: 14px;
    color: #374151;
    font-weight: 500;
    margin-bottom: 10px;
}
.derivatives-relation-slide .x-value {
    color: #2563eb;
    font-weight: bold;
}
.derivatives-relation-slide input[type="range"] {
    width: 100%;
    height: 8px;
    background: #e5e7eb;
    border-radius: 4px;
    outline: none;
    appearance: none;
    cursor: pointer;
}
.derivatives-relation-slide input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 20px;
    height: 20px;
    background: #2563eb;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}
.derivatives-relation-slide .slider-scale {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: #9ca3af;
    margin-top: 5px;
}
.derivatives-relation-slide .info-card {
    background: white;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}
.derivatives-relation-slide .info-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}
.derivatives-relation-slide .info-title {
    font-size: 18px;
    font-weight: 600;
    color: #374151;
}
.derivatives-relation-slide .info-icon {
    font-size: 28px;
}
.derivatives-relation-slide .info-text {
    font-size: 16px;
    font-weight: 500;
    color: #4b5563;
}
.derivatives-relation-slide .info-note {
    font-size: 14px;
    color: #6b7280;
    margin-top: 10px;
    line-height: 1.5;
}
.derivatives-relation-slide .highlight-card {
    background: #eff6ff;
    border: 2px solid #3b82f6;
    box-shadow: 0 4px 6px rgba(59, 130, 246, 0.15);
}
.derivatives-relation-slide .highlight-card .info-title {
    color: #1d4ed8;
}
.derivatives-relation-slide .highlight-card .info-text {
    font-size: 24px;
    color: #2563eb;
}
.derivatives-relation-slide .concavity-icon {
    font-size: 48px;
    color: #2563eb;
    font-family: monospace;
}
.derivatives-relation-slide .explanation-box {
    background: #f9fafb;
    border-radius: 12px;
    padding: 20px;
    font-size: 14px;
    color: #374151;
    line-height: 1.8;
    margin-top: auto;
}
.derivatives-relation-slide .explanation-box p {
    margin-bottom: 8px;
}
.derivatives-relation-slide .explanation-box strong {
    color: #1f2937;
}
</style>

<div class="container-wrapper">
    <div class="main-container">
        <div class="content-area">
            <h1>f'(x) 与 f''(x) 的关系</h1>
            <p class="subtitle">观察 f''(x) (紫色) 如何决定 f'(x) (绿色) 的趋势，以及 f'(x) 如何塑造 f(x) (蓝色) 的形状</p>
            
            <div class="main-layout">
                <!-- 左侧：图表 -->
                <div class="charts-section">
                    <!-- 图表 1: f(x) -->
                    <div class="chart-container">
                        <div class="chart-header">
                            <span class="chart-title blue-badge">主函数: f(x) = x³</span>
                            <span class="value-badge blue-badge">f(x) = <span id="derFValueText">0.00</span></span>
                        </div>
                        <div class="canvas-wrapper tall">
                            <canvas id="derFCanvas"></canvas>
                        </div>
                    </div>
                    
                    <!-- 图表 2: f'(x) 和 f''(x) -->
                    <div class="chart-container">
                        <div class="chart-header">
                            <span class="chart-title">导数图像</span>
                            <span class="value-badge green-badge">f'(x) = <span id="derFpValueText">0.00</span></span>
                            <span class="value-badge purple-badge">f''(x) = <span id="derFppValueText">0.00</span></span>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="derDCanvas"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- 右侧：控制面板和数据 -->
                <div class="control-section">
                    <!-- 滑块 -->
                    <div class="slider-container">
                        <div class="slider-label">选择 x 的值 (当前: <span id="derXValueText" class="x-value">0.00</span>)</div>
                        <input type="range" id="derXSlider" min="-2" max="2" step="0.01" value="0.28">
                        <div class="slider-scale">
                            <span>-2.0</span>
                            <span>0.0</span>
                            <span>2.0</span>
                        </div>
                    </div>
                    
                    <!-- f'(x) 卡片 -->
                    <div class="info-card">
                        <div class="info-header">
                            <span class="info-title">f'(x) (斜率)</span>
                            <span id="derSlopeIcon" class="info-icon">➡️</span>
                        </div>
                        <div id="derSlopeText" class="info-text">水平 (f' = 0)</div>
                        <div class="info-note green-badge" style="margin-top: 10px; text-align: center;">
                            查看绿色曲线在导数图上的位置
                        </div>
                    </div>
                    
                    <!-- f''(x) 卡片 -->
                    <div id="derConcavityCard" class="info-card highlight-card">
                        <div class="info-header">
                            <span class="info-title">f''(x) (凹凸性)</span>
                            <span id="derConcaveIcon" class="concavity-icon">⌣</span>
                        </div>
                        <div id="derConcaveText" class="info-text">凹向上 (f'' > 0)</div>
                        <div class="info-note purple-badge" style="margin-top: 10px; text-align: center; background: #ede9fe; color: #5b21b6;">
                            查看紫色曲线是否在x轴上方
                        </div>
                    </div>
                    
                    <!-- 解释 -->
                    <div id="derExplanation" class="explanation-box">
                        <!-- 动态解释会在这里更新 -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
(function() {
    // --- 导数关系可视化脚本 ---
    const derXSlider = document.getElementById('derXSlider');
    const derFCanvas = document.getElementById('derFCanvas');
    const derFCtx = derFCanvas.getContext('2d');
    const derDCanvas = document.getElementById('derDCanvas');
    const derDCtx = derDCanvas.getContext('2d');
    
    const derXValueText = document.getElementById('derXValueText');
    const derFValueText = document.getElementById('derFValueText');
    const derFpValueText = document.getElementById('derFpValueText');
    const derFppValueText = document.getElementById('derFppValueText');
    const derExplanation = document.getElementById('derExplanation');
    const derSlopeIcon = document.getElementById('derSlopeIcon');
    const derSlopeText = document.getElementById('derSlopeText');
    const derConcavityCard = document.getElementById('derConcavityCard');
    const derConcaveIcon = document.getElementById('derConcaveIcon');
    const derConcaveText = document.getElementById('derConcaveText');
    
    // 函数定义
    const f = (x) => x * x * x;
    const fp = (x) => 3 * x * x;
    const fpp = (x) => 6 * x;
    
    // 图表参数
    let xMin = -2, xMax = 2;
    let xRange = xMax - xMin;
    let f_yMin = -8, f_yMax = 8;
    let f_yRange = f_yMax - f_yMin;
    let d_yMin = -12, d_yMax = 12;
    let d_yRange = d_yMax - d_yMin;
    
    // 坐标映射
    function mapX(x, canvas) {
        return canvas.width * (x - xMin) / xRange;
    }
    
    function mapY(y, yMin, yRange, canvas) {
        return canvas.height * (1 - (y - yMin) / yRange);
    }
    
    function unmapX(px, canvas) {
        return (px / canvas.width) * xRange + xMin;
    }
    
    // 绘制坐标轴
    function drawAxes(ctx, yMin, yMax, yRange) {
        const canvas = ctx.canvas;
        ctx.strokeStyle = '#9ca3af';
        ctx.fillStyle = '#6b7280';
        ctx.lineWidth = 1;
        ctx.font = '12px sans-serif';
        
        // Y轴
        const yAxisX = mapX(0, canvas);
        ctx.beginPath();
        ctx.moveTo(yAxisX, 0);
        ctx.lineTo(yAxisX, canvas.height);
        ctx.stroke();
        
        // X轴
        const xAxisY = mapY(0, yMin, yRange, canvas);
        ctx.beginPath();
        ctx.moveTo(0, xAxisY);
        ctx.lineTo(canvas.width, xAxisY);
        ctx.stroke();
        
        // 标签
        ctx.fillText('0', yAxisX + 5, xAxisY + 12);
    }
    
    // 绘制函数曲线
    function drawCurve(ctx, func, yMin, yRange, color, lineWidth) {
        const canvas = ctx.canvas;
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        
        for (let px = 0; px <= canvas.width; px++) {
            const x = unmapX(px, canvas);
            const y = func(x);
            const py = mapY(y, yMin, yRange, canvas);
            if (px === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();
    }
    
    // 绘制f(x)图表
    function drawFCanvas(x_val) {
        const canvas = derFCtx.canvas;
        derFCtx.clearRect(0, 0, canvas.width, canvas.height);
        drawAxes(derFCtx, f_yMin, f_yMax, f_yRange);
        
        // 绘制f(x)
        drawCurve(derFCtx, f, f_yMin, f_yRange, '#3b82f6', 3);
        
        // 绘制切线
        const y = f(x_val);
        const m = fp(x_val);
        const x1 = x_val - 1, y1 = m * (x1 - x_val) + y;
        const x2 = x_val + 1, y2 = m * (x2 - x_val) + y;
        
        derFCtx.strokeStyle = '#f97316';
        derFCtx.lineWidth = 2;
        derFCtx.beginPath();
        derFCtx.moveTo(mapX(x1, canvas), mapY(y1, f_yMin, f_yRange, canvas));
        derFCtx.lineTo(mapX(x2, canvas), mapY(y2, f_yMin, f_yRange, canvas));
        derFCtx.stroke();
        
        // 绘制scrubber
        drawScrubber(derFCtx, x_val, f(x_val), f_yMin, f_yRange, '#0284c7');
    }
    
    // 绘制导数图表
    function drawDCanvas(x_val) {
        const canvas = derDCtx.canvas;
        derDCtx.clearRect(0, 0, canvas.width, canvas.height);
        drawAxes(derDCtx, d_yMin, d_yMax, d_yRange);
        
        // 绘制f'(x)
        drawCurve(derDCtx, fp, d_yMin, d_yRange, '#16a34a', 3);
        
        // 绘制f''(x)
        drawCurve(derDCtx, fpp, d_yMin, d_yRange, '#7e22ce', 3);
        
        // 绘制scrubbers
        drawScrubber(derDCtx, x_val, fp(x_val), d_yMin, d_yRange, '#15803d');
        drawScrubber(derDCtx, x_val, fpp(x_val), d_yMin, d_yRange, '#6b21a8');
    }
    
    // 绘制scrubber
    function drawScrubber(ctx, x, y, yMin, yRange, color) {
        const canvas = ctx.canvas;
        const px = mapX(x, canvas);
        const py = mapY(y, yMin, yRange, canvas);
        
        // 垂直虚线
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(px, 0);
        ctx.lineTo(px, canvas.height);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // 点
        ctx.fillStyle = color;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
    }
    
    // 主更新函数
    function updateDerivatives(x_str) {
        const x = parseFloat(x_str);
        const val_f = f(x);
        const val_fp = fp(x);
        const val_fpp = fpp(x);
        
        // 更新文本
        derXValueText.textContent = x.toFixed(2);
        derFValueText.textContent = val_f.toFixed(2);
        derFpValueText.textContent = val_fp.toFixed(2);
        derFppValueText.textContent = val_fpp.toFixed(2);
        
        // 更新f'(x)卡片
        if (val_fp > 0.01) {
            derSlopeIcon.textContent = '📈';
            derSlopeText.textContent = "递增 (f' > 0)";
        } else if (val_fp < -0.01) {
            derSlopeIcon.textContent = '📉';
            derSlopeText.textContent = "递减 (f' < 0)";
        } else {
            derSlopeIcon.textContent = '➡️';
            derSlopeText.textContent = "水平 (f' = 0)";
        }
        
        // 更新f''(x)卡片
        derConcavityCard.className = 'info-card highlight-card';
        let explainerText = "";
        
        if (val_fpp > 0.01) {
            derConcaveIcon.textContent = '⌣';
            derConcaveText.textContent = "凹向上 (f'' > 0)";
            explainerText = `
                <p><strong>f''(x) 为正 (${val_fpp.toFixed(2)})</strong></p>
                <p style="color: #7e22ce;">🟣 f''(x) 曲线在x轴上方</p>
                <p>这迫使 f'(x) (斜率) <strong>增加</strong></p>
                <p style="color: #16a34a;">🟢 f'(x) 曲线正在上升</p>
                <p>这塑造了 f(x) <strong>向上弯曲 ⌣</strong> 的形状</p>
            `;
        } else if (val_fpp < -0.01) {
            derConcaveIcon.textContent = '⌢';
            derConcaveText.textContent = "凹向下 (f'' < 0)";
            derConcavityCard.style.borderColor = '#f97316';
            derConcavityCard.style.backgroundColor = '#fff7ed';
            explainerText = `
                <p><strong>f''(x) 为负 (${val_fpp.toFixed(2)})</strong></p>
                <p style="color: #7e22ce;">🟣 f''(x) 曲线在x轴下方</p>
                <p>这迫使 f'(x) (斜率) <strong>减少</strong></p>
                <p style="color: #16a34a;">🟢 f'(x) 曲线正在下降</p>
                <p>这塑造了 f(x) <strong>向下弯曲 ⌢</strong> 的形状</p>
            `;
        } else {
            derConcaveIcon.textContent = '—';
            derConcaveText.textContent = "拐点 (f'' = 0)";
            derConcavityCard.style.borderColor = '#6b7280';
            derConcavityCard.style.backgroundColor = '#f9fafb';
            explainerText = `
                <p><strong>f''(x) 为零 (0.00)</strong></p>
                <p style="color: #7e22ce;">🟣 f''(x) 曲线正在穿越x轴</p>
                <p>f'(x) (斜率) 停止了减少，即将开始增加</p>
                <p style="color: #16a34a;">🟢 f'(x) 曲线达到了它的最低点</p>
                <p>f(x) 正在<strong>改变弯曲方向</strong></p>
            `;
        }
        
        derExplanation.innerHTML = explainerText;
        
        // 重绘图表
        drawFCanvas(x);
        drawDCanvas(x);
    }
    
    // 设置画布
    function setupDerivativesCanvases() {
        const dpr = window.devicePixelRatio || 1;
        
        [derFCanvas, derDCanvas].forEach(canvas => {
            const parent = canvas.parentElement;
            canvas.width = parent.clientWidth * dpr;
            canvas.height = parent.clientHeight * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
        });
        
        updateDerivatives(derXSlider.value);
    }
    
    // 事件监听
    derXSlider.addEventListener('input', (e) => updateDerivatives(e.target.value));
    
    // 初始化（当导数关系幻灯片显示时）
    let derivativesInitialized = false;
    const derivativesSlide = document.querySelector('.derivatives-relation-slide');
    
    if (derivativesSlide) {
        const checkAndInit = () => {
            const isActive = derivativesSlide.classList.contains('active');
            if (isActive && !derivativesInitialized) {
                derivativesInitialized = true;
                setTimeout(() => {
                    setupDerivativesCanvases();
                    
                    // 响应式处理
                    const resizeObserver = new ResizeObserver(() => {
                        setupDerivativesCanvases();
                    });
                    resizeObserver.observe(derFCanvas.parentElement);
                    resizeObserver.observe(derDCanvas.parentElement);
                }, 100);
            } else if (!isActive) {
                derivativesInitialized = false;
            }
        };
        
        // 监听slide变化
        setTimeout(checkAndInit, 100);
        const observer = new MutationObserver(checkAndInit);
        observer.observe(derivativesSlide, { attributes: true, attributeFilter: ['class'] });
        
        // 监听所有slide变化
        const allSlides = document.querySelectorAll('.slide');
        allSlides.forEach(slide => {
            const slideObserver = new MutationObserver(() => {
                if (slide.classList.contains('active') && slide === derivativesSlide) {
                    checkAndInit();
                }
            });
            slideObserver.observe(slide, { attributes: true, attributeFilter: ['class'] });
        });
    }
})();
</script>
</div>
<!-- 第31页：凹凸性与拐点例题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>求凹凸区间与拐点</h2>
<h3>解题步骤</h3>
<p><strong>第一步：</strong>求二阶导数 $f''(x)$；<strong>第二步：</strong>令 $f''(x) = 0$，求可能的拐点；<strong>第三步：</strong>判断 $f''(x)$ 的符号变化；<strong>第四步：</strong>确定凹凸区间和拐点</p>
<h3>例题：求 $f(x) = x^4 - 6x^2 + 3$ 的凹凸区间和拐点</h3>
<div class="example">
<p><strong>解：</strong>$f'(x) = 4x^3 - 12x$；$f''(x) = 12x^2 - 12 = 12(x^2 - 1) = 12(x-1)(x+1)$；令 $f''(x) = 0$，得 $x = \pm 1$；列表分析：</p>
<table style="margin: 10px 0; border-collapse: collapse;">
<tr><td style="border: 1px solid #ccc; padding: 5px;">$x$</td><td style="border: 1px solid #ccc; padding: 5px;">$(-\infty, -1)$</td><td style="border: 1px solid #ccc; padding: 5px;">$(-1, 1)$</td><td style="border: 1px solid #ccc; padding: 5px;">$(1, +\infty)$</td></tr>
<tr><td style="border: 1px solid #ccc; padding: 5px;">$f''(x)$</td><td style="border: 1px solid #ccc; padding: 5px;">$+$</td><td style="border: 1px solid #ccc; padding: 5px;">$-$</td><td style="border: 1px solid #ccc; padding: 5px;">$+$</td></tr>
<tr><td style="border: 1px solid #ccc; padding: 5px;">凹凸性</td><td style="border: 1px solid #ccc; padding: 5px;">凹向上 ∪</td><td style="border: 1px solid #ccc; padding: 5px;">凹向下 ∩</td><td style="border: 1px solid #ccc; padding: 5px;">凹向上 ∪</td></tr>
</table>
<p><strong>答：</strong>凹向上区间：$(-\infty, -1)$ 和 $(1, +\infty)$</p>
<p>凹向下区间：$(-1, 1)$</p>
<p>拐点：$(-1, f(-1)) = (-1, -2)$ 和 $(1, f(1)) = (1, -2)$</p>
</div>
</div><div class="right-visual"><div id="vis-concavity-example"></div></div></div></div>
<!-- 第32页：边际分析 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>边际分析</h2>
<p>经济学中的<span class="highlight">边际</span>概念就是导数的经济学应用。</p>
<h3>主要概念</h3>
<ul>
<li><strong>边际成本</strong>：$MC = C'(x)$ - 增产一单位的成本</li>
<li><strong>边际收益</strong>：$MR = R'(x)$ - 增销一单位的收益</li>
<li><strong>边际利润</strong>：$MP = P'(x) = MR - MC$</li>
</ul>
<h3>边际分析解题步骤</h3>
<div class="example">
<p><strong>第一步：</strong>写出成本函数 $C(x)$ 和收益函数 $R(x)$</p>
<p><strong>第二步：</strong>求边际成本 $MC = C'(x)$ 和边际收益 $MR = R'(x)$</p>
<p><strong>第三步：</strong>令 $MR = MC$，求最优产量</p>
<p><strong>第四步：</strong>计算最大利润 $P = R - C$</p>
</div>
<h3>最优决策原则</h3>
<div class="formula-highlight">
<p>利润最大化条件：$MR = MC$</p>
<p>即边际收益等于边际成本时，利润达到最大</p>
</div>
</div><div class="right-visual"><div id="vis-marginal-analysis"></div></div></div></div>
<!-- 第33页：需求弹性 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>需求弹性</h2>
<p>衡量需求量对价格变化的<span class="highlight">敏感程度</span>。</p>
<div class="formula-highlight">
<p><strong>点弹性公式：</strong></p>
$E_d = -\frac{dQ}{dP} \cdot \frac{P}{Q}$
<p>其中 $Q$ 是需求量，$P$ 是价格</p>
</div>
<h3>弹性计算步骤</h3>
<div class="example">
<p><strong>第一步：</strong>写出需求函数 $Q = f(P)$</p>
<p><strong>第二步：</strong>求导数 $\frac{dQ}{dP}$</p>
<p><strong>第三步：</strong>代入具体的 $P$ 值，计算对应的 $Q$ 值</p>
<p><strong>第四步：</strong>代入弹性公式计算 $E_d$</p>
</div>
<h3>弹性分类</h3>
<ul>
<li>$|E_d| > 1$：<span class="highlight">富有弹性</span> - 需求对价格敏感</li>
<li>$|E_d| = 1$：<span class="highlight">单位弹性</span> - 收益最大化点</li>
<li>$|E_d| < 1$：<span class="highlight">缺乏弹性</span> - 需求对价格不敏感</li>
</ul>
</div><div class="right-visual"><div id="vis-elasticity"></div></div></div></div>
<!-- 第34页：函数图像描绘 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>函数图像描绘步骤</h2>
<ol>
<li><strong>定义域</strong>：确定函数存在的范围</li>
<li><strong>关键点</strong>：
                    <ul>
<li>与坐标轴的交点</li>
<li>$f'(x) = 0$ 的点（可能极值）</li>
<li>$f''(x) = 0$ 的点（可能拐点）</li>
</ul>
</li>
<li><strong>单调性</strong>：根据 $f'(x)$ 的符号</li>
<li><strong>凹凸性</strong>：根据 $f''(x)$ 的符号</li>
<li><strong>渐近线</strong>：水平、垂直渐近线</li>
</ol>
</div><div class="right-visual"><div id="vis-curve-sketching"></div></div></div></div>
<!-- 第35页：综合练习 - 洛必达法则 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>练习1：洛必达法则</h2>
<h3>题目</h3>
<p>求极限：$\lim\limits_{x \to 0} \frac{e^x - 1 - x}{x^2}$</p>
<h3>解题步骤</h3>
<div class="example">
<p><strong>第1步：验证未定式类型</strong>当 $x \to 0$ 时：分子：$e^0 - 1 - 0 = 1 - 1 - 0 = 0$；分母：$0^2 = 0$。确认为 $\frac{0}{0}$ 型，可以使用洛必达法则。</p>
<p><strong>第2步：第一次应用洛必达法则</strong>对分子分母分别求导：$\lim_{x \to 0} \frac{e^x - 1 - x}{x^2} = \lim_{x \to 0} \frac{(e^x - 1 - x)'}{(x^2)'} = \lim_{x \to 0} \frac{e^x - 1}{2x}$</p>
<p><strong>第3步：再次验证</strong>当 $x \to 0$ 时：$e^0 - 1 = 0$，$2 \cdot 0 = 0$。仍为 $\frac{0}{0}$ 型，继续应用洛必达法则。</p>
<p><strong>第4步：第二次应用洛必达法则</strong>$\lim_{x \to 0} \frac{e^x - 1}{2x} = \lim_{x \to 0} \frac{(e^x - 1)'}{(2x)'} = \lim_{x \to 0} \frac{e^x}{2} = \frac{e^0}{2} = \frac{1}{2}$</p>
</div>
<div class="formula-highlight">
<p><strong>答案：</strong>$\lim\limits_{x \to 0} \frac{e^x - 1 - x}{x^2} = \frac{1}{2}$</p>
</div>
</div><div class="right-visual"><div id="vis-practice-1"></div></div></div></div>
<!-- 第36页：综合练习 - 优化问题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>练习2：优化问题</h2>
<h3>题目</h3>
<p>某工厂要制造一个容积为 $V$ 的圆柱形容器，使表面积最小。求最优的高与底面半径之比。</p>
<h3>解题步骤</h3>
<div class="example">
<p><strong>第1步：</strong>建立数学模型</p>
<p>设圆柱体底面半径为 $r$，高为 $h$</p>
<ul>
<li>约束条件：$V = \pi r^2 h$（容积固定）</li>
<li>目标函数：$S = 2\pi r^2 + 2\pi rh$（表面积最小）</li>
</ul>
</div>
<div class="example">
<p><strong>第2步：</strong>消除变量</p>
<p>由约束条件得：$h = \frac{V}{\pi r^2}$</p>
<p>代入目标函数：</p>
$S(r) = 2\pi r^2 + 2\pi r \cdot \frac{V}{\pi r^2} = 2\pi r^2 + \frac{2V}{r}$
</div>
<div class="example">
<p><strong>第3步：</strong>求导并令其为零</p>
$S'(r) = 4\pi r - \frac{2V}{r^2} = 0$
<p>解得：$4\pi r = \frac{2V}{r^2}$</p>
<p>即：$4\pi r^3 = 2V$，所以 $r^3 = \frac{V}{2\pi}$</p>
</div>
<div class="example">
<p><strong>第4步：</strong>求最优比值</p>
<p>由 $h = \frac{V}{\pi r^2}$ 和 $r^3 = \frac{V}{2\pi}$：</p>
$\frac{h}{r} = \frac{V}{\pi r^3} = \frac{V}{\pi \cdot \frac{V}{2\pi}} = \frac{V \cdot 2\pi}{\pi V} = 2$
</div>
<div class="formula-highlight">
<p><strong>答案：</strong>最优的高与底面半径之比为 $h : r = 2 : 1$</p>
</div>
</div><div class="right-visual"><div id="vis-practice-2"></div></div></div></div>
<!-- 第37页：综合练习 - 边际分析 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>练习3：边际分析</h2>
<h3>题目</h3>
<p>已知成本函数 $C(x) = 50 + 3x + 0.02x^2$，价格函数 $p = 15 - 0.01x$。</p>
<p>求：(1) 边际成本函数；(2) 边际收益函数；(3) 最优产量。</p>
<h3>解题步骤</h3>
<div class="example">
<p><strong>(1) 边际成本函数</strong></p>
<p>边际成本 $MC = C'(x)$：</p>
$MC(x) = \frac{d}{dx}(50 + 3x + 0.02x^2) = 3 + 0.04x$
</div>
<div class="example">
<p><strong>(2) 边际收益函数</strong></p>
<p>收益函数：$R(x) = p \cdot x = (15 - 0.01x) \cdot x = 15x - 0.01x^2$</p>
<p>边际收益 $MR = R'(x)$：</p>
$MR(x) = \frac{d}{dx}(15x - 0.01x^2) = 15 - 0.02x$
</div>
<div class="example">
<p><strong>(3) 最优产量</strong></p>
<p>利润最大化条件：$MR = MC$</p>
$15 - 0.02x = 3 + 0.04x$
$12 = 0.06x$
$x = 200$
</div>
<div class="example">
<p><strong>验证：</strong>二阶条件</p>
<p>利润函数：$P(x) = R(x) - C(x) = 15x - 0.01x^2 - 50 - 3x - 0.02x^2$</p>
<p>$P(x) = 12x - 0.03x^2 - 50$</p>
<p>$P''(x) = -0.06 < 0$，确认为最大值点。</p>
</div>
<div class="formula-highlight">
<p><strong>答案：</strong>(1) $MC(x) = 3 + 0.04x$；(2) $MR(x) = 15 - 0.02x$；(3) 最优产量 $x = 200$ 单位</p>
</div>
</div><div class="right-visual"><div id="vis-practice-3"></div></div></div></div>
<!-- 第38页：综合练习 - 相关变化率 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>练习4：相关变化率</h2>
<h3>题目</h3>
<p>梯子长 5m，靠在墙上。梯子底端以 1m/s 的速度离开墙根，当底端距墙根 3m 时，梯子顶端下滑的速度是多少？</p>
<h3>解题步骤</h3>
<div class="example">
<p><strong>第1步：</strong>建立坐标系和变量</p>
<p>设梯子底端距墙根距离为 $x$，顶端距地面高度为 $y$</p>
<ul>
<li>梯子长度：$L = 5$ m（常数）</li>
<li>已知：$\frac{dx}{dt} = 1$ m/s</li>
<li>求：当 $x = 3$ m 时的 $\frac{dy}{dt}$</li>
</ul>
</div>
<div class="example">
<p><strong>第2步：</strong>建立函数关系</p>
<p>根据勾股定理：</p>
$x^2 + y^2 = L^2 = 25$
</div>
<div class="example">
<p><strong>第3步：</strong>对时间求导</p>
<p>对等式两边关于 $t$ 求导：</p>
$\frac{d}{dt}(x^2 + y^2) = \frac{d}{dt}(25)$
$2x\frac{dx}{dt} + 2y\frac{dy}{dt} = 0$
</div>
<div class="example">
<p><strong>第4步：</strong>求解特定时刻的值</p>
<p>当 $x = 3$ 时，由 $x^2 + y^2 = 25$ 得：</p>
$y = \sqrt{25 - 9} = \sqrt{16} = 4 \text{ m}$
<p>代入导数方程：</p>
$2 \times 3 \times 1 + 2 \times 4 \times \frac{dy}{dt} = 0$
$6 + 8\frac{dy}{dt} = 0$
$\frac{dy}{dt} = -\frac{6}{8} = -\frac{3}{4} \text{ m/s}$
</div>
<div class="formula-highlight">
<p><strong>答案：</strong>梯子顶端下滑速度为 $\frac{3}{4}$ m/s（负号表示向下）</p>
</div>
</div><div class="right-visual"><div id="vis-practice-4"></div></div></div></div>
<!-- 第39页：总结 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2 style="font-size: 3rem">总结</h2>
<div style="text-align: left; max-width: 800px; margin: 0 auto">
<h3>导数应用要点</h3>
<ul style="font-size: 1.3rem; line-height: 2">
<li>导数 = 变化率 = 切线斜率</li>
<li>$f'(x) &gt; 0$ → 递增；$f'(x) &lt; 0$ → 递减</li>
<li>极值点：$f'(x) = 0$ 且符号改变</li>
<li>最值 = 比较极值和端点值</li>
<li>洛必达法则：求未定式极限的利器</li>
<li>边际分析：经济决策的数学基础</li>
<li>实际问题：建模 → 求导 → 求极值</li>
</ul>
<div style="margin-top: 30px; padding: 20px">
<p style="font-size: 1.2rem">记住：导数是理解函数变化的<span class="highlight">关键工具</span>！</p>
</div>
</div>
</div><div class="right-visual"><div id="vis-summary"></div></div></div></div>
<!-- 翻页按钮 -->
<!-- 全局动画控制面板 -->
    <div class="nav-controls" role="navigation" aria-label="幻灯片导航">
        <button class="nav-btn" onclick="previousSlide()" aria-label="上一页" title="上一页 (<i class="fa-solid fa-arrow-left"></i>)"><i class="fa-solid fa-arrow-left"></i> 上一页</button>
        <div class="slide-number" role="status" aria-live="polite">
            <input type="number" id="slideNumberInput" min="1" max="38" value="1"
                   onchange="jumpToSlide(this.value)"
                   aria-label="当前页码">/<span id="slideNumberTotal">38</span>
        </div>
        <button class="nav-btn" onclick="nextSlide()" aria-label="下一页" title="下一页 (→)">下一页 →</button>
    </div>
<script>
    let slides, totalSlides, counter, currentSlide = 0;
    let currentAnimation;
    let globalAnimationPlaying = true;
    let globalAnimationSpeed = 1.0;

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        counter = document.getElementById('page-indicator');
        
        initFloatingMenu();
        showSlide(0);

        // 键盘导航
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ' || e.key === 'PageDown') {
                e.preventDefault();
                nextSlide();
            } else if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
                e.preventDefault();
                previousSlide();
            } else if (e.key === 'Home') {
                e.preventDefault();
                showSlide(0);
            } else if (e.key === 'End') {
                e.preventDefault();
                showSlide(totalSlides - 1);
            }
        });

        // 鼠标滚轮导航
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY > 0) {
                nextSlide();
            } else {
                previousSlide();
            }
        }, { passive: false });
    });

    // 浮动菜单初始化
    function initFloatingMenu() {
        const menuToggle = document.getElementById('menu-toggle');
        const menuContent = document.getElementById('menu-content');
        
        if (menuToggle && menuContent) {
            menuToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                menuToggle.classList.toggle('active');
                menuContent.classList.toggle('active');
            });
            
            // 点击页面其他地方关闭菜单
            document.addEventListener('click', function(e) {
                if (!menuToggle.contains(e.target) && !menuContent.contains(e.target)) {
                    menuToggle.classList.remove('active');
                    menuContent.classList.remove('active');
                }
            });
            
            menuContent.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }
    }

    // 翻页功能
    function nextSlide() {
        currentSlide = (currentSlide + 1) % totalSlides;
        showSlide(currentSlide);
    }

    function previousSlide() {
        currentSlide = (currentSlide - 1 + totalSlides) % totalSlides;
        showSlide(currentSlide);
    }

    function jumpToSlide(value) {
        const slideNumber = parseInt(value);
        if (slideNumber >= 1 && slideNumber <= totalSlides) {
            currentSlide = slideNumber - 1;
            showSlide(currentSlide);
        }
    }

    function showSlide(index) {
        slides.forEach(slide => slide.classList.remove('active'));
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        
        // 更新页码输入框
        const slideInput = document.getElementById('slideNumberInput');
        const slideTotal = document.getElementById('slideNumberTotal');
        if (slideInput) {
            slideInput.value = currentSlide + 1;
            slideInput.max = totalSlides;
        }
        if (slideTotal) {
            slideTotal.textContent = totalSlides;
        }
        
        updateNavButtons();
        
        // 先渲染MathJax，然后运行可视化
        if (window.MathJax && window.MathJax.typesetPromise) {
            window.MathJax.typesetPromise([slides[currentSlide]]).then(() => {
                runVisualization(currentSlide);
            });
        } else {
            runVisualization(currentSlide);
        }
    }

    function updateNavButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        if (prevBtn && nextBtn) {
            prevBtn.disabled = (currentSlide === 0);
            nextBtn.disabled = (currentSlide === totalSlides - 1);
        }
    }

    // D3.js 辅助函数
    
    const rootStyles = getComputedStyle(document.documentElement);
    const themeColors = {
        text: rootStyles.getPropertyValue('--text-color').trim() || '#34495e',
        axis: rootStyles.getPropertyValue('--axis-color').trim() || '#475569',
        muted: rootStyles.getPropertyValue('--muted-color').trim() || '#94a3b8',
        surface: rootStyles.getPropertyValue('--card-bg').trim() || '#ffffff'
    };

function setupD3(containerId, margins = {top: 20, right: 20, bottom: 30, left: 30}) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) {
            console.error(`setupD3: Container with id '${containerId}' not found`);
            return null;
        }
        
        container.html('');
        
        // 设置容器样式确保充分利用空间
        container.style('width', '100%').style('height', '100%');
        
        const bounds = container.node().getBoundingClientRect();
        if (bounds.width === 0 || bounds.height === 0) {
            console.warn(`setupD3: Container '${containerId}' has zero dimensions`, bounds);
            // 尝试使用父容器的尺寸
            const parentBounds = container.node().parentElement.getBoundingClientRect();
            if (parentBounds.width > 0 && parentBounds.height > 0) {
                bounds.width = parentBounds.width * 0.95; // 使用95%的宽度
                bounds.height = parentBounds.height * 0.95; // 使用95%的高度
            } else {
                return null;
            }
        }
        
        const svg = container.append('svg')
            .attr('width', bounds.width)
            .attr('height', bounds.height)
            .style('display', 'block');
        
        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margins.left}, ${margins.top})`);
        
        return { container, svg, g, width, height };
    }

    function drawAxes(g, xScale, yScale, width, height) {
        // X轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(10))
            .call(g => g.select(".domain").attr("stroke-width", 1.5).attr("stroke", "#333"))
            .style('font-size', '14px');

        // Y轴
        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale).ticks(10))
            .call(g => g.select(".domain").attr("stroke-width", 1.5).attr("stroke", "#333"))
            .style('font-size', '14px');
            
        // 添加网格线
        g.append('g')
            .attr('class', 'grid')
            .attr('transform', `translate(0, ${height})`)
            .call(d3.axisBottom(xScale).ticks(10).tickSize(-height).tickFormat(''))
            .style('stroke-dasharray', '3,3')
            .style('opacity', 0.3);
            
        g.append('g')
            .attr('class', 'grid')
            .call(d3.axisLeft(yScale).ticks(10).tickSize(-width).tickFormat(''))
            .style('stroke-dasharray', '3,3')
            .style('opacity', 0.3);
    }

    // 运行可视化
    function runVisualization(slideIndex) {
        // 清理之前的动画
        if (currentAnimation && typeof currentAnimation === 'function') {
            currentAnimation();
        }
        
        // 延迟执行，确保容器尺寸正确
        setTimeout(() => {
            // 先尝试通过容器ID查找并调用对应的可视化函数
            const slideEl = slides[slideIndex];
            if (slideEl) {
                const visDiv = slideEl.querySelector('.right-visual > div[id]');
                if (visDiv && visDiv.id) {
                    const containerId = visDiv.id;
                    // 根据容器ID调用对应的可视化函数
                    const visMap = {
                        'vis-title': visualizeTitle,
                        'vis-contents': visualizeContents,
                        'vis-section1': visualizeSection1,
                        'vis-mvt-overview': visualizeMVTOverview,
                        'vis-rolle': visualizeRolle,
                        'vis-lagrange': visualizeLagrange,
                        'vis-cauchy': visualizeCauchy,
                        'vis-section2': visualizeSection2,
                        'vis-lhopital': visualizeLHopital,
                        'vis-lhopital-examples': visualizeLHopitalExamples,
                        'vis-section3': visualizeSection3,
                        'vis-derivative-intro': visualizeDerivativeIntro,
                        'vis-tangent-line': visualizeTangentLine,
                        'vis-monotonicity': visualizeMonotonicity,
                        'vis-monotonicity-example': visualizeMonotonicityExample,
                        'vis-monotonic-intervals': visualizeMonotonicIntervals,
                        'vis-extremum-concept': visualizeExtremumConcept,
                        'vis-extremum-test': visualizeExtremumTest,
                        'vis-extremum-example': visualizeExtremumExample,
                        'vis-section5': visualizeSection5,
                        'vis-max-min': visualizeMaxMin,
                        'vis-maxmin-example': visualizeMaxMinExample,
                        'vis-max-value-method': visualizeMaxValueMethod,
                        'vis-cost-optimization': visualizeCostOptimization,
                        'vis-profit-optimization': visualizeProfitOptimization,
                        'vis-container-design': visualizeContainerDesign,
                        'vis-related-rates': visualizeRelatedRates,
                        'vis-section4': visualizeSection4,
                        'vis-concavity': visualizeConcavity,
                        'vis-concavity-example': visualizeConcavityExample,
                        'vis-marginal-analysis': visualizeMarginalAnalysis,
                        'vis-elasticity': visualizeElasticity,
                        'vis-curve-sketching': visualizeCurveSketching,
                        'vis-practice-1': visualizePractice1,
                        'vis-practice-2': visualizePractice2,
                        'vis-practice-3': visualizePractice3,
                        'vis-practice-4': visualizePractice4,
                        'vis-summary': visualizeSummary
                    };
                    
                    const visFn = visMap[containerId];
                    if (visFn && typeof visFn === 'function') {
                        visFn(containerId);
                        return;
                    }
                }
            }
            
            // 如果通过ID找不到，则使用索引映射（向后兼容）
            switch(slideIndex) {
            case 0: visualizeTitle('vis-title'); break;
            case 1: visualizeContents('vis-contents'); break;
            case 2: visualizeSection1('vis-section1'); break;
            case 3: visualizeMVTOverview('vis-mvt-overview'); break;
            case 4: visualizeRolle('vis-rolle'); break;
            case 5: visualizeLagrange('vis-lagrange'); break;
            case 6: visualizeCauchy('vis-cauchy'); break;
            case 7: visualizeSection2('vis-section2'); break;
            case 8: visualizeLHopital('vis-lhopital'); break;
            case 9: visualizeLHopitalExamples('vis-lhopital-examples'); break;
            case 10: visualizeSection3('vis-section3'); break;
            case 11: visualizeDerivativeIntro('vis-derivative-intro'); break;
            case 12: visualizeTangentLine('vis-tangent-line'); break;
            case 13: visualizeMonotonicity('vis-monotonicity'); break;
            case 14: visualizeMonotonicityExample('vis-monotonicity-example'); break;
            case 15: visualizeMonotonicIntervals('vis-monotonic-intervals'); break;
            case 16: visualizeExtremumConcept('vis-extremum-concept'); break;
            case 17: visualizeExtremumTest('vis-extremum-test'); break;
            case 18: visualizeExtremumExample('vis-extremum-example'); break;
            case 19: visualizeSection5('vis-section5'); break;
            case 20: visualizeMaxMin('vis-max-min'); break;
            case 21: visualizeMaxMinExample('vis-maxmin-example'); break;
            case 22: visualizeMaxValueMethod('vis-max-value-method'); break;
            case 23: visualizeCostOptimization('vis-cost-optimization'); break;
            case 24: visualizeProfitOptimization('vis-profit-optimization'); break;
case 25: visualizeContainerDesign('vis-container-design'); break;
case 26: visualizeRelatedRates('vis-related-rates'); break;
case 27: visualizeSection4('vis-section4'); break;
case 28: visualizeConcavity('vis-concavity'); break;
case 29: visualizeConcavityExample('vis-concavity-example'); break;
case 30: visualizeMarginalAnalysis('vis-marginal-analysis'); break;
case 31: visualizeElasticity('vis-elasticity'); break;
case 32: visualizeCurveSketching('vis-curve-sketching'); break;
case 33: visualizePractice1('vis-practice-1'); break;
case 34: visualizePractice2('vis-practice-2'); break;
case 35: visualizePractice3('vis-practice-3'); break;
case 36: visualizePractice4('vis-practice-4'); break;
case 37: visualizeSummary('vis-summary'); break;
            }
        }, 100); // 延迟100ms执行
    }

    // 过渡页可视化函数（通用）
    function visualizeSectionTransition(containerId, sectionNumber, color) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { svg, g, width, height } = setup;
        
        // 创建大型章节标识
        g.append('circle')
            .attr('cx', width / 2)
            .attr('cy', height / 2)
            .attr('r', 0)
            .attr('fill', color)
            .attr('opacity', 0.2)
            .transition()
            .duration(1500)
            .attr('r', 100);
        
        // 添加章节编号
        g.append('text')
            .attr('x', width / 2)
            .attr('y', height / 2)
            .text(sectionNumber)
            .style('font-size', '60px')
            .style('font-weight', 'bold')
            .style('fill', color)
            .style('text-anchor', 'middle')
            .style('dominant-baseline', 'middle')
            .style('opacity', 0)
            .transition()
            .delay(500)
            .duration(1000)
            .style('opacity', 1);
    }
    
    function visualizeSection1(containerId) {
        visualizeSectionTransition(containerId, '1', '#3498db');
    }
    
    function visualizeSection2(containerId) {
        visualizeSectionTransition(containerId, '2', '#e74c3c');
    }
    
    function visualizeSection3(containerId) {
        visualizeSectionTransition(containerId, '3', '#f39c12');
    }
    
    function visualizeSection4(containerId) {
        visualizeSectionTransition(containerId, '4', '#9b59b6');
    }
    
    function visualizeSection5(containerId) {
        visualizeSectionTransition(containerId, '5', '#27ae60');
    }

    // 第1页：标题页可视化 - 精美升级版
    function visualizeTitle(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, svg, g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 添加渐变定义
        const defs = svg.append('defs');
        
        // 蓝色渐变
        const blueGradient = defs.append('linearGradient')
            .attr('id', 'blueGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        blueGradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#3498db')
            .style('stop-opacity', 1);
        blueGradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#2980b9')
            .style('stop-opacity', 1);
        
        // 红色渐变
        const redGradient = defs.append('linearGradient')
            .attr('id', 'redGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        redGradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#e74c3c')
            .style('stop-opacity', 1);
        redGradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#c0392b')
            .style('stop-opacity', 1);
        
        // 背景装饰圆圈
        for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI * 2) / 8;
            const radius = 200 + i * 15;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            g.append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 3)
                .attr('fill', '#9b59b6')
                .attr('opacity', 0)
                .transition()
                .delay(2000 + i * 100)
                .duration(800)
                .attr('opacity', 0.3);
        }
        
        const symbolGroup = g.append('g')
            .attr('transform', `translate(${centerX}, ${centerY})`);
        
        // dy文字 - 带阴影效果
        const dyText = symbolGroup.append('text')
            .attr('text-anchor', 'middle')
            .attr('y', -35)
            .attr('font-size', '90px')
            .attr('fill', 'url(#blueGradient)')
            .attr('font-weight', 'bold')
            .attr('font-style', 'italic')
            .text('dy')
            .style('opacity', 0)
            .style('filter', 'drop-shadow(0 4px 8px rgba(52, 152, 219, 0.3))');
        
        dyText.transition()
            .duration(1200)
            .style('opacity', 1)
            .attr('y', -35)
            .ease(d3.easeElasticOut);
        
        // 分数线 - 动态扩展
        const line = symbolGroup.append('line')
            .attr('x1', 0)
            .attr('x2', 0)
            .attr('y1', 10)
            .attr('y2', 10)
            .attr('stroke', '#2c3e50')
            .attr('stroke-width', 5)
            .attr('stroke-linecap', 'round');
        
        line.transition()
            .delay(600)
            .duration(1000)
            .attr('x1', -70)
            .attr('x2', 70)
            .ease(d3.easeBackOut);
        
        // dx文字 - 带阴影效果
        const dxText = symbolGroup.append('text')
            .attr('text-anchor', 'middle')
            .attr('y', 90)
            .attr('font-size', '90px')
            .attr('fill', 'url(#redGradient)')
            .attr('font-weight', 'bold')
            .attr('font-style', 'italic')
            .text('dx')
            .style('opacity', 0)
            .style('filter', 'drop-shadow(0 4px 8px rgba(231, 76, 60, 0.3))');
        
        dxText.transition()
            .delay(1200)
            .duration(1200)
            .style('opacity', 1)
            .attr('y', 90)
            .ease(d3.easeElasticOut);
        
        // 等号和文字说明
        symbolGroup.append('text')
            .attr('x', 140)
            .attr('y', 10)
            .attr('font-size', '40px')
            .attr('fill', '#7f8c8d')
            .attr('text-anchor', 'start')
            .text('=')
            .style('opacity', 0)
            .transition()
            .delay(1800)
            .duration(600)
            .style('opacity', 1);
        
        symbolGroup.append('text')
            .attr('x', 180)
            .attr('y', -10)
            .attr('font-size', '28px')
            .attr('fill', '#16a085')
            .attr('font-weight', 'bold')
            .text('导数')
            .style('opacity', 0)
            .transition()
            .delay(2000)
            .duration(600)
            .style('opacity', 1);
        
        symbolGroup.append('text')
            .attr('x', 180)
            .attr('y', 25)
            .attr('font-size', '20px')
            .attr('fill', '#95a5a6')
            .text('变化率')
            .style('opacity', 0)
            .transition()
            .delay(2200)
            .duration(600)
            .style('opacity', 1);
        
        // 主圆环 - 旋转动画
        const mainCircle = symbolGroup.append('circle')
            .attr('r', 0)
            .attr('fill', 'none')
            .attr('stroke', '#9b59b6')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '15,5')
            .attr('opacity', 0.8);
        
        mainCircle.transition()
            .delay(1600)
            .duration(1800)
            .attr('r', 180)
            .ease(d3.easeBackOut);
        
        // 外圆环 - 脉冲效果
        const outerCircle = symbolGroup.append('circle')
            .attr('r', 0)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '10,10')
            .attr('opacity', 0.4);
        
        outerCircle.transition()
            .delay(2400)
            .duration(2000)
            .attr('r', 220)
            .ease(d3.easeCircleOut);
        
        // 添加持续旋转动画
        function rotateCircles() {
            mainCircle
                .transition()
                .duration(20000)
                .ease(d3.easeLinear)
                .attrTween('transform', function() {
                    return d3.interpolateString('rotate(0)', 'rotate(360)');
                })
                .on('end', rotateCircles);
            
            outerCircle
                .transition()
                .duration(30000)
                .ease(d3.easeLinear)
                .attrTween('transform', function() {
                    return d3.interpolateString('rotate(0)', 'rotate(-360)');
                })
                .on('end', () => {});
        }
        
        setTimeout(rotateCircles, 2500);
        
        // 装饰性小圆点
        const dotAngles = [0, 45, 90, 135, 180, 225, 270, 315];
        dotAngles.forEach((angle, i) => {
            const rad = (angle * Math.PI) / 180;
            const r = 180;
            const dotX = Math.cos(rad) * r;
            const dotY = Math.sin(rad) * r;
            
            symbolGroup.append('circle')
                .attr('cx', dotX)
                .attr('cy', dotY)
                .attr('r', 0)
                .attr('fill', '#e74c3c')
                .transition()
                .delay(2600 + i * 80)
                .duration(400)
                .attr('r', 5)
                .transition()
                .duration(200)
                .attr('r', 3);
        });
    }

    // 第2页：目录页可视化 - 精美升级版
    function visualizeContents(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { svg, g, width, height } = setup;
        
        // 添加渐变
        const defs = svg.append('defs');
        const gradients = [
            { id: 'grad1', color1: '#3498db', color2: '#2980b9' },
            { id: 'grad2', color1: '#2ecc71', color2: '#27ae60' },
            { id: 'grad3', color1: '#f39c12', color2: '#e67e22' },
            { id: 'grad4', color1: '#e74c3c', color2: '#c0392b' },
            { id: 'grad5', color1: '#9b59b6', color2: '#8e44ad' },
            { id: 'grad6', color1: '#1abc9c', color2: '#16a085' }
        ];
        
        gradients.forEach(grad => {
            const gradient = defs.append('radialGradient')
                .attr('id', grad.id);
            gradient.append('stop')
                .attr('offset', '0%')
                .style('stop-color', grad.color1)
                .style('stop-opacity', 0.8);
            gradient.append('stop')
                .attr('offset', '100%')
                .style('stop-color', grad.color2)
                .style('stop-opacity', 0.4);
        });
        
        const topics = [
            { icon: 'triangle', title: '几何意义', grad: 'grad1', y: 0.12, delay: 0 },
            { icon: 'trending-up', title: '单调性', grad: 'grad2', y: 0.28, delay: 200 },
            { icon: 'star', title: '极值最值', grad: 'grad3', y: 0.44, delay: 400 },
            { icon: 'target', title: '优化问题', grad: 'grad4', y: 0.60, delay: 600 },
            { icon: 'bar-chart', title: '图像描绘', grad: 'grad5', y: 0.76, delay: 800 },
            { icon: 'briefcase', title: '实际应用', grad: 'grad6', y: 0.92, delay: 1000 }
        ];
        
        // 背景连接线
        for (let i = 0; i < topics.length - 1; i++) {
            const line = g.append('line')
                .attr('x1', width / 2)
                .attr('y1', height * topics[i].y)
                .attr('x2', width / 2)
                .attr('y2', height * topics[i].y)
                .attr('stroke', '#bdc3c7')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('opacity', 0.3);
            
            line.transition()
                .delay(topics[i].delay + 400)
                .duration(600)
                .attr('y2', height * topics[i + 1].y);
        }
        
        topics.forEach((topic, i) => {
            const group = g.append('g')
                .attr('transform', `translate(${width/2}, ${height * topic.y})`)
                .style('opacity', 0)
                .style('cursor', 'pointer');
            
            // 外圈光晕
            const halo = group.append('circle')
                .attr('r', 0)
                .attr('fill', `url(#${topic.grad})`)
                .attr('opacity', 0.2);
            
            // 主圆圈
            const mainCircle = group.append('circle')
                .attr('r', 0)
                .attr('fill', `url(#${topic.grad})`)
                .attr('opacity', 0.6)
                .attr('stroke', '#fff')
                .attr('stroke-width', 3);
            
            // 图标
            // 添加SVG图标
            const iconGroup = group.append('g')
                .attr('transform', 'translate(-12, -12)');
            
            // 根据图标名称添加对应的SVG
            let iconSvg = '';
            switch(topic.icon) {
                case 'triangle':
                    iconSvg = '<path d="M10.29,3.86L1.82,18a2,2,0,0,0,1.71,3H20.47a2,2,0,0,0,1.71-3L13.71,3.86A2,2,0,0,0,10.29,3.86Z"></path>';
                    break;
                case 'trending-up':
                    iconSvg = '<polyline points="23,6 13.5,15.5 8.5,10.5 1,18"></polyline><polyline points="17,6 23,6 23,12"></polyline>';
                    break;
                case 'star':
                    iconSvg = '<polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>';
                    break;
                case 'target':
                    iconSvg = '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>';
                    break;
                case 'bar-chart':
                    iconSvg = '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>';
                    break;
                case 'briefcase':
                    iconSvg = '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16,21V5a2,2,0,0,0-2-2H10A2,2,0,0,0,8,5V21"></path>';
                    break;
            }
            
            iconGroup.append('svg')
                .attr('width', '24')
                .attr('height', '24')
                .attr('viewBox', '0 0 24 24')
                .attr('fill', 'none')
                .attr('stroke', 'white')
                .attr('stroke-width', '2')
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .html(iconSvg);
            
            // 标题文字
            const titleText = group.append('text')
                .attr('text-anchor', 'middle')
                .attr('y', 75)
                .attr('font-size', '20px')
                .attr('fill', '#2c3e50')
                .attr('font-weight', 'bold')
                .text(topic.title)
                .style('opacity', 0);
            
            // 序号
            const numberText = group.append('text')
                .attr('text-anchor', 'middle')
                .attr('x', -70)
                .attr('font-size', '32px')
                .attr('fill', `url(#${topic.grad})`)
                .attr('font-weight', 'bold')
                .text(i + 1)
                .style('opacity', 0);
            
            // 动画序列
            group.transition()
                .delay(topic.delay)
                .duration(600)
                .style('opacity', 1);
            
            halo.transition()
                .delay(topic.delay + 100)
                .duration(800)
                .attr('r', 75)
                .ease(d3.easeCircleOut);
            
            mainCircle.transition()
                .delay(topic.delay + 200)
                .duration(600)
                .attr('r', 55)
                .ease(d3.easeBackOut);
            
            iconText.transition()
                .delay(topic.delay + 400)
                .duration(500)
                .attr('font-size', '42px');
            
            titleText.transition()
                .delay(topic.delay + 600)
                .duration(400)
                .style('opacity', 1);
            
            numberText.transition()
                .delay(topic.delay + 300)
                .duration(400)
                .style('opacity', 0.6);
            
            // 鼠标悬停效果
            group.on('mouseover', function() {
                d3.select(this).transition()
                    .duration(200)
                    .attr('transform', `translate(${width/2}, ${height * topic.y}) scale(1.15)`);
                
                halo.transition()
                    .duration(200)
                    .attr('r', 85)
                    .attr('opacity', 0.4);
            });
            
            group.on('mouseout', function() {
                d3.select(this).transition()
                    .duration(200)
                    .attr('transform', `translate(${width/2}, ${height * topic.y}) scale(1)`);
                
                halo.transition()
                    .duration(200)
                    .attr('r', 75)
                    .attr('opacity', 0.2);
            });
            
            // 脉冲动画
            function pulse() {
                mainCircle
                    .transition()
                    .duration(2000)
                    .attr('r', 58)
                    .transition()
                    .duration(2000)
                    .attr('r', 55)
                    .on('end', pulse);
            }
            
            setTimeout(() => pulse(), topic.delay + 1000);
        });
        
        // 标题装饰
        const titleDecor = g.append('g')
            .attr('transform', `translate(${width/2}, 30)`);
        
        titleDecor.append('line')
            .attr('x1', -100)
            .attr('x2', -20)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .attr('stroke-linecap', 'round')
            .attr('opacity', 0)
            .transition()
            .delay(1200)
            .duration(600)
            .attr('opacity', 0.6);
        
        titleDecor.append('line')
            .attr('x1', 20)
            .attr('x2', 100)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .attr('stroke-linecap', 'round')
            .attr('opacity', 0)
            .transition()
            .delay(1200)
            .duration(600)
            .attr('opacity', 0.6);
    }

    // 第3页：中值定理概述可视化
    function visualizeMVTOverview(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { svg, g, width, height } = setup;
        
        // 绘制三个定理的图示
        const theorems = [
            { name: 'Rolle', y: height * 0.25, color: '#059669' },
            { name: 'Lagrange', y: height * 0.5, color: '#dc2626' },
            { name: 'Cauchy', y: height * 0.75, color: '#9333ea' }
        ];
        
        theorems.forEach((theorem, i) => {
            const group = g.append('g')
                .attr('transform', `translate(${width/2}, ${theorem.y})`);
            
            // 绘制圆圈
            group.append('circle')
                .attr('r', 0)
                .attr('fill', theorem.color)
                .attr('opacity', 0.2)
                .transition()
                .delay(i * 200)
                .duration(800)
                .attr('r', 60);
            
            // 添加文字
            group.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .style('fill', theorem.color)
                .style('opacity', 0)
                .text(theorem.name)
                .transition()
                .delay(i * 200 + 400)
                .duration(600)
                .style('opacity', 1);
        });
        
        // 添加连接线
        setTimeout(() => {
            g.append('line')
                .attr('x1', width/2)
                .attr('y1', theorems[0].y + 60)
                .attr('x2', width/2)
                .attr('y2', theorems[0].y + 60)
                .attr('stroke', '#666')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .transition()
                .duration(800)
                .attr('y2', theorems[2].y - 60);
        }, 800);
    }

    // 第4页：罗尔定理可视化
    function visualizeRolle(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { svg, g, width, height } = setup;
        
        const margin = { top: 40, right: 40, bottom: 60, left: 60 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const xScale = d3.scaleLinear().domain([0, 4]).range([0, innerWidth]);
        const yScale = d3.scaleLinear().domain([0, 3]).range([innerHeight, 0]);
        
        const chart = g.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 坐标轴
        chart.append('g')
            .attr('transform', `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5))
            .style('color', '#666');
        
        chart.append('g')
            .call(d3.axisLeft(yScale).ticks(4))
            .style('color', '#666');
        
        // 罗尔定理的函数曲线 f(x) = (x-1)(x-3) + 1
        const rolleFunc = x => -(x - 1) * (x - 3) + 1;
        const pathData = [];
        for (let x = 1; x <= 3; x += 0.05) {
            pathData.push([xScale(x), yScale(rolleFunc(x))]);
        }
        
        const line = d3.line();
        
        // 绘制曲线
        const path = chart.append('path')
            .datum(pathData)
            .attr('fill', 'none')
            .attr('stroke', '#059669')
            .attr('stroke-width', 3)
            .attr('d', line);
        
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);
        
        // 标记端点 f(a) = f(b)
        setTimeout(() => {
            [1, 3].forEach((x, i) => {
                chart.append('circle')
                    .attr('cx', xScale(x))
                    .attr('cy', yScale(rolleFunc(x)))
                    .attr('r', 0)
                    .attr('fill', '#dc2626')
                    .transition()
                    .delay(i * 200)
                    .duration(500)
                    .attr('r', 6);
                
                chart.append('text')
                    .attr('x', xScale(x))
                    .attr('y', yScale(rolleFunc(x)) - 15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '16px')
                    .style('fill', '#dc2626')
                    .style('opacity', 0)
                    .text(i === 0 ? 'f(a)' : 'f(b)')
                    .transition()
                    .delay(i * 200)
                    .duration(500)
                    .style('opacity', 1);
            });
            
            // 标记ξ点（导数为0的点）
            const xi = 2;
            setTimeout(() => {
                chart.append('circle')
                    .attr('cx', xScale(xi))
                    .attr('cy', yScale(rolleFunc(xi)))
                    .attr('r', 0)
                    .attr('fill', '#f59e0b')
                    .transition()
                    .duration(500)
                    .attr('r', 10);
                
                // 绘制水平切线
                chart.append('line')
                    .attr('x1', xScale(1.3))
                    .attr('y1', yScale(rolleFunc(xi)))
                    .attr('x2', xScale(1.3))
                    .attr('y2', yScale(rolleFunc(xi)))
                    .attr('stroke', '#f59e0b')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5')
                    .transition()
                    .duration(800)
                    .attr('x2', xScale(2.7));
                
                chart.append('text')
                    .attr('x', xScale(xi))
                    .attr('y', yScale(rolleFunc(xi)) + 25)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '16px')
                    .style('font-weight', 'bold')
                    .style('fill', '#f59e0b')
                    .style('opacity', 0)
                    .text("ξ: f'(ξ)=0")
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
            }, 600);
        }, 2000);
    }

    // 第5页：拉格朗日中值定理可视化
    function visualizeLagrange(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { svg, g, width, height } = setup;
        
        const margin = { top: 40, right: 40, bottom: 60, left: 60 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const xScale = d3.scaleLinear().domain([0, 5]).range([0, innerWidth]);
        const yScale = d3.scaleLinear().domain([0, 4]).range([innerHeight, 0]);
        
        const chart = g.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 坐标轴
        chart.append('g')
            .attr('transform', `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(6))
            .style('color', '#666');
        
        chart.append('g')
            .call(d3.axisLeft(yScale).ticks(5))
            .style('color', '#666');
        
        // 拉格朗日函数 f(x) = 0.2x^2 + 0.5
        const lagrangeFunc = x => 0.2 * x * x + 0.5;
        const a = 1, b = 4;
        
        const pathData = [];
        for (let x = a; x <= b; x += 0.05) {
            pathData.push([xScale(x), yScale(lagrangeFunc(x))]);
        }
        
        const line = d3.line();
        
        // 绘制曲线
        const path = chart.append('path')
            .datum(pathData)
            .attr('fill', 'none')
            .attr('stroke', '#dc2626')
            .attr('stroke-width', 3)
            .attr('d', line);
        
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);
        
        setTimeout(() => {
            // 绘制割线
            chart.append('line')
                .attr('x1', xScale(a))
                .attr('y1', yScale(lagrangeFunc(a)))
                .attr('x2', xScale(a))
                .attr('y2', yScale(lagrangeFunc(a)))
                .attr('stroke', '#3b82f6')
                .attr('stroke-width', 2)
                .transition()
                .duration(1000)
                .attr('x2', xScale(b))
                .attr('y2', yScale(lagrangeFunc(b)));
            
            // 标记端点
            [a, b].forEach((x, i) => {
                chart.append('circle')
                    .attr('cx', xScale(x))
                    .attr('cy', yScale(lagrangeFunc(x)))
                    .attr('r', 0)
                    .attr('fill', '#3b82f6')
                    .transition()
                    .delay(i * 300)
                    .duration(500)
                    .attr('r', 6);
            });
            
            // 计算并绘制切线点
            const slope = (lagrangeFunc(b) - lagrangeFunc(a)) / (b - a);
            const xi = 2.5; // 近似计算的ξ点
            
            setTimeout(() => {
                // 绘制切线
                const tangentY1 = lagrangeFunc(xi) - slope * 0.8;
                const tangentY2 = lagrangeFunc(xi) + slope * 0.8;
                
                chart.append('line')
                    .attr('x1', xScale(xi - 0.8))
                    .attr('y1', yScale(tangentY1))
                    .attr('x2', xScale(xi - 0.8))
                    .attr('y2', yScale(tangentY1))
                    .attr('stroke', '#f59e0b')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5')
                    .transition()
                    .duration(800)
                    .attr('x2', xScale(xi + 0.8))
                    .attr('y2', yScale(tangentY2));
                
                // 标记ξ点
                chart.append('circle')
                    .attr('cx', xScale(xi))
                    .attr('cy', yScale(lagrangeFunc(xi)))
                    .attr('r', 0)
                    .attr('fill', '#f59e0b')
                    .transition()
                    .duration(500)
                    .attr('r', 10);
                
                chart.append('text')
                    .attr('x', xScale(xi))
                    .attr('y', yScale(lagrangeFunc(xi)) - 20)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '16px')
                    .style('font-weight', 'bold')
                    .style('fill', '#f59e0b')
                    .style('opacity', 0)
                    .text('ξ')
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
                
                // 添加说明文字
                chart.append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', -10)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '16px')
                    .style('fill', '#666')
                    .style('opacity', 0)
                    .text("切线斜率 = 割线斜率")
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
            }, 1200);
        }, 2000);
    }

    // 第6页：柯西中值定理可视化
    function visualizeCauchy(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { svg, g, width, height } = setup;
        
        const margin = { top: 60, right: 40, bottom: 60, left: 60 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        // 参数方程：x(t) = t, y(t) = t^2
        const tMin = 0, tMax = 3;
        const xFunc = t => t;
        const yFunc = t => 0.3 * t * t;
        
        const xScale = d3.scaleLinear()
            .domain([tMin - 0.5, tMax + 0.5])
            .range([0, innerWidth]);
        const yScale = d3.scaleLinear()
            .domain([0, 3.5])
            .range([innerHeight, 0]);
        
        const chart = g.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 坐标轴
        chart.append('g')
            .attr('transform', `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(5))
            .style('color', '#666');
        
        chart.append('g')
            .call(d3.axisLeft(yScale).ticks(5))
            .style('color', '#666');
        
        // 绘制参数曲线
        const pathData = [];
        for (let t = tMin; t <= tMax; t += 0.05) {
            pathData.push([xScale(xFunc(t)), yScale(yFunc(t))]);
        }
        
        const line = d3.line();
        const path = chart.append('path')
            .datum(pathData)
            .attr('fill', 'none')
            .attr('stroke', '#9333ea')
            .attr('stroke-width', 3)
            .attr('d', line);
        
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2500)
            .attr('stroke-dashoffset', 0);
        
        setTimeout(() => {
            const t1 = 0.5, t2 = 2.5;
            
            // 绘制割线
            chart.append('line')
                .attr('x1', xScale(xFunc(t1)))
                .attr('y1', yScale(yFunc(t1)))
                .attr('x2', xScale(xFunc(t1)))
                .attr('y2', yScale(yFunc(t1)))
                .attr('stroke', '#3b82f6')
                .attr('stroke-width', 2)
                .transition()
                .duration(1000)
                .attr('x2', xScale(xFunc(t2)))
                .attr('y2', yScale(yFunc(t2)));
            
            // 标记端点
            [t1, t2].forEach((t, i) => {
                chart.append('circle')
                    .attr('cx', xScale(xFunc(t)))
                    .attr('cy', yScale(yFunc(t)))
                    .attr('r', 0)
                    .attr('fill', '#3b82f6')
                    .transition()
                    .delay(i * 300)
                    .duration(500)
                    .attr('r', 6);
                
                chart.append('text')
                    .attr('x', xScale(xFunc(t)))
                    .attr('y', yScale(yFunc(t)) - 15)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .style('fill', '#3b82f6')
                    .text(i === 0 ? '(x(a), y(a))' : '(x(b), y(b))');
            });
            
            // 标记ξ点
            const tXi = 1.5;
            setTimeout(() => {
                chart.append('circle')
                    .attr('cx', xScale(xFunc(tXi)))
                    .attr('cy', yScale(yFunc(tXi)))
                    .attr('r', 0)
                    .attr('fill', '#f59e0b')
                    .transition()
                    .duration(500)
                    .attr('r', 10);
                
                // 添加标题
                chart.append('text')
                    .attr('x', innerWidth / 2)
                    .attr('y', -30)
                    .attr('text-anchor', 'middle')
                    .style('font-size', '16px')
                    .style('fill', '#666')
                    .style('opacity', 0)
                    .text("参数曲线的中值定理")
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
            }, 1200);
        }, 2500);
    }

    // 第7页：导数直观理解（原第3页）
    function visualizeDerivativeIntro(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([0, 10]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 100]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 位置函数 s(t) = t²
        const data = d3.range(0, 10.1, 0.1).map(t => ({t: t, s: t * t}));
        const line = d3.line().x(d => xScale(d.t)).y(d => yScale(d.s));
        
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 标签
        g.append('text')
            .attr('x', xScale(8))
            .attr('y', yScale(70))
            .text('s(t) = t²')
            .style('font-size', '18px')
            .style('fill', '#3498db')
            .style('font-weight', 'bold');
        
        // 动画小球
        const ball = g.append('circle')
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('cx', xScale(0))
            .attr('cy', yScale(0));
        
        // 速度显示
        const speedDisplay = container.append('div')
            .attr('class', 'value-display')
            .html(`
                <div class="value-item">
                    <span class="value-label">时间 t：</span>
                    <span class="value-number" id="time-value">0.00</span>
                </div>
                <div class="value-item">
                    <span class="value-label">位置 s：</span>
                    <span class="value-number" id="position-value">0.00</span>
                </div>
                <div class="value-item">
                    <span class="value-label">速度 v：</span>
                    <span class="value-number" id="speed-value">0.00</span>
                </div>
            `);
        
        let t = 0;
        let animationId;
        function animate() {
            t += 0.02 / globalAnimationSpeed;
            if (t > 10) t = 0;
            
            const s = t * t;
            const v = 2 * t; // 导数
            
            ball.attr('cx', xScale(t))
                .attr('cy', yScale(s));
            
            container.select('#time-value').text(t.toFixed(2));
            container.select('#position-value').text(s.toFixed(2));
            container.select('#speed-value').text(v.toFixed(2));
            
            if (globalAnimationPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }
        animate();
        
        // 返回清理函数
        return () => {
            if (animationId) cancelAnimationFrame(animationId);
        };
    }

    // 第4页：切线动画
    function visualizeTangentLine(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 10]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 函数 f(x) = x²
        const data = d3.range(-3, 3.1, 0.1).map(x => ({x: x, y: x * x}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 切线
        const tangentLine = g.append('line')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2);
        
        // 切点
        const tangentPoint = g.append('circle')
            .attr('r', 6)
            .attr('fill', '#e74c3c');
        
        // 斜率显示
        const slopeText = g.append('text')
            .style('font-size', '16px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold');
        
        // 信息显示
        const infoDisplay = container.append('div')
            .attr('class', 'value-display')
            .html(`
                <div class="value-item">
                    <span class="value-label">点 x：</span>
                    <span class="value-number" id="x-value">0.00</span>
                </div>
                <div class="value-item">
                    <span class="value-label">函数值 f(x)：</span>
                    <span class="value-number" id="fx-value">0.00</span>
                </div>
                <div class="value-item">
                    <span class="value-label">导数 f'(x)：</span>
                    <span class="value-number" id="fprime-value">0.00</span>
                </div>
            `);
        
        let x0 = -2;
        let animationId;
        
        function updateTangent() {
            const y0 = x0 * x0;
            const slope = 2 * x0;
            
            tangentPoint
                .attr('cx', xScale(x0))
                .attr('cy', yScale(y0));
            
            // 切线方程：y - y0 = slope * (x - x0)
            const x1 = -3, x2 = 3;
            const y1 = y0 + slope * (x1 - x0);
            const y2 = y0 + slope * (x2 - x0);
            
            tangentLine
                .attr('x1', xScale(x1))
                .attr('y1', yScale(y1))
                .attr('x2', xScale(x2))
                .attr('y2', yScale(y2));
            
            slopeText
                .attr('x', xScale(x0) + 10)
                .attr('y', yScale(y0) - 10)
                .text(`斜率 = ${slope.toFixed(1)}`);
            
            // 更新信息
            container.select('#x-value').text(x0.toFixed(2));
            container.select('#fx-value').text(y0.toFixed(2));
            container.select('#fprime-value').text(slope.toFixed(2));
        }
        
        function animate() {
            x0 += 0.01 / globalAnimationSpeed;
            if (x0 > 2) x0 = -2;
            updateTangent();
            
            if (globalAnimationPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }
        animate();
        
        return () => {
            if (animationId) cancelAnimationFrame(animationId);
        };
    }

    // 第5页：单调性可视化
    function visualizeMonotonicity(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 函数 f(x) = x³ - 3x
        const data = d3.range(-3, 3.1, 0.05).map(x => ({
            x: x, 
            y: x * x * x - 3 * x,
            derivative: 3 * x * x - 3
        }));
        
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        // 递增区间背景
        g.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', xScale(-1))
            .attr('height', height)
            .attr('fill', '#2ecc71')
            .attr('opacity', 0.1);
        
        g.append('rect')
            .attr('x', xScale(1))
            .attr('y', 0)
            .attr('width', width - xScale(1))
            .attr('height', height)
            .attr('fill', '#2ecc71')
            .attr('opacity', 0.1);
        
        // 递减区间背景
        g.append('rect')
            .attr('x', xScale(-1))
            .attr('y', 0)
            .attr('width', xScale(1) - xScale(-1))
            .attr('height', height)
            .attr('fill', '#e74c3c')
            .attr('opacity', 0.1);
        
        // 函数曲线
        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 动画绘制
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);
        
        // 标记极值点
        setTimeout(() => {
            g.append('circle')
                .attr('cx', xScale(-1))
                .attr('cy', yScale(2))
                .attr('r', 0)
                .attr('fill', '#f39c12')
                .transition()
                .duration(500)
                .attr('r', 8);
            
            g.append('circle')
                .attr('cx', xScale(1))
                .attr('cy', yScale(-2))
                .attr('r', 0)
                .attr('fill', '#f39c12')
                .transition()
                .duration(500)
                .attr('r', 8);
        }, 2000);
        
        // 添加标签
        setTimeout(() => {
            g.append('text')
                .attr('x', xScale(-2))
                .attr('y', 30)
                .text('递增 ↗')
                .style('font-size', '16px')
                .style('fill', '#2ecc71')
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
            
            g.append('text')
                .attr('x', xScale(0))
                .attr('y', 30)
                .text('递减 ↘')
                .style('font-size', '16px')
                .style('fill', '#e74c3c')
                .style('font-weight', 'bold')
                .style('text-anchor', 'middle')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
            
            g.append('text')
                .attr('x', xScale(2))
                .attr('y', 30)
                .text('递增 ↗')
                .style('font-size', '16px')
                .style('fill', '#2ecc71')
                .style('font-weight', 'bold')
                .style('text-anchor', 'end')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 2500);
    }

    // 第6页：单调性实例
    function visualizeMonotonicityExample(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // f(x) = x³ - 3x
        const f = x => x * x * x - 3 * x;
        const fPrime = x => 3 * x * x - 3;
        
        // 绘制函数
        const data = d3.range(-3, 3.1, 0.05).map(x => ({x: x, y: f(x)}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 绘制导数
        const derivativeData = d3.range(-3, 3.1, 0.05).map(x => ({x: x, y: fPrime(x)}));
        const derivativeLine = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        g.append('path')
            .datum(derivativeData)
            .attr('d', derivativeLine)
            .attr('fill', 'none')
            .attr('stroke', '#9b59b6')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        
        // 标记关键点
        [-1, 1].forEach((x, i) => {
            setTimeout(() => {
                g.append('circle')
                    .attr('cx', xScale(x))
                    .attr('cy', yScale(f(x)))
                    .attr('r', 0)
                    .attr('fill', '#e74c3c')
                    .attr('class', 'pulse')
                    .transition()
                    .duration(500)
                    .attr('r', 10);
                
                g.append('line')
                    .attr('x1', xScale(x))
                    .attr('y1', yScale(-5))
                    .attr('x2', xScale(x))
                    .attr('y2', yScale(5))
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '3,3')
                    .attr('opacity', 0)
                    .transition()
                    .duration(500)
                    .attr('opacity', 0.5);
                
                g.append('text')
                    .attr('x', xScale(x))
                    .attr('y', yScale(f(x)) + (x === -1 ? -20 : 30))
                    .text(x === -1 ? '极大值' : '极小值')
                    .style('font-size', '16px')
                    .style('font-weight', 'bold')
                    .style('text-anchor', 'middle')
                    .style('fill', '#e74c3c')
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
            }, 1000 + i * 500);
        });
        
        // 图例
        const legend = g.append('g')
            .attr('transform', `translate(${width - 120}, 20)`);
        
        legend.append('line')
            .attr('x1', 0).attr('y1', 0)
            .attr('x2', 30).attr('y2', 0)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        legend.append('text')
            .attr('x', 35).attr('y', 5)
            .text('f(x)')
            .style('font-size', '14px');
        
        legend.append('line')
            .attr('x1', 0).attr('y1', 20)
            .attr('x2', 30).attr('y2', 20)
            .attr('stroke', '#9b59b6')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        legend.append('text')
            .attr('x', 35).attr('y', 25)
            .text("f'(x)")
            .style('font-size', '14px');
    }

    // 第7页：求单调区间可视化
    function visualizeMonotonicIntervals(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, svg, g, width, height } = setup;
        
        // 清除SVG，使用HTML展示步骤
        svg.selectAll("*").remove();
        
        const mainContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '0')
            .style('left', '0')
            .style('right', '0')
            .style('bottom', '0')
            .style('padding', '15px')
            .style('background', 'white')
            .style('border-radius', '8px')
            .style('overflow-y', 'auto')
            .style('font-family', 'inherit')
            .style('border', '1px solid #e0e0e0');
        
        // 标题
        mainContainer.append('div')
            .style('text-align', 'center')
            .style('margin-bottom', '15px')
            .style('padding', '10px')
            .style('background', 'rgba(255,255,255,0.9)')
            .style('border-radius', '6px')
            .style('color', '#2c3e50')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('函数图像与单调区间');
        
        // 创建SVG用于绘制函数图像
        const chartSvg = mainContainer.append('svg')
            .attr('width', '100%')
            .attr('height', '200px')
            .style('background', '#f8f9fa')
            .style('border-radius', '6px')
            .style('margin-bottom', '15px');
        
        const chartWidth = 350;
        const chartHeight = 180;
        const margin = {top: 20, right: 20, bottom: 30, left: 30};
        const innerWidth = chartWidth - margin.left - margin.right;
        const innerHeight = chartHeight - margin.top - margin.bottom;
        
        const xScale = d3.scaleLinear().domain([-1, 5]).range([0, innerWidth]);
        const yScale = d3.scaleLinear().domain([-5, 15]).range([innerHeight, 0]);
        
        const chartG = chartSvg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 坐标轴
        chartG.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(6))
            .style('color', '#666');
        
        chartG.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale).ticks(5))
            .style('color', '#666');
        
        // 函数 f(x) = x³ - 6x² + 9x + 1
        const data = [];
        for (let x = -0.5; x <= 4.5; x += 0.1) {
            const y = Math.pow(x, 3) - 6*Math.pow(x, 2) + 9*x + 1;
            data.push({x: x, y: y});
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        // 绘制函数曲线
        setTimeout(() => {
            chartG.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 3)
                .attr('d', line);
            
            // 标记驻点
            chartG.append('circle')
                .attr('cx', xScale(1))
                .attr('cy', yScale(5))
                .attr('r', 5)
                .attr('fill', '#e74c3c');
            
            chartG.append('circle')
                .attr('cx', xScale(3))
                .attr('cy', yScale(1))
                .attr('r', 5)
                .attr('fill', '#e74c3c');
            
            // 标注
            chartG.append('text')
                .attr('x', xScale(1))
                .attr('y', yScale(5) - 10)
                .text('x=1')
                .style('font-size', '12px')
                .style('text-anchor', 'middle')
                .style('fill', '#e74c3c');
            
            chartG.append('text')
                .attr('x', xScale(3))
                .attr('y', yScale(1) - 10)
                .text('x=3')
                .style('font-size', '12px')
                .style('text-anchor', 'middle')
                .style('fill', '#e74c3c');
        }, 500);
        
        // 区间分析
        const intervals = [
            {
                range: '(-∞, 1)',
                derivative: 'f\'(x) > 0',
                monotonicity: '单调递增 ↗',
                color: '#27ae60'
            },
            {
                range: '(1, 3)',
                derivative: 'f\'(x) < 0',
                monotonicity: '单调递减 ↘',
                color: '#e74c3c'
            },
            {
                range: '(3, +∞)',
                derivative: 'f\'(x) > 0',
                monotonicity: '单调递增 ↗',
                color: '#27ae60'
            }
        ];
        
        intervals.forEach((interval, i) => {
            setTimeout(() => {
                const intervalDiv = mainContainer.append('div')
                    .style('margin-bottom', '10px')
                    .style('padding', '12px')
                    .style('background', 'rgba(255,255,255,0.95)')
                    .style('border-radius', '6px')
                    .style('border-left', `4px solid ${interval.color}`)
                    .style('display', 'flex')
                    .style('justify-content', 'space-between')
                    .style('align-items', 'center')
                    .style('opacity', '0');
                
                intervalDiv.append('div')
                    .style('font-weight', 'bold')
                    .style('color', '#2c3e50')
                    .text(interval.range);
                
                intervalDiv.append('div')
                    .style('color', '#666')
                    .text(interval.derivative);
                
                intervalDiv.append('div')
                    .style('color', interval.color)
                    .style('font-weight', 'bold')
                    .text(interval.monotonicity);
                
                intervalDiv.transition()
                    .duration(600)
                    .style('opacity', '1');
            }, 1000 + i * 500);
        });
    }

    // 第8页：极值概念
    function visualizeExtremumConcept(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-4, 4]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 函数 f(x) = x⁴ - 2x²
        const f = x => Math.pow(x, 4) - 2 * x * x;
        const data = d3.range(-2.5, 2.5, 0.05).map(x => ({x: x, y: f(x)}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 渐进绘制动画
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);
        
        // 标记极值点
        const extrema = [
            {x: -1, y: f(-1), type: '极小值', color: '#2ecc71'},
            {x: 0, y: f(0), type: '极大值', color: '#e74c3c'},
            {x: 1, y: f(1), type: '极小值', color: '#2ecc71'}
        ];
        
        extrema.forEach((point, i) => {
            setTimeout(() => {
                // 极值点
                g.append('circle')
                    .attr('cx', xScale(point.x))
                    .attr('cy', yScale(point.y))
                    .attr('r', 0)
                    .attr('fill', point.color)
                    .attr('class', 'pulse')
                    .transition()
                    .duration(500)
                    .attr('r', 10);
                
                // 标签
                g.append('text')
                    .attr('x', xScale(point.x))
                    .attr('y', yScale(point.y) + (point.type === '极大值' ? -20 : 30))
                    .text(point.type)
                    .style('font-size', '16px')
                    .style('font-weight', 'bold')
                    .style('text-anchor', 'middle')
                    .style('fill', point.color)
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
                
                // 水平切线
                g.append('line')
                    .attr('x1', xScale(point.x) - 30)
                    .attr('x2', xScale(point.x) + 30)
                    .attr('y1', yScale(point.y))
                    .attr('y2', yScale(point.y))
                    .attr('stroke', '#f39c12')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '3,3')
                    .attr('opacity', 0)
                    .transition()
                    .duration(500)
                    .attr('opacity', 0.7);
            }, 2500 + i * 500);
        });
    }

    // 第8页：极值判断
    function visualizeExtremumTest(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 函数和导数
        const f = x => x * x * x - 3 * x;
        const fPrime = x => 3 * x * x - 3;
        
        const data = d3.range(-3, 3.1, 0.05).map(x => ({x: x, y: f(x)}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 标记符号变化
        const criticalPoints = [-1, 1];
        
        criticalPoints.forEach((x0, i) => {
            const leftSign = fPrime(x0 - 0.1) > 0 ? '+' : '-';
            const rightSign = fPrime(x0 + 0.1) > 0 ? '+' : '-';
            
            setTimeout(() => {
                // 极值点
                g.append('circle')
                    .attr('cx', xScale(x0))
                    .attr('cy', yScale(f(x0)))
                    .attr('r', 0)
                    .attr('fill', leftSign === '+' && rightSign === '-' ? '#e74c3c' : '#2ecc71')
                    .transition()
                    .duration(500)
                    .attr('r', 10);
                
                // 导数符号
                g.append('text')
                    .attr('x', xScale(x0 - 0.5))
                    .attr('y', height - 10)
                    .text(leftSign)
                    .style('font-size', '20px')
                    .style('font-weight', 'bold')
                    .style('fill', leftSign === '+' ? '#2ecc71' : '#e74c3c')
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
                
                g.append('text')
                    .attr('x', xScale(x0 + 0.5))
                    .attr('y', height - 10)
                    .text(rightSign)
                    .style('font-size', '20px')
                    .style('font-weight', 'bold')
                    .style('fill', rightSign === '+' ? '#2ecc71' : '#e74c3c')
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
                
                // 箭头表示变化
                const arrow = g.append('text')
                    .attr('x', xScale(x0))
                    .attr('y', height - 10)
                    .style('font-size', '20px')
                    .style('text-anchor', 'middle')
                    .style('opacity', 0);
                
                if (leftSign === '+' && rightSign === '-') {
                    arrow.text('↘').style('fill', '#e74c3c');
                } else {
                    arrow.text('↗').style('fill', '#2ecc71');
                }
                
                arrow.transition()
                    .duration(500)
                    .style('opacity', 1);
            }, 1000 + i * 1000);
        });
    }

    // 第9页：最值问题
    function visualizeMaxMin(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([-1, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 10]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 在区间[0, 3]上的函数
        const f = x => x * x * x - 6 * x * x + 9 * x;
        const interval = [0, 3];
        
        // 绘制函数
        const data = d3.range(interval[0], interval[1] + 0.01, 0.05).map(x => ({x: x, y: f(x)}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 区间端点
        [interval[0], interval[1]].forEach(x => {
            g.append('line')
                .attr('x1', xScale(x))
                .attr('y1', yScale(-5))
                .attr('x2', xScale(x))
                .attr('y2', yScale(10))
                .attr('stroke', themeColors.muted)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('opacity', 0)
                .transition()
                .duration(500)
                .attr('opacity', 0.5);
        });
        
        // 标记关键点
        const points = [
            {x: 0, y: f(0), type: '端点'},
            {x: 1, y: f(1), type: '极大值'},
            {x: 3, y: f(3), type: '端点'}
        ];
        
        const maxPoint = points.reduce((max, p) => p.y > max.y ? p : max);
        const minPoint = points.reduce((min, p) => p.y < min.y ? p : min);
        
        points.forEach((point, i) => {
            setTimeout(() => {
                const isMax = point === maxPoint;
                const isMin = point === minPoint;
                
                g.append('circle')
                    .attr('cx', xScale(point.x))
                    .attr('cy', yScale(point.y))
                    .attr('r', 0)
                    .attr('fill', isMax ? '#e74c3c' : (isMin ? '#2ecc71' : '#f39c12'))
                    .attr('class', isMax || isMin ? 'pulse' : '')
                    .transition()
                    .duration(500)
                    .attr('r', 10);
                
                g.append('text')
                    .attr('x', xScale(point.x))
                    .attr('y', yScale(point.y) - 15)
                    .text(isMax ? '最大值' : (isMin ? '最小值' : point.type))
                    .style('font-size', '12px')
                    .style('text-anchor', 'middle')
                    .style('font-weight', 'bold')
                    .style('fill', isMax ? '#e74c3c' : (isMin ? '#2ecc71' : '#f39c12'))
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
            }, 1000 + i * 500);
        });
    }

    // 第17页：极值例题可视化
    function visualizeExtremumExample(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, svg, g, width, height } = setup;
        
        svg.selectAll("*").remove();
        
        const mainContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '0')
            .style('left', '0')
            .style('right', '0')
            .style('bottom', '0')
            .style('padding', '15px')
            .style('background', 'white')
            .style('border-radius', '8px')
            .style('overflow-y', 'auto')
            .style('font-family', 'inherit')
            .style('border', '1px solid #e0e0e0');
        
        // 创建SVG绘制函数图像
        const chartSvg = mainContainer.append('svg')
            .attr('width', '100%')
            .attr('height', '250px')
            .style('background', '#f8f9fa')
            .style('border-radius', '6px');
        
        const chartWidth = 350;
        const chartHeight = 230;
        const margin = {top: 20, right: 20, bottom: 30, left: 40};
        const innerWidth = chartWidth - margin.left - margin.right;
        const innerHeight = chartHeight - margin.top - margin.bottom;
        
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, innerWidth]);
        const yScale = d3.scaleLinear().domain([-15, 25]).range([innerHeight, 0]);
        
        const chartG = chartSvg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 坐标轴
        chartG.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(6))
            .style('color', '#666');
        
        chartG.append('g')
            .call(d3.axisLeft(yScale).ticks(6))
            .style('color', '#666');
        
        // 函数 f(x) = x³ - 12x + 5
        const data = [];
        for (let x = -3; x <= 3; x += 0.1) {
            const y = Math.pow(x, 3) - 12*x + 5;
            data.push({x: x, y: y});
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        setTimeout(() => {
            chartG.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 3)
                .attr('d', line);
            
            // 标记极值点
            chartG.append('circle')
                .attr('cx', xScale(-2))
                .attr('cy', yScale(21))
                .attr('r', 6)
                .attr('fill', '#27ae60');
            
            chartG.append('circle')
                .attr('cx', xScale(2))
                .attr('cy', yScale(-11))
                .attr('r', 6)
                .attr('fill', '#e74c3c');
            
            chartG.append('text')
                .attr('x', xScale(-2))
                .attr('y', yScale(21) - 12)
                .text('极大值(−2, 21)')
                .style('font-size', '10px')
                .style('text-anchor', 'middle')
                .style('fill', '#27ae60');
            
            chartG.append('text')
                .attr('x', xScale(2))
                .attr('y', yScale(-11) + 15)
                .text('极小值(2, −11)')
                .style('font-size', '10px')
                .style('text-anchor', 'middle')
                .style('fill', '#e74c3c');
        }, 500);
    }
    
    // 第21页：最值例题可视化
    function visualizeMaxMinExample(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, svg, g, width, height } = setup;
        
        svg.selectAll("*").remove();
        
        const mainContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '0')
            .style('left', '0')
            .style('right', '0')
            .style('bottom', '0')
            .style('padding', '15px')
            .style('background', 'white')
            .style('border-radius', '8px')
            .style('overflow-y', 'auto')
            .style('font-family', 'inherit')
            .style('border', '1px solid #e0e0e0');
        
        const chartSvg = mainContainer.append('svg')
            .attr('width', '100%')
            .attr('height', '250px')
            .style('background', '#f8f9fa')
            .style('border-radius', '6px');
        
        const chartWidth = 350;
        const chartHeight = 230;
        const margin = {top: 20, right: 20, bottom: 30, left: 40};
        const innerWidth = chartWidth - margin.left - margin.right;
        const innerHeight = chartHeight - margin.top - margin.bottom;
        
        const xScale = d3.scaleLinear().domain([-2.5, 3.5]).range([0, innerWidth]);
        const yScale = d3.scaleLinear().domain([-20, 15]).range([innerHeight, 0]);
        
        const chartG = chartSvg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 坐标轴
        chartG.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(6))
            .style('color', '#666');
        
        chartG.append('g')
            .call(d3.axisLeft(yScale).ticks(6))
            .style('color', '#666');
        
        // 函数 f(x) = 2x³ - 3x² - 12x + 5
        const data = [];
        for (let x = -2; x <= 3; x += 0.05) {
            const y = 2*Math.pow(x, 3) - 3*Math.pow(x, 2) - 12*x + 5;
            data.push({x: x, y: y});
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        setTimeout(() => {
            chartG.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 3)
                .attr('d', line);
            
            // 标记关键点
            const points = [
                {x: -2, y: 1, label: '(-2, 1)', color: '#95a5a6'},
                {x: -1, y: 12, label: '(-1, 12)', color: '#27ae60'},  // 最大值
                {x: 2, y: -15, label: '(2, -15)', color: '#e74c3c'},  // 最小值
                {x: 3, y: -4, label: '(3, -4)', color: '#95a5a6'}
            ];
            
            points.forEach(point => {
                chartG.append('circle')
                    .attr('cx', xScale(point.x))
                    .attr('cy', yScale(point.y))
                    .attr('r', 5)
                    .attr('fill', point.color);
                
                chartG.append('text')
                    .attr('x', xScale(point.x))
                    .attr('y', yScale(point.y) + (point.y > 0 ? -10 : 15))
                    .text(point.label)
                    .style('font-size', '9px')
                    .style('text-anchor', 'middle')
                    .style('fill', point.color);
            });
        }, 500);
    }

    // 第22页：利用导数求最值方法可视化
    function visualizeMaxValueMethod(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, svg, g, width, height } = setup;
        
        // 清除SVG，使用HTML展示步骤
        svg.selectAll("*").remove();
        
        const mainContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '0')
            .style('left', '0')
            .style('right', '0')
            .style('bottom', '0')
            .style('padding', '15px')
            .style('background', 'white')
            .style('border-radius', '8px')
            .style('overflow-y', 'auto')
            .style('font-family', 'inherit')
            .style('border', '1px solid #e0e0e0');
        
        // 标题
        mainContainer.append('div')
            .style('text-align', 'center')
            .style('margin-bottom', '15px')
            .style('padding', '10px')
            .style('background', 'rgba(255,255,255,0.9)')
            .style('border-radius', '6px')
            .style('color', '#2c3e50')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('函数最值分析');
        
        // 创建SVG用于绘制函数图像
        const chartSvg = mainContainer.append('svg')
            .attr('width', '100%')
            .attr('height', '200px')
            .style('background', '#f8f9fa')
            .style('border-radius', '6px')
            .style('margin-bottom', '15px');
        
        const chartWidth = 350;
        const chartHeight = 180;
        const margin = {top: 20, right: 20, bottom: 30, left: 30};
        const innerWidth = chartWidth - margin.left - margin.right;
        const innerHeight = chartHeight - margin.top - margin.bottom;
        
        const xScale = d3.scaleLinear().domain([-2.5, 2.5]).range([0, innerWidth]);
        const yScale = d3.scaleLinear().domain([-3, 3]).range([innerHeight, 0]);
        
        const chartG = chartSvg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 坐标轴
        chartG.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(5))
            .style('color', '#666');
        
        chartG.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale).ticks(6))
            .style('color', '#666');
        
        // 函数 f(x) = x³ - 3x 在 [-2, 2]
        const data = [];
        for (let x = -2; x <= 2; x += 0.1) {
            const y = Math.pow(x, 3) - 3*x;
            data.push({x: x, y: y});
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        // 绘制函数曲线
        setTimeout(() => {
            chartG.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 3)
                .attr('d', line);
            
            // 标记关键点
            const points = [
                {x: -2, y: -2, label: '(-2,-2)', color: '#e74c3c'},
                {x: -1, y: 2, label: '(-1,2)', color: '#27ae60'},
                {x: 1, y: -2, label: '(1,-2)', color: '#e74c3c'},
                {x: 2, y: 2, label: '(2,2)', color: '#27ae60'}
            ];
            
            points.forEach(point => {
                chartG.append('circle')
                    .attr('cx', xScale(point.x))
                    .attr('cy', yScale(point.y))
                    .attr('r', 5)
                    .attr('fill', point.color);
                
                chartG.append('text')
                    .attr('x', xScale(point.x))
                    .attr('y', yScale(point.y) - 10)
                    .text(point.label)
                    .style('font-size', '10px')
                    .style('text-anchor', 'middle')
                    .style('fill', point.color);
            });
        }, 500);
        
        // 最值分析
        setTimeout(() => {
            const resultDiv = mainContainer.append('div')
                .style('padding', '12px')
                .style('background', '#e8f5e8')
                .style('border-radius', '6px')
                .style('border', '2px solid #27ae60')
                .style('opacity', '0');
            
            resultDiv.append('div')
                .style('font-weight', 'bold')
                .style('color', '#27ae60')
                .style('margin-bottom', '8px')
                .style('font-size', '14px')
                .text('最值结果');
            
            resultDiv.append('div')
                .style('color', '#2c3e50')
                .style('margin-bottom', '4px')
                .text('最大值：2（在 x = -1, 2 处取得）');
            
            resultDiv.append('div')
                .style('color', '#2c3e50')
                .text('最小值：-2（在 x = -2, 1 处取得）');
            
            resultDiv.transition()
                .duration(600)
                .style('opacity', '1');
        }, 1500);
    }

    // 第11页：成本优化
    function visualizeCostOptimization(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([0, 12]).range([0, width]);
        const yScale = d3.scaleLinear().domain([70, 120]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 成本函数 C(x) = x² - 10x + 100
        const C = x => x * x - 10 * x + 100;
        
        const data = d3.range(0, 12, 0.1).map(x => ({x: x, y: C(x)}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 动画绘制
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);
        
        // 最小值点
        const minX = 5;
        const minY = C(minX);
        
        setTimeout(() => {
            g.append('circle')
                .attr('cx', xScale(minX))
                .attr('cy', yScale(minY))
                .attr('r', 0)
                .attr('fill', '#2ecc71')
                .attr('class', 'pulse')
                .transition()
                .duration(500)
                .attr('r', 10);
            
            // 标注
            g.append('text')
                .attr('x', xScale(minX))
                .attr('y', yScale(minY) - 20)
                .text(`最小成本: ${minY}万元`)
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .style('text-anchor', 'middle')
                .style('fill', '#2ecc71')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
            
            g.append('text')
                .attr('x', xScale(minX))
                .attr('y', yScale(minY) + 30)
                .text(`产量: ${minX}百件`)
                .style('font-size', '14px')
                .style('text-anchor', 'middle')
                .style('fill', '#34495e')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 2500);
        
        // 坐标轴标签
        g.append('text')
            .attr('x', width / 2)
            .attr('y', height + 35)
            .text('产量（百件）')
            .style('font-size', '14px')
            .style('text-anchor', 'middle');
        
        g.append('text')
            .attr('x', -height / 2)
            .attr('y', -25)
            .attr('transform', 'rotate(-90)')
            .text('成本（万元）')
            .style('font-size', '14px')
            .style('text-anchor', 'middle');
    }

    // 第11页：利润优化
    function visualizeProfitOptimization(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([0, 10]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-25, 20]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 利润函数 P(x) = -x² + 12x - 20
        const P = x => -x * x + 12 * x - 20;
        
        const data = d3.range(0, 10, 0.1).map(x => ({x: x, y: P(x)}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        // 动画绘制
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);
        
        // 最大值点
        const maxX = 6;
        const maxY = P(maxX);
        
        setTimeout(() => {
            g.append('circle')
                .attr('cx', xScale(maxX))
                .attr('cy', yScale(maxY))
                .attr('r', 0)
                .attr('fill', '#f39c12')
                .attr('class', 'pulse')
                .transition()
                .duration(500)
                .attr('r', 10);
            
            // 盈亏平衡点
            const breakEven1 = 2;
            const breakEven2 = 10;
            
            [breakEven1, breakEven2].forEach(x => {
                g.append('circle')
                    .attr('cx', xScale(x))
                    .attr('cy', yScale(0))
                    .attr('r', 0)
                    .attr('fill', themeColors.muted)
                    .transition()
                    .duration(500)
                    .attr('r', 6);
            });
            
            // 标注
            g.append('text')
                .attr('x', xScale(maxX))
                .attr('y', yScale(maxY) - 20)
                .text(`最大利润: ${maxY}万元`)
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .style('text-anchor', 'middle')
                .style('fill', '#f39c12')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 2500);
    }

    // 第12页：容器设计
    function visualizeContainerDesign(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;
        
        // 创建滑块控制
        const sliderContainer = container.append('div')
            .attr('class', 'slider-container');
        
        sliderContainer.append('label')
            .text('剪去正方形边长: ')
            .style('font-weight', 'bold');
        
        const valueDisplay = sliderContainer.append('span')
            .text('3.33 cm')
            .style('margin-left', '10px')
            .style('color', '#3498db');
        
        const slider = sliderContainer.append('input')
            .attr('type', 'range')
            .attr('min', '0')
            .attr('max', '10')
            .attr('step', '0.1')
            .attr('value', '3.33')
            .attr('class', 'slider')
            .style('margin-top', '10px');
        
        const xScale = d3.scaleLinear().domain([0, 10]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 700]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 容积函数 V(x) = x(20-2x)²
        const V = x => x * Math.pow(20 - 2 * x, 2);
        
        const data = d3.range(0.1, 10, 0.1).map(x => ({x: x, y: V(x)}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        const point = g.append('circle')
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('class', 'pulse');
        
        const volumeText = g.append('text')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .style('fill', '#e74c3c');
        
        // 更新函数
        function update(x) {
            const volume = V(x);
            
            point
                .attr('cx', xScale(x))
                .attr('cy', yScale(volume));
            
            volumeText
                .attr('x', xScale(x))
                .attr('y', yScale(volume) - 15)
                .text(`V = ${volume.toFixed(1)} cm³`)
                .style('text-anchor', 'middle');
            
            valueDisplay.text(`${x} cm`);
        }
        
        // 初始显示最优点
        update(10/3);
        
        // 滑块事件
        slider.on('input', function() {
            update(+this.value);
        });
        
        // 标注最优点
        g.append('line')
            .attr('x1', xScale(10/3))
            .attr('y1', yScale(0))
            .attr('x2', xScale(10/3))
            .attr('y2', yScale(V(10/3)))
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '3,3')
            .attr('opacity', 0.5);
    }

    // 第13页：凹凸性
    function visualizeConcavity(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 10]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 函数 f(x) = x³ - 3x²
        const f = x => x * x * x - 3 * x * x;
        
        const data = d3.range(-2, 3, 0.05).map(x => ({x: x, y: f(x)}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        // 凹向下区域
        g.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', xScale(1))
            .attr('height', height)
            .attr('fill', '#3498db')
            .attr('opacity', 0.1);
        
        // 凹向上区域
        g.append('rect')
            .attr('x', xScale(1))
            .attr('y', 0)
            .attr('width', width - xScale(1))
            .attr('height', height)
            .attr('fill', '#e74c3c')
            .attr('opacity', 0.1);
        
        // 函数曲线
        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#9b59b6')
            .attr('stroke-width', 3);
        
        // 动画绘制
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);
        
        // 拐点
        const inflectionX = 1;
        
        setTimeout(() => {
            g.append('circle')
                .attr('cx', xScale(inflectionX))
                .attr('cy', yScale(f(inflectionX)))
                .attr('r', 0)
                .attr('fill', '#f39c12')
                .transition()
                .duration(500)
                .attr('r', 8);
            
            g.append('text')
                .attr('x', xScale(inflectionX))
                .attr('y', yScale(f(inflectionX)) - 15)
                .text('拐点')
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('text-anchor', 'middle')
                .style('fill', '#f39c12')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 2500);
        
        // 标签
        setTimeout(() => {
            g.append('text')
                .attr('x', xScale(-1))
                .attr('y', 30)
                .text('凹向下 ∩')
                .style('font-size', '16px')
                .style('fill', '#3498db')
                .style('font-weight', 'bold')
                .style('text-anchor', 'middle')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
            
            g.append('text')
                .attr('x', xScale(2))
                .attr('y', 30)
                .text('凹向上 ∪')
                .style('font-size', '16px')
                .style('fill', '#e74c3c')
                .style('font-weight', 'bold')
                .style('text-anchor', 'middle')
                .style('opacity', 0)
                .transition()
                .duration(500)
                .style('opacity', 1);
        }, 3000);
    }

    // 第14页：凹凸性例题可视化
    function visualizeConcavityExample(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, svg, g, width, height } = setup;
        
        // 清除SVG，使用HTML展示步骤
        svg.selectAll("*").remove();
        
        const mainContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '0')
            .style('left', '0')
            .style('right', '0')
            .style('bottom', '0')
            .style('padding', '15px')
            .style('background', 'white')
            .style('border-radius', '8px')
            .style('overflow-y', 'auto')
            .style('font-family', 'inherit')
            .style('border', '1px solid #e0e0e0');
        
        // 标题
        mainContainer.append('div')
            .style('text-align', 'center')
            .style('margin-bottom', '15px')
            .style('padding', '10px')
            .style('background', 'rgba(255,255,255,0.9)')
            .style('border-radius', '6px')
            .style('color', '#2c3e50')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('函数的凹凸性分析');
        
        // 创建SVG用于绘制函数图像
        const chartSvg = mainContainer.append('svg')
            .attr('width', '100%')
            .attr('height', '200px')
            .style('background', '#f8f9fa')
            .style('border-radius', '6px')
            .style('margin-bottom', '15px');
        
        const chartWidth = 350;
        const chartHeight = 180;
        const margin = {top: 20, right: 20, bottom: 30, left: 30};
        const innerWidth = chartWidth - margin.left - margin.right;
        const innerHeight = chartHeight - margin.top - margin.bottom;
        
        const xScale = d3.scaleLinear().domain([-2.5, 2.5]).range([0, innerWidth]);
        const yScale = d3.scaleLinear().domain([-8, 8]).range([innerHeight, 0]);
        
        const chartG = chartSvg.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 坐标轴
        chartG.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).ticks(5))
            .style('color', '#666');
        
        chartG.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale).ticks(6))
            .style('color', '#666');
        
        // 函数 f(x) = x⁴ - 6x² + 3
        const data = [];
        for (let x = -2.2; x <= 2.2; x += 0.1) {
            const y = Math.pow(x, 4) - 6*Math.pow(x, 2) + 3;
            data.push({x: x, y: y});
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        // 绘制函数曲线
        setTimeout(() => {
            chartG.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 3)
                .attr('d', line);
            
            // 标记拐点
            chartG.append('circle')
                .attr('cx', xScale(-1))
                .attr('cy', yScale(-2))
                .attr('r', 5)
                .attr('fill', '#e74c3c');
            
            chartG.append('circle')
                .attr('cx', xScale(1))
                .attr('cy', yScale(-2))
                .attr('r', 5)
                .attr('fill', '#e74c3c');
            
            // 标注拐点
            chartG.append('text')
                .attr('x', xScale(-1))
                .attr('y', yScale(-2) - 10)
                .text('(-1,-2)')
                .style('font-size', '10px')
                .style('text-anchor', 'middle')
                .style('fill', '#e74c3c');
            
            chartG.append('text')
                .attr('x', xScale(1))
                .attr('y', yScale(-2) - 10)
                .text('(1,-2)')
                .style('font-size', '10px')
                .style('text-anchor', 'middle')
                .style('fill', '#e74c3c');
        }, 500);
        
        // 凹凸性分析
        const regions = [
            {
                range: '(-∞, -1)',
                secondDerivative: 'f\'\'(x) > 0',
                concavity: '凹向上 ∪',
                color: '#27ae60'
            },
            {
                range: '(-1, 1)',
                secondDerivative: 'f\'\'(x) < 0',
                concavity: '凹向下 ∩',
                color: '#e74c3c'
            },
            {
                range: '(1, +∞)',
                secondDerivative: 'f\'\'(x) > 0',
                concavity: '凹向上 ∪',
                color: '#27ae60'
            }
        ];
        
        regions.forEach((region, i) => {
            setTimeout(() => {
                const regionDiv = mainContainer.append('div')
                    .style('margin-bottom', '10px')
                    .style('padding', '12px')
                    .style('background', 'rgba(255,255,255,0.95)')
                    .style('border-radius', '6px')
                    .style('border-left', `4px solid ${region.color}`)
                    .style('display', 'flex')
                    .style('justify-content', 'space-between')
                    .style('align-items', 'center')
                    .style('opacity', '0');
                
                regionDiv.append('div')
                    .style('font-weight', 'bold')
                    .style('color', '#2c3e50')
                    .text(region.range);
                
                regionDiv.append('div')
                    .style('color', '#666')
                    .text(region.secondDerivative);
                
                regionDiv.append('div')
                    .style('color', region.color)
                    .style('font-weight', 'bold')
                    .text(region.concavity);
                
                regionDiv.transition()
                    .duration(600)
                    .style('opacity', '1');
            }, 1000 + i * 500);
        });
        
        // 拐点信息
        setTimeout(() => {
            const inflectionDiv = mainContainer.append('div')
                .style('margin-top', '15px')
                .style('padding', '12px')
                .style('background', '#fff3cd')
                .style('border-radius', '6px')
                .style('border', '1px solid #ffeaa7')
                .style('opacity', '0');
            
            inflectionDiv.append('div')
                .style('font-weight', 'bold')
                .style('color', '#856404')
                .style('margin-bottom', '5px')
                .text('拐点');
            
            inflectionDiv.append('div')
                .style('color', '#856404')
                .text('(-1, -2) 和 (1, -2) 是函数的拐点');
            
            inflectionDiv.transition()
                .duration(600)
                .style('opacity', '1');
        }, 3000);
    }

    // 第15页：曲线描绘
    function visualizeCurveSketching(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([-4, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 5]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 综合函数 f(x) = x³ - 3x
        const f = x => x * x * x - 3 * x;
        
        const data = d3.range(-3, 3, 0.05).map(x => ({x: x, y: f(x)}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        // 动画绘制曲线
        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        const totalLength = path.node().getTotalLength();
        
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(3000)
            .attr('stroke-dashoffset', 0);
        
        // 依次标记关键点
        const keyPoints = [
            {x: -1, y: 2, type: '极大值', color: '#e74c3c', delay: 1000},
            {x: 1, y: -2, type: '极小值', color: '#2ecc71', delay: 1500},
            {x: 0, y: 0, type: '拐点', color: '#f39c12', delay: 2000}
        ];
        
        keyPoints.forEach(point => {
            setTimeout(() => {
                g.append('circle')
                    .attr('cx', xScale(point.x))
                    .attr('cy', yScale(point.y))
                    .attr('r', 0)
                    .attr('fill', point.color)
                    .transition()
                    .duration(500)
                    .attr('r', 6);
                
                g.append('text')
                    .attr('x', xScale(point.x))
                    .attr('y', yScale(point.y) + (point.type === '极大值' ? -15 : 25))
                    .text(point.type)
                    .style('font-size', '12px')
                    .style('text-anchor', 'middle')
                    .style('fill', point.color)
                    .style('font-weight', 'bold')
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
            }, 3000 + point.delay);
        });
    }

    // 第15页：总结页可视化 - 精美升级版
    function visualizeSummary(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { svg, g, width, height } = setup;
        
        // 添加渐变
        const defs = svg.append('defs');
        
        // 发光效果
        const glow = defs.append('filter')
            .attr('id', 'glow');
        glow.append('feGaussianBlur')
            .attr('stdDeviation', '4')
            .attr('result', 'coloredBlur');
        const feMerge = glow.append('feMerge');
        feMerge.append('feMergeNode').attr('in', 'coloredBlur');
        feMerge.append('feMergeNode').attr('in', 'SourceGraphic');
        
        // 彩虹渐变
        const rainbow = defs.append('linearGradient')
            .attr('id', 'rainbow')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        ['#3498db', '#9b59b6', '#e74c3c', '#f39c12', '#2ecc71'].forEach((color, i) => {
            rainbow.append('stop')
                .attr('offset', `${i * 25}%`)
                .style('stop-color', color);
        });
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 中心大标题
        const titleGroup = g.append('g')
            .attr('transform', `translate(${centerX}, ${centerY - 150})`);
        
        titleGroup.append('text')
            .attr('text-anchor', 'middle')
            .attr('font-size', '48px')
            .attr('fill', 'url(#rainbow)')
            .attr('font-weight', 'bold')
            .text('导数应用')
            .style('opacity', 0)
            .style('filter', 'url(#glow)')
            .transition()
            .duration(1500)
            .style('opacity', 1);
        
        // 核心概念环形布局
        const concepts = [
            { text: '切线斜率', icon: 'triangle', color: '#3498db', angle: 0 },
            { text: '单调性', icon: 'trending-up', color: '#2ecc71', angle: 60 },
            { text: '极值', icon: 'star', color: '#f39c12', angle: 120 },
            { text: '最值', icon: 'target', color: '#e74c3c', angle: 180 },
            { text: '优化', icon: 'zap', color: '#9b59b6', angle: 240 },
            { text: '图像', icon: 'bar-chart', color: '#1abc9c', angle: 300 }
        ];
        
        const radius = 180;
        
        concepts.forEach((concept, i) => {
            const angle = (concept.angle * Math.PI) / 180;
            const x = centerX + Math.cos(angle) * radius;
            const y = centerY + Math.sin(angle) * radius;
            
            const group = g.append('g')
                .attr('transform', `translate(${x}, ${y})`)
                .style('opacity', 0);
            
            // 背景圆
            const bgCircle = group.append('circle')
                .attr('r', 50)
                .attr('fill', concept.color)
                .attr('opacity', 0.2)
                .attr('stroke', concept.color)
                .attr('stroke-width', 3);
            
            // 图标
            const iconGroup = group.append('g')
                .attr('transform', 'translate(-16, -16)');
            
            // 根据图标名称添加对应的SVG
            let iconSvg = '';
            switch(concept.icon) {
                case 'triangle':
                    iconSvg = '<path d="M10.29,3.86L1.82,18a2,2,0,0,0,1.71,3H20.47a2,2,0,0,0,1.71-3L13.71,3.86A2,2,0,0,0,10.29,3.86Z"></path>';
                    break;
                case 'trending-up':
                    iconSvg = '<polyline points="23,6 13.5,15.5 8.5,10.5 1,18"></polyline><polyline points="17,6 23,6 23,12"></polyline>';
                    break;
                case 'star':
                    iconSvg = '<polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"></polygon>';
                    break;
                case 'target':
                    iconSvg = '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>';
                    break;
                case 'zap':
                    iconSvg = '<polygon points="13,2 3,14 12,14 11,22 21,10 12,10"></polygon>';
                    break;
                case 'bar-chart':
                    iconSvg = '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>';
                    break;
            }
            
            iconGroup.append('svg')
                .attr('width', '32')
                .attr('height', '32')
                .attr('viewBox', '0 0 24 24')
                .attr('fill', 'none')
                .attr('stroke', concept.color)
                .attr('stroke-width', '2')
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .html(iconSvg);
            
            // 文字
            group.append('text')
                .attr('text-anchor', 'middle')
                .attr('y', 40)
                .attr('font-size', '16px')
                .attr('fill', concept.color)
                .attr('font-weight', 'bold')
                .text(concept.text);
            
            // 动画序列
            group.transition()
                .delay(800 + i * 200)
                .duration(800)
                .style('opacity', 1)
                .ease(d3.easeBackOut);
            
            // 脉冲效果
            function pulse() {
                bgCircle
                    .transition()
                    .duration(2000)
                    .attr('r', 55)
                    .attr('opacity', 0.4)
                    .transition()
                    .duration(2000)
                    .attr('r', 50)
                    .attr('opacity', 0.2)
                    .on('end', pulse);
            }
            setTimeout(() => pulse(), 1800 + i * 200);
            
            // 连线到中心
            g.append('line')
                .attr('x1', centerX)
                .attr('y1', centerY)
                .attr('x2', centerX)
                .attr('y2', centerY)
                .attr('stroke', concept.color)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('opacity', 0.3)
                .transition()
                .delay(1000 + i * 200)
                .duration(600)
                .attr('x2', x)
                .attr('y2', y);
        });
        
        // 中心核心符号 dy/dx
        const coreGroup = g.append('g')
            .attr('transform', `translate(${centerX}, ${centerY})`)
            .style('opacity', 0);
        
        coreGroup.append('circle')
            .attr('r', 60)
            .attr('fill', '#fff')
            .attr('stroke', 'url(#rainbow)')
            .attr('stroke-width', 4)
            .style('filter', 'drop-shadow(0 4px 12px rgba(0,0,0,0.2))');
        
        coreGroup.append('text')
            .attr('text-anchor', 'middle')
            .attr('y', -8)
            .attr('font-size', '28px')
            .attr('fill', '#3498db')
            .attr('font-weight', 'bold')
            .attr('font-style', 'italic')
            .text('dy');
        
        coreGroup.append('line')
            .attr('x1', -25)
            .attr('x2', 25)
            .attr('y1', 5)
            .attr('y2', 5)
            .attr('stroke', '#2c3e50')
            .attr('stroke-width', 2);
        
        coreGroup.append('text')
            .attr('text-anchor', 'middle')
            .attr('y', 25)
            .attr('font-size', '28px')
            .attr('fill', '#e74c3c')
            .attr('font-weight', 'bold')
            .attr('font-style', 'italic')
            .text('dx');
        
        coreGroup.transition()
            .delay(2400)
            .duration(1000)
            .style('opacity', 1)
            .ease(d3.easeBackOut);
        
        // 旋转动画
        function rotateCoreGroup() {
            coreGroup
                .transition()
                .duration(20000)
                .ease(d3.easeLinear)
                .attrTween('transform', function() {
                    return d3.interpolateString(
                        `translate(${centerX}, ${centerY}) rotate(0)`,
                        `translate(${centerX}, ${centerY}) rotate(360)`
                    );
                })
                .on('end', rotateCoreGroup);
        }
        setTimeout(rotateCoreGroup, 3500);
        
        // 底部总结文字
        const summaryText = g.append('g')
            .attr('transform', `translate(${centerX}, ${height - 40})`)
            .style('opacity', 0);
        
        summaryText.append('text')
            .attr('text-anchor', 'middle')
            .attr('font-size', '24px')
            .attr('fill', '#16a085')
            .attr('font-weight', 'bold')
            .text('导数 · 变化之道')
            .style('filter', 'url(#glow)');
        
        summaryText.transition()
            .delay(3000)
            .duration(1500)
            .style('opacity', 1);
        
        // 星星装饰
        for (let i = 0; i < 20; i++) {
            const starX = Math.random() * width;
            const starY = Math.random() * height;
            const starSize = 2 + Math.random() * 3;
            
            g.append('circle')
                .attr('cx', starX)
                .attr('cy', starY)
                .attr('r', 0)
                .attr('fill', ['#3498db', '#e74c3c', '#f39c12', '#2ecc71', '#9b59b6'][i % 5])
                .attr('opacity', 0.6)
                .transition()
                .delay(3500 + Math.random() * 2000)
                .duration(800)
                .attr('r', starSize)
                .transition()
                .duration(1500)
                .attr('opacity', 0.2)
                .on('end', function() {
                    d3.select(this)
                        .transition()
                        .duration(1500)
                        .attr('opacity', 0.6)
                        .on('end', function repeat() {
                            d3.select(this)
                                .transition()
                                .duration(1500)
                                .attr('opacity', 0.2)
                                .transition()
                                .duration(1500)
                                .attr('opacity', 0.6)
                                .on('end', repeat);
                        });
                });
        }
    }

    // 第7页：洛必达法则可视化 - 解题步骤展示
    function visualizeLHopital(containerId) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) return;
        
        // 清除所有内容，使用HTML展示步骤
        container.html('');
        
        const mainContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '0')
            .style('left', '0')
            .style('right', '0')
            .style('bottom', '0')
            .style('padding', '15px')
            .style('background', 'white')
            .style('border-radius', '8px')
            .style('overflow-y', 'auto')
            .style('font-family', 'inherit')
            .style('border', '1px solid #e0e0e0');
        
        // 标题
        mainContainer.append('div')
            .style('text-align', 'center')
            .style('margin-bottom', '15px')
            .style('padding', '10px')
            .style('background', 'rgba(255,255,255,0.9)')
            .style('border-radius', '6px')
            .style('color', '#2c3e50')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('洛必达法则应用指南');
        
        const steps = [
            {
                title: '识别未定式',
                content: '检查极限是否为 0/0 或 ∞/∞ 型',
                icon: 'search',
                color: '#3498db'
            },
            {
                title: '分别求导',
                content: '对分子分母分别求导数',
                icon: 'edit',
                color: '#e74c3c'
            },
            {
                title: '计算新极限',
                content: '计算导数比值的极限',
                icon: 'target',
                color: '#f39c12'
            },
            {
                title: '重复应用',
                content: '如仍为未定式，继续应用',
                icon: 'refresh-cw',
                color: '#27ae60'
            }
        ];
        
        steps.forEach((step, i) => {
            setTimeout(() => {
                const stepDiv = mainContainer.append('div')
                    .style('margin-bottom', '10px')
                    .style('padding', '12px')
                    .style('background', 'rgba(255,255,255,0.95)')
                    .style('border-radius', '6px')
                    .style('border-left', `4px solid ${step.color}`)
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('opacity', '0')
                    .style('transform', 'translateX(-20px)');
                
                const iconDiv = stepDiv.append('div')
                    .style('width', '20px')
                    .style('height', '20px')
                    .style('margin-right', '10px')
                    .style('flex-shrink', '0');
                
                // 根据图标名称添加对应的SVG
                let iconSvg = '';
                switch(step.icon) {
                    case 'search':
                        iconSvg = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${step.color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>`;
                        break;
                    case 'edit':
                        iconSvg = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${step.color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>`;
                        break;
                    case 'target':
                        iconSvg = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${step.color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>`;
                        break;
                    case 'refresh-cw':
                        iconSvg = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="${step.color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23,4 23,10 17,10"></polyline><polyline points="1,20 1,14 7,14"></polyline><path d="M20.49,9A9,9,0,0,0,5.64,5.64L1,10m22,4L18.36,18.36A9,9,0,0,1,3.51,15"></path></svg>`;
                        break;
                }
                iconDiv.html(iconSvg);
                
                const textDiv = stepDiv.append('div');
                textDiv.append('div')
                    .style('font-weight', 'bold')
                    .style('color', step.color)
                    .style('font-size', '16px')
                    .text(step.title);
                
                textDiv.append('div')
                    .style('color', '#34495e')
                    .style('font-size', '12px')
                    .text(step.content);
                
                stepDiv.transition()
                    .duration(600)
                    .ease(d3.easeBackOut)
                    .style('opacity', '1')
                    .style('transform', 'translateX(0px)');
            }, i * 800);
        });
    }

    // 第8页：洛必达法则解题步骤可视化
    function visualizeLHopitalExamples(containerId) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) return;
        
        // 清除所有内容，使用HTML展示步骤
        container.html('');
        
        const mainContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '0')
            .style('left', '0')
            .style('right', '0')
            .style('bottom', '0')
            .style('padding', '15px')
            .style('background', 'white')
            .style('border-radius', '8px')
            .style('overflow-y', 'auto')
            .style('font-family', 'inherit')
            .style('border', '1px solid #e0e0e0');
        
        // 标题
        mainContainer.append('div')
            .style('text-align', 'center')
            .style('margin-bottom', '15px')
            .style('padding', '10px')
            .style('background', 'rgba(255,255,255,0.9)')
            .style('border-radius', '6px')
            .style('color', '#2c3e50')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('解题流程图');
        
        const flowSteps = [
            {
                step: '1',
                title: '验证未定式',
                description: '代入极限值检查',
                examples: ['0/0', '∞/∞'],
                color: '#e17055'
            },
            {
                step: '2', 
                title: '分别求导',
                description: '对分子分母求导',
                examples: ['f\'(x)', 'g\'(x)'],
                color: '#fdcb6e'
            },
            {
                step: '3',
                title: '计算极限',
                description: '求新比值的极限',
                examples: ['lim f\'(x)/g\'(x)'],
                color: '#00b894'
            },
            {
                step: '4',
                title: '检查结果',
                description: '若仍未定式则重复',
                examples: ['得到答案', '继续应用'],
                color: '#6c5ce7'
            }
        ];
        
        flowSteps.forEach((step, i) => {
            setTimeout(() => {
                const stepContainer = mainContainer.append('div')
                    .style('margin-bottom', '12px')
                    .style('padding', '12px')
                    .style('background', 'rgba(255,255,255,0.95)')
                    .style('border-radius', '8px')
                    .style('border-left', `5px solid ${step.color}`)
                    .style('opacity', '0')
                    .style('transform', 'scale(0.8)');
                
                const headerDiv = stepContainer.append('div')
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('margin-bottom', '8px');
                
                headerDiv.append('div')
                    .style('width', '30px')
                    .style('height', '30px')
                    .style('border-radius', '50%')
                    .style('background', step.color)
                    .style('color', 'white')
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('justify-content', 'center')
                    .style('font-weight', 'bold')
                    .style('margin-right', '10px')
                    .text(step.step);
                
                const textDiv = headerDiv.append('div');
                textDiv.append('div')
                    .style('font-weight', 'bold')
                    .style('color', '#2c3e50')
                    .style('font-size', '16px')
                    .text(step.title);
                
                textDiv.append('div')
                    .style('color', '#636e72')
                    .style('font-size', '12px')
                    .text(step.description);
                
                const exampleDiv = stepContainer.append('div')
                    .style('margin-top', '8px')
                    .style('padding', '6px')
                    .style('background', '#f8f9fa')
                    .style('border-radius', '4px')
                    .style('font-size', '11px')
                    .style('color', '#495057');
                
                step.examples.forEach(example => {
                    exampleDiv.append('span')
                        .style('display', 'inline-block')
                        .style('margin-right', '8px')
                        .style('padding', '2px 6px')
                        .style('background', 'white')
                        .style('border-radius', '3px')
                        .style('border', '1px solid #dee2e6')
                        .text(example);
                });
                
                stepContainer.transition()
                    .duration(800)
                    .ease(d3.easeBackOut)
                    .style('opacity', '1')
                    .style('transform', 'scale(1)');
                
                // 添加箭头（除了最后一步）
                if (i < flowSteps.length - 1) {
                    setTimeout(() => {
                        mainContainer.append('div')
                            .style('text-align', 'center')
                            .style('margin', '5px 0')
                            .style('opacity', '0')
                            .html('<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#666" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6,9 12,15 18,9"></polyline></svg>')
                            .transition()
                            .duration(400)
                            .style('opacity', '1');
                    }, 400);
                }
            }, i * 1000);
        });
    }

    function drawLHopitalExample1(g, width, height) {
        const xScale = d3.scaleLinear().domain([-1, 1]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 1.2]).range([height, 0]);
        
        // 标题
        g.append('text')
            .attr('x', width/2)
            .attr('y', 20)
            .text('sin(x)/x')
            .style('font-size', '16px')
            .style('text-anchor', 'middle')
            .style('font-weight', 'bold');
        
        // 函数曲线
        const data = [];
        for (let x = -0.9; x <= 0.9; x += 0.02) {
            if (Math.abs(x) > 0.01) {
                data.push({x: x, y: Math.sin(x) / x});
            }
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .datum(data)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2)
            .attr('d', line);
        
        // 极限点
        g.append('circle')
            .attr('cx', xScale(0))
            .attr('cy', yScale(1))
            .attr('r', 4)
            .attr('fill', '#e74c3c');
    }

    function drawLHopitalExample2(g, width, height) {
        const xScale = d3.scaleLinear().domain([0, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 20]).range([height, 0]);
        
        // 标题
        g.append('text')
            .attr('x', width/2)
            .attr('y', 20)
            .text('e^x/x²')
            .style('font-size', '16px')
            .style('text-anchor', 'middle')
            .style('font-weight', 'bold');
        
        // 函数曲线
        const data = [];
        for (let x = 0.1; x <= 3; x += 0.05) {
            const y = Math.exp(x) / (x * x);
            if (y < 20) {
                data.push({x: x, y: y});
            }
        }
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .datum(data)
            .attr('fill', 'none')
            .attr('stroke', '#9b59b6')
            .attr('stroke-width', 2)
            .attr('d', line);
    }

        // 第14页：相关变化率解题步骤可视化
    function visualizeRelatedRates(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, svg, g, width, height } = setup;
        
        // 清除SVG，使用HTML展示步骤
        svg.selectAll("*").remove();
        
        const mainContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '0')
            .style('left', '0')
            .style('right', '0')
            .style('bottom', '0')
            .style('padding', '15px')
            .style('background', 'white')
            .style('border-radius', '8px')
            .style('overflow-y', 'auto')
            .style('font-family', 'inherit')
            .style('border', '1px solid #e0e0e0');
        
        // 标题
        mainContainer.append('div')
            .style('text-align', 'center')
            .style('margin-bottom', '15px')
            .style('padding', '10px')
            .style('background', 'rgba(255,255,255,0.9)')
            .style('border-radius', '6px')
            .style('color', '#2c3e50')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .text('相关变化率解题步骤');
        
        const steps = [
            {
                step: '1',
                title: '建立关系式',
                content: '找出各变量间的函数关系',
                example: 'V = (4/3)πr³',
                color: '#e17055'
            },
            {
                step: '2',
                title: '对时间求导',
                content: '利用链式法则对t求导',
                example: 'dV/dt = 4πr² · dr/dt',
                color: '#fdcb6e'
            },
            {
                step: '3',
                title: '代入已知条件',
                content: '将已知的变化率和数值代入',
                example: 'dr/dt = 2 cm/s, r = 10 cm',
                color: '#00b894'
            },
            {
                step: '4',
                title: '计算结果',
                content: '求出所需的变化率',
                example: 'dV/dt = 4π×10²×2 = 800π',
                color: '#6c5ce7'
            }
        ];
        
        steps.forEach((step, i) => {
            setTimeout(() => {
                const stepContainer = mainContainer.append('div')
                    .style('margin-bottom', '12px')
                    .style('padding', '12px')
                    .style('background', 'rgba(255,255,255,0.95)')
                    .style('border-radius', '8px')
                    .style('border-left', `5px solid ${step.color}`)
                    .style('opacity', '0')
                    .style('transform', 'translateX(-30px)');
                
                const headerDiv = stepContainer.append('div')
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('margin-bottom', '8px');
                
                headerDiv.append('div')
                    .style('width', '30px')
                    .style('height', '30px')
                    .style('border-radius', '50%')
                    .style('background', step.color)
                    .style('color', 'white')
                    .style('display', 'flex')
                    .style('align-items', 'center')
                    .style('justify-content', 'center')
                    .style('font-weight', 'bold')
                    .style('margin-right', '10px')
                    .text(step.step);
                
                const textDiv = headerDiv.append('div');
                textDiv.append('div')
                    .style('font-weight', 'bold')
                    .style('color', '#2c3e50')
                    .style('font-size', '16px')
                    .text(step.title);
                
                textDiv.append('div')
                    .style('color', '#636e72')
                    .style('font-size', '12px')
                    .text(step.content);
                
                stepContainer.append('div')
                    .style('margin-top', '8px')
                    .style('padding', '8px')
                    .style('background', '#f1f2f6')
                    .style('border-radius', '4px')
                    .style('font-size', '12px')
                    .style('color', '#2c3e50')
                    .style('font-family', 'monospace')
                    .style('border', '1px solid #ddd')
                    .text(step.example);
                
                stepContainer.transition()
                    .duration(800)
                    .ease(d3.easeBackOut)
                    .style('opacity', '1')
                    .style('transform', 'translateX(0px)');
            }, i * 1200);
        });
        
        // 添加解题要点
        setTimeout(() => {
            const tipsContainer = mainContainer.append('div')
                .style('margin-top', '15px')
                .style('padding', '12px')
                .style('background', 'rgba(255,255,255,0.95)')
                .style('border-radius', '8px')
                .style('border', '2px solid #00b894')
                .style('opacity', '0');
            
            const tipsHeader = tipsContainer.append('div')
                .style('display', 'flex')
                .style('align-items', 'center')
                .style('margin-bottom', '8px');
            
            tipsHeader.append('div')
                .style('width', '16px')
                .style('height', '16px')
                .style('margin-right', '8px')
                .html('<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#00b894" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M9.09,9a3,3,0,0,1,5.83,1c0,2-3,3-3,3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>');
            
            tipsHeader.append('div')
                .style('font-weight', 'bold')
                .style('color', '#00b894')
                .style('font-size', '14px')
                .text('解题要点');
            
            const tips = [
                '• 正确识别变量间的几何或物理关系',
                '• 注意变化率的正负号含义',
                '• 代入数值时要对应具体时刻'
            ];
            
            tips.forEach(tip => {
                tipsContainer.append('div')
                    .style('margin-bottom', '4px')
                    .style('font-size', '12px')
                    .style('color', '#2c3e50')
                    .text(tip);
            });
            
            tipsContainer.transition()
                .duration(800)
                .style('opacity', '1');
        }, steps.length * 1200 + 500);
    }

    // 第15页：边际分析可视化
    function visualizeMarginalAnalysis(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([0, 300]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 15]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 边际成本 MC = 2 + 0.02x
        const mcData = d3.range(0, 301, 5).map(x => ({x: x, y: 2 + 0.02 * x}));
        // 边际收益 MR = 10 - 0.04x
        const mrData = d3.range(0, 251, 5).map(x => ({x: x, y: 10 - 0.04 * x}));
        
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        // 绘制MC曲线
        g.append('path')
            .datum(mcData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        // 绘制MR曲线
        g.append('path')
            .datum(mrData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3);
        
        // 交点（最优产量）
        const optimalX = 200; // 求解 2 + 0.02x = 10 - 0.04x
        const optimalY = 2 + 0.02 * optimalX;
        
        setTimeout(() => {
            g.append('circle')
                .attr('cx', xScale(optimalX))
                .attr('cy', yScale(optimalY))
                .attr('r', 0)
                .attr('fill', '#f39c12')
                .transition()
                .duration(500)
                .attr('r', 8);
            
            g.append('text')
                .attr('x', xScale(optimalX))
                .attr('y', yScale(optimalY) - 15)
                .text('最优产量')
                .style('font-size', '14px')
                .style('text-anchor', 'middle')
                .style('fill', '#f39c12')
                .style('font-weight', 'bold');
        }, 1000);
        
        // 图例
        const legend = g.append('g')
            .attr('transform', `translate(${width - 100}, 20)`);
        
        legend.append('line')
            .attr('x1', 0).attr('y1', 0)
            .attr('x2', 30).attr('y2', 0)
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        legend.append('text')
            .attr('x', 35).attr('y', 5)
            .text('MC')
            .style('font-size', '14px');
        
        legend.append('line')
            .attr('x1', 0).attr('y1', 20)
            .attr('x2', 30).attr('y2', 20)
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3);
        legend.append('text')
            .attr('x', 35).attr('y', 25)
            .text('MR')
            .style('font-size', '14px');
    }

    // 第16页：需求弹性可视化
    function visualizeElasticity(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        const xScale = d3.scaleLinear().domain([0, 50]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 100]).range([height, 0]);
        
        drawAxes(g, xScale, yScale, width, height);
        
        // 需求曲线 Q = 100 - 2P
        const demandData = d3.range(0, 51, 1).map(p => ({x: p, y: 100 - 2 * p}));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        g.append('path')
            .datum(demandData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 标记不同弹性区域
        const elasticRegion = g.append('rect')
            .attr('x', xScale(25))
            .attr('y', yScale(50))
            .attr('width', xScale(25))
            .attr('height', yScale(0) - yScale(50))
            .attr('fill', '#2ecc71')
            .attr('opacity', 0.2);
        
        const inelasticRegion = g.append('rect')
            .attr('x', xScale(0))
            .attr('y', yScale(100))
            .attr('width', xScale(25))
            .attr('height', yScale(50) - yScale(100))
            .attr('fill', '#e74c3c')
            .attr('opacity', 0.2);
        
        // 标签
        g.append('text')
            .attr('x', xScale(37.5))
            .attr('y', yScale(25))
            .text('富有弹性')
            .style('font-size', '14px')
            .style('text-anchor', 'middle')
            .style('fill', '#2ecc71')
            .style('font-weight', 'bold');
        
        g.append('text')
            .attr('x', xScale(12.5))
            .attr('y', yScale(75))
            .text('缺乏弹性')
            .style('font-size', '14px')
            .style('text-anchor', 'middle')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold');
        
        // 单位弹性点
        g.append('circle')
            .attr('cx', xScale(25))
            .attr('cy', yScale(50))
            .attr('r', 6)
            .attr('fill', '#f39c12');
        
        g.append('text')
            .attr('x', xScale(25))
            .attr('y', yScale(50) - 15)
            .text('单位弹性')
            .style('font-size', '12px')
            .style('text-anchor', 'middle')
            .style('fill', '#f39c12')
            .style('font-weight', 'bold');
    }

    // 第24页：洛必达法则练习可视化 - 专注于解题步骤
    function visualizePractice1(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, svg, g, width, height } = setup;
        
        // 清除SVG内容，专注于步骤显示
        svg.selectAll("*").remove();
        
        // 创建主容器
        const mainContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '0')
            .style('left', '0')
            .style('right', '0')
            .style('bottom', '0')
            .style('padding', '20px')
            .style('background', 'white')
            .style('border-radius', '8px')
            .style('overflow-y', 'auto')
            .style('font-family', 'inherit')
            .style('border', '1px solid #e0e0e0');
        
        // 标题
        const titleDiv = mainContainer.append('div')
            .style('text-align', 'center')
            .style('margin-bottom', '20px')
            .style('padding', '10px')
            .style('background', 'rgba(255,255,255,0.9)')
            .style('border-radius', '8px')
            .style('box-shadow', '0 2px 10px rgba(0,0,0,0.1)');
        
        titleDiv.append('h3')
            .style('margin', '0')
            .style('color', '#2c3e50')
            .style('font-size', '18px')
            .text('洛必达法则解题步骤');
        
        titleDiv.append('div')
            .style('margin-top', '5px')
            .style('color', '#7f8c8d')
            .style('font-size', '14px')
            .html('求解：$\\lim_{x \\to 0} \\frac{e^x - 1 - x}{x^2}$');
        
        // 解题步骤 - 详细版本
        const steps = [
            {
                title: '第1步：验证未定式类型',
                formula: '当 $x \\to 0$ 时：',
                content: [
                    '分子：$e^0 - 1 - 0 = 1 - 1 - 0 = 0$',
                    '分母：$0^2 = 0$',
                    '确认为 $\\frac{0}{0}$ 型，可使用洛必达法则 ✓'
                ],
                delay: 0,
                color: '#3498db'
            },
            {
                title: '第2步：第一次应用洛必达法则',
                formula: '对分子分母分别求导：',
                content: [
                    '$(e^x - 1 - x)\' = e^x - 1$',
                    '$(x^2)\' = 2x$',
                    '$\\lim_{x \\to 0} \\frac{e^x - 1 - x}{x^2} = \\lim_{x \\to 0} \\frac{e^x - 1}{2x}$'
                ],
                delay: 2000,
                color: '#e74c3c'
            },
            {
                title: '第3步：再次验证未定式类型',
                formula: '当 $x \\to 0$ 时：',
                content: [
                    '分子：$e^0 - 1 = 1 - 1 = 0$',
                    '分母：$2 \\cdot 0 = 0$',
                    '仍为 $\\frac{0}{0}$ 型，继续应用洛必达法则'
                ],
                delay: 4000,
                color: '#f39c12'
            },
            {
                title: '第4步：第二次应用洛必达法则',
                formula: '再次对分子分母求导：',
                content: [
                    '$(e^x - 1)\' = e^x$',
                    '$(2x)\' = 2$',
                    '$\\lim_{x \\to 0} \\frac{e^x - 1}{2x} = \\lim_{x \\to 0} \\frac{e^x}{2}$'
                ],
                delay: 6000,
                color: '#9b59b6'
            },
            {
                title: '第5步：计算最终结果',
                formula: '代入极限值：',
                content: [
                    '$\\lim_{x \\to 0} \\frac{e^x}{2} = \\frac{e^0}{2} = \\frac{1}{2}$'
                ],
                delay: 8000,
                color: '#27ae60'
            }
        ];
        
        // 显示步骤
        steps.forEach((step, i) => {
            setTimeout(() => {
                const stepContainer = mainContainer.append('div')
                    .style('margin-bottom', '15px')
                    .style('background', 'rgba(255,255,255,0.95)')
                    .style('border-radius', '8px')
                    .style('padding', '15px')
                    .style('border-left', `5px solid ${step.color}`)
                    .style('box-shadow', '0 2px 10px rgba(0,0,0,0.1)')
                    .style('opacity', '0')
                    .style('transform', 'translateY(20px)');
                
                // 步骤标题
                stepContainer.append('div')
                    .style('font-weight', 'bold')
                    .style('color', step.color)
                    .style('font-size', '16px')
                    .style('margin-bottom', '10px')
                    .text(step.title);
                
                // 公式说明
                if (step.formula) {
                    stepContainer.append('div')
                        .style('color', '#2c3e50')
                        .style('font-size', '16px')
                        .style('margin-bottom', '8px')
                        .style('font-style', 'italic')
                        .html(step.formula);
                }
                
                // 步骤内容
                step.content.forEach(content => {
                    stepContainer.append('div')
                        .style('color', '#34495e')
                        .style('font-size', '16px')
                        .style('line-height', '1.6')
                        .style('margin-bottom', '5px')
                        .style('padding-left', '10px')
                        .html(content);
                });
                
                // 动画效果
                stepContainer.transition()
                    .duration(800)
                    .ease(d3.easeBackOut)
                    .style('opacity', '1')
                    .style('transform', 'translateY(0px)');
                
                // 如果是最后一步，添加最终答案高亮
                if (i === steps.length - 1) {
                    setTimeout(() => {
                        const answerBox = mainContainer.append('div')
                            .style('margin-top', '20px')
                            .style('padding', '20px')
                            .style('background', '#f8f9fa')
                            .style('color', '#2c3e50')
                            .style('border-radius', '10px')
                            .style('text-align', 'center')
                            .style('border', '2px solid #27ae60')
                            .style('opacity', '0');
                        
                        answerBox.append('div')
                            .style('font-size', '18px')
                            .style('font-weight', 'bold')
                            .style('margin-bottom', '10px')
                            .text('最终答案');
                        
                        answerBox.append('div')
                            .style('font-size', '24px')
                            .style('font-weight', 'bold')
                            .html('$\\lim_{x \\to 0} \\frac{e^x - 1 - x}{x^2} = \\frac{1}{2}$');
                        
                        answerBox.transition()
                            .duration(1000)
                            .ease(d3.easeBackOut)
                            .style('opacity', '1');
                        
                        // 触发MathJax渲染最终答案
                        setTimeout(() => {
                            if (window.MathJax && window.MathJax.typesetPromise) {
                                window.MathJax.typesetPromise([answerBox.node()]);
                            }
                        }, 100);
                    }, 1000);
                }
            }, step.delay);
        });
        
        // 触发MathJax渲染所有数学公式
        setTimeout(() => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise([mainContainer.node()]);
            }
        }, 500);
        
        // 每次添加新步骤后重新渲染MathJax
        steps.forEach((step, i) => {
            setTimeout(() => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    window.MathJax.typesetPromise([mainContainer.node()]);
                }
            }, step.delay + 1000);
        });
    }

    // 第19页：优化问题练习可视化
    function visualizePractice2(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 绘制圆柱体示意图
        let currentR = 50;
        let currentH = 100;
        
        // 圆柱体底面
        const bottomEllipse = g.append('ellipse')
            .attr('cx', centerX)
            .attr('cy', centerY + currentH/2)
            .attr('rx', currentR)
            .attr('ry', currentR * 0.3)
            .attr('fill', '#3498db')
            .attr('opacity', 0.6)
            .attr('stroke', '#2980b9')
            .attr('stroke-width', 2);
        
        // 圆柱体顶面
        const topEllipse = g.append('ellipse')
            .attr('cx', centerX)
            .attr('cy', centerY - currentH/2)
            .attr('rx', currentR)
            .attr('ry', currentR * 0.3)
            .attr('fill', '#3498db')
            .attr('opacity', 0.8)
            .attr('stroke', '#2980b9')
            .attr('stroke-width', 2);
        
        // 圆柱体侧面
        const leftSide = g.append('line')
            .attr('x1', centerX - currentR)
            .attr('y1', centerY - currentH/2)
            .attr('x2', centerX - currentR)
            .attr('y2', centerY + currentH/2)
            .attr('stroke', '#2980b9')
            .attr('stroke-width', 2);
        
        const rightSide = g.append('line')
            .attr('x1', centerX + currentR)
            .attr('y1', centerY - currentH/2)
            .attr('x2', centerX + currentR)
            .attr('y2', centerY + currentH/2)
            .attr('stroke', '#2980b9')
            .attr('stroke-width', 2);
        
        // 标注半径和高度
        const radiusLine = g.append('line')
            .attr('x1', centerX)
            .attr('y1', centerY + currentH/2)
            .attr('x2', centerX + currentR)
            .attr('y2', centerY + currentH/2)
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2);
        
        const radiusLabel = g.append('text')
            .attr('x', centerX + currentR/2)
            .attr('y', centerY + currentH/2 - 10)
            .text('r')
            .style('font-size', '16px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold')
            .style('text-anchor', 'middle');
        
        const heightLine = g.append('line')
            .attr('x1', centerX + currentR + 20)
            .attr('y1', centerY - currentH/2)
            .attr('x2', centerX + currentR + 20)
            .attr('y2', centerY + currentH/2)
            .attr('stroke', '#27ae60')
            .attr('stroke-width', 2);
        
        const heightLabel = g.append('text')
            .attr('x', centerX + currentR + 35)
            .attr('y', centerY)
            .text('h')
            .style('font-size', '16px')
            .style('fill', '#27ae60')
            .style('font-weight', 'bold')
            .style('text-anchor', 'middle');
        
        // 显示最优比例
        setTimeout(() => {
            // 调整到最优比例 h:r = 2:1
            const optimalR = 60;
            const optimalH = 120;
            
            // 动画调整圆柱体
            bottomEllipse.transition()
                .duration(2000)
                .attr('rx', optimalR)
                .attr('ry', optimalR * 0.3)
                .attr('cy', centerY + optimalH/2);
            
            topEllipse.transition()
                .duration(2000)
                .attr('rx', optimalR)
                .attr('ry', optimalR * 0.3)
                .attr('cy', centerY - optimalH/2);
            
            leftSide.transition()
                .duration(2000)
                .attr('x1', centerX - optimalR)
                .attr('x2', centerX - optimalR)
                .attr('y1', centerY - optimalH/2)
                .attr('y2', centerY + optimalH/2);
            
            rightSide.transition()
                .duration(2000)
                .attr('x1', centerX + optimalR)
                .attr('x2', centerX + optimalR)
                .attr('y1', centerY - optimalH/2)
                .attr('y2', centerY + optimalH/2);
            
            radiusLine.transition()
                .duration(2000)
                .attr('x2', centerX + optimalR)
                .attr('y1', centerY + optimalH/2)
                .attr('y2', centerY + optimalH/2);
            
            radiusLabel.transition()
                .duration(2000)
                .attr('x', centerX + optimalR/2)
                .attr('y', centerY + optimalH/2 - 10);
            
            heightLine.transition()
                .duration(2000)
                .attr('x1', centerX + optimalR + 20)
                .attr('x2', centerX + optimalR + 20)
                .attr('y1', centerY - optimalH/2)
                .attr('y2', centerY + optimalH/2);
            
            heightLabel.transition()
                .duration(2000)
                .attr('x', centerX + optimalR + 35);
            
            // 显示最优比例标签
            setTimeout(() => {
                g.append('text')
                    .attr('x', centerX)
                    .attr('y', centerY - optimalH/2 - 30)
                    .text('最优比例：h : r = 2 : 1')
                    .style('font-size', '18px')
                    .style('fill', '#f39c12')
                    .style('font-weight', 'bold')
                    .style('text-anchor', 'middle')
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
            }, 2000);
        }, 1000);
    }

    // 第20页：边际分析练习可视化
    function visualizePractice3(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;
        
        const margin = { top: 40, right: 40, bottom: 60, left: 60 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const xScale = d3.scaleLinear().domain([0, 400]).range([0, innerWidth]);
        const yScale = d3.scaleLinear().domain([0, 20]).range([innerHeight, 0]);
        
        const chart = g.append('g')
            .attr('transform', `translate(${margin.left}, ${margin.top})`);
        
        // 坐标轴
        chart.append('g')
            .attr('transform', `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(xScale).ticks(8))
            .style('color', '#666');
        
        chart.append('g')
            .call(d3.axisLeft(yScale).ticks(8))
            .style('color', '#666');
        
        // 边际成本函数 MC = 3 + 0.04x
        const mcData = d3.range(0, 401, 10).map(x => ({x: x, y: 3 + 0.04 * x}));
        // 边际收益函数 MR = 15 - 0.02x
        const mrData = d3.range(0, 401, 10).map(x => ({x: x, y: Math.max(0, 15 - 0.02 * x)}));
        
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        
        // 绘制MC曲线
        const mcPath = chart.append('path')
            .datum(mcData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .style('opacity', 0);
        
        // 绘制MR曲线
        const mrPath = chart.append('path')
            .datum(mrData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3)
            .style('opacity', 0);
        
        // 动画显示曲线
        setTimeout(() => {
            mcPath.transition()
                .duration(1500)
                .style('opacity', 1);
            
            // MC标签
            chart.append('text')
                .attr('x', xScale(350))
                .attr('y', yScale(3 + 0.04 * 350) - 10)
                .text('MC = 3 + 0.04x')
                .style('font-size', '14px')
                .style('fill', '#e74c3c')
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .transition()
                .delay(500)
                .duration(500)
                .style('opacity', 1);
        }, 1000);
        
        setTimeout(() => {
            mrPath.transition()
                .duration(1500)
                .style('opacity', 1);
            
            // MR标签
            chart.append('text')
                .attr('x', xScale(100))
                .attr('y', yScale(15 - 0.02 * 100) + 20)
                .text('MR = 15 - 0.02x')
                .style('font-size', '14px')
                .style('fill', '#2ecc71')
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .transition()
                .delay(500)
                .duration(500)
                .style('opacity', 1);
        }, 2500);
        
        // 最优产量点
        const optimalX = 200; // 解方程 3 + 0.04x = 15 - 0.02x
        const optimalY = 3 + 0.04 * optimalX;
        
        setTimeout(() => {
            // 垂直线
            chart.append('line')
                .attr('x1', xScale(optimalX))
                .attr('y1', yScale(0))
                .attr('x2', xScale(optimalX))
                .attr('y2', yScale(optimalY))
                .attr('stroke', '#f39c12')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .style('opacity', 0)
                .transition()
                .duration(800)
                .style('opacity', 0.7);
            
            // 交点
            chart.append('circle')
                .attr('cx', xScale(optimalX))
                .attr('cy', yScale(optimalY))
                .attr('r', 0)
                .attr('fill', '#f39c12')
                .transition()
                .duration(500)
                .attr('r', 8);
            
            // 最优产量标签
            chart.append('text')
                .attr('x', xScale(optimalX))
                .attr('y', yScale(optimalY) - 20)
                .text('最优产量: x = 200')
                .style('font-size', '14px')
                .style('text-anchor', 'middle')
                .style('fill', '#f39c12')
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .transition()
                .delay(500)
                .duration(500)
                .style('opacity', 1);
            
            // 显示计算过程
            chart.append('text')
                .attr('x', xScale(250))
                .attr('y', yScale(5))
                .text('MR = MC')
                .style('font-size', '16px')
                .style('fill', '#2c3e50')
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .transition()
                .delay(1000)
                .duration(500)
                .style('opacity', 1);
            
            chart.append('text')
                .attr('x', xScale(250))
                .attr('y', yScale(3))
                .text('15 - 0.02x = 3 + 0.04x')
                .style('font-size', '14px')
                .style('fill', '#2c3e50')
                .style('opacity', 0)
                .transition()
                .delay(1500)
                .duration(500)
                .style('opacity', 1);
            
            chart.append('text')
                .attr('x', xScale(250))
                .attr('y', yScale(1))
                .text('x = 200')
                .style('font-size', '14px')
                .style('fill', '#f39c12')
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .transition()
                .delay(2000)
                .duration(500)
                .style('opacity', 1);
        }, 4000);
    }

    // 第21页：相关变化率练习可视化
    function visualizePractice4(containerId) {
        const setup = setupD3(containerId);
        if (!setup) return;
        const { container, g, width, height } = setup;
        
        const centerX = width / 2;
        const centerY = height * 0.7;
        
        // 墙
        const wall = g.append('line')
            .attr('x1', centerX - 150)
            .attr('y1', centerY - 200)
            .attr('x2', centerX - 150)
            .attr('y2', centerY)
            .attr('stroke', '#7f8c8d')
            .attr('stroke-width', 8);
        
        // 地面
        const ground = g.append('line')
            .attr('x1', centerX - 200)
            .attr('y1', centerY)
            .attr('x2', centerX + 100)
            .attr('y2', centerY)
            .attr('stroke', '#7f8c8d')
            .attr('stroke-width', 8);
        
        // 梯子初始位置
        let x = 120; // 底端距墙根距离
        let y = Math.sqrt(25 - (x/40)*(x/40)) * 40; // 根据勾股定理计算高度
        
        const ladder = g.append('line')
            .attr('x1', centerX - 150)
            .attr('y1', centerY - y)
            .attr('x2', centerX - 150 + x)
            .attr('y2', centerY)
            .attr('stroke', '#e67e22')
            .attr('stroke-width', 6);
        
        // 标注距离
        const xLabel = g.append('text')
            .attr('x', centerX - 150 + x/2)
            .attr('y', centerY + 25)
            .text(`x = ${(x/40).toFixed(1)}m`)
            .style('font-size', '14px')
            .style('text-anchor', 'middle')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold');
        
        const yLabel = g.append('text')
            .attr('x', centerX - 170)
            .attr('y', centerY - y/2)
            .text(`y = ${(y/40).toFixed(1)}m`)
            .style('font-size', '14px')
            .style('text-anchor', 'middle')
            .style('fill', '#27ae60')
            .style('font-weight', 'bold');
        
        // 速度向量
        const velocityArrow = g.append('line')
            .attr('x1', centerX - 150 + x)
            .attr('y1', centerY - 30)
            .attr('x2', centerX - 150 + x + 30)
            .attr('y2', centerY - 30)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .attr('marker-end', 'url(#arrowhead)');
        
        // 定义箭头标记
        const defs = g.append('defs');
        defs.append('marker')
            .attr('id', 'arrowhead')
            .attr('markerWidth', 10)
            .attr('markerHeight', 7)
            .attr('refX', 9)
            .attr('refY', 3.5)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 10 3.5, 0 7')
            .attr('fill', '#3498db');
        
        const velocityLabel = g.append('text')
            .attr('x', centerX - 150 + x + 40)
            .attr('y', centerY - 25)
            .text('dx/dt = 1 m/s')
            .style('font-size', '12px')
            .style('fill', '#3498db')
            .style('font-weight', 'bold');
        
        // 显示解题过程
        const processContainer = container.append('div')
            .style('position', 'absolute')
            .style('top', '20px')
            .style('right', '20px')
            .style('width', '300px')
            .style('background', 'rgba(255,255,255,0.95)')
            .style('border-radius', '8px')
            .style('padding', '15px')
            .style('box-shadow', '0 4px 12px rgba(0,0,0,0.1)')
            .style('font-family', 'inherit');
        
        const steps = [
            '勾股定理：x² + y² = 25',
            '对时间求导：2x(dx/dt) + 2y(dy/dt) = 0',
            '当 x = 3m 时，y = 4m',
            '代入：2×3×1 + 2×4×(dy/dt) = 0',
            '解得：dy/dt = -3/4 m/s'
        ];
        
        steps.forEach((step, i) => {
            setTimeout(() => {
                processContainer.append('div')
                    .style('margin-bottom', '8px')
                    .style('padding', '5px')
                    .style('background', i === steps.length - 1 ? '#e8f5e8' : '#f8f9fa')
                    .style('border-radius', '4px')
                    .style('font-size', '16px')
                    .style('color', '#2c3e50')
                    .text(step)
                    .style('opacity', 0)
                    .transition()
                    .duration(500)
                    .style('opacity', 1);
            }, i * 1000);
        });
        
        // 动画演示梯子滑动
        setTimeout(() => {
            function animateLadder() {
                x += 2;
                if (x > 200) x = 120;
                
                y = Math.sqrt(Math.max(0, 25 - (x/40)*(x/40))) * 40;
                
                ladder
                    .attr('x1', centerX - 150)
                    .attr('y1', centerY - y)
                    .attr('x2', centerX - 150 + x)
                    .attr('y2', centerY);
                
                xLabel
                    .attr('x', centerX - 150 + x/2)
                    .text(`x = ${(x/40).toFixed(1)}m`);
                
                yLabel
                    .attr('y', centerY - y/2)
                    .text(`y = ${(y/40).toFixed(1)}m`);
                
                velocityArrow
                    .attr('x1', centerX - 150 + x)
                    .attr('x2', centerX - 150 + x + 30);
                
                velocityLabel
                    .attr('x', centerX - 150 + x + 40);
                
                if (globalAnimationPlaying) {
                    requestAnimationFrame(animateLadder);
                }
            }
            animateLadder();
        }, 6000);
    }
</script>

<!-- 悬浮控制按钮与二级菜单（统一样式） -->
<button class="floating-control-btn" id="floating-control-btn"><span class="btn-icon">+</span></button>
<div class="floating-menu-items" id="floating-menu-items">
    <div class="floating-menu-item" onclick="event.stopPropagation(); toggleLabSubmenu()">
        <span class="item-icon"><i class="fa-solid fa-flask"></i></span>
        <span class="item-text">实验室</span>
    </div>
    <div class="floating-menu-item" onclick="event.stopPropagation(); toggleChapterSubmenu()">
        <span class="item-icon"><i class="fa-solid fa-clipboard-list"></i></span>
        <span class="item-text">本章目录</span>
    </div>
</div>

<!-- 实验室弹层（第四章） -->
<div class="lab-submenu" id="lab-submenu" style="display: none;">
    <div class="submenu-content">
        <div class="submenu-title">第四章实验室</div>
        <div class="submenu-grid">
            <div class="submenu-item" onclick="window.open('../网页资源/index.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-list"></i></span><span class="submenu-text">资源总览</span></div>
            <div class="submenu-item" onclick="window.open('../网页资源/lab 4-1.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">单调性与极值分析实验室</span></div>
            <div class="submenu-item" onclick="window.open('../网页资源/lab 4-2.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">洛必达法则实验室</span></div>
            <div class="submenu-item" onclick="window.open('../网页资源/lab 4-3.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">中值定理虚拟实验室</span></div>
        </div>
        <div class="submenu-close" onclick="toggleLabSubmenu()">×</div>
    </div>
</div>

<!-- 本章目录弹层（自动生成） -->
<div class="lab-submenu" id="chapter-submenu" style="display:none;">
    <div class="submenu-content">
        <div class="submenu-title">第四章目录</div>
        <div class="submenu-grid" id="chapter-submenu-grid"></div>
        <div class="submenu-close" onclick="toggleChapterSubmenu()">×</div>
    </div>
</div>

<!-- 全部课件目录弹层 -->
<div class="lab-submenu" id="course-submenu" style="display: none;">
    <div class="submenu-content">
        <div class="submenu-title">全部课件目录</div>
        <div class="submenu-grid">
            <div class="submenu-item" onclick="window.location.href='第1章代数.html';"><span class="submenu-icon"><i class="fa-solid fa-1"></i></span><span class="submenu-text">第1章 代数</span></div>
            <div class="submenu-item" onclick="window.location.href='第2章极限与连续.html';"><span class="submenu-icon"><i class="fa-solid fa-2"></i></span><span class="submenu-text">第2章 极限与连续</span></div>
            <div class="submenu-item" onclick="window.location.href='第3章导数与微分.html';"><span class="submenu-icon"><i class="fa-solid fa-3"></i></span><span class="submenu-text">第3章 导数与微分</span></div>
            <div class="submenu-item" onclick="window.location.href='第4章导数应用.html';"><span class="submenu-icon"><i class="fa-solid fa-4"></i></span><span class="submenu-text">第4章 导数应用</span></div>
            <div class="submenu-item" onclick="window.location.href='第5章不定积分.html';"><span class="submenu-icon"><i class="fa-solid fa-5"></i></span><span class="submenu-text">第5章 不定积分</span></div>
            <div class="submenu-item" onclick="window.location.href='第6章定积分.html';"><span class="submenu-icon"><i class="fa-solid fa-6"></i></span><span class="submenu-text">第6章 定积分</span></div>
            <div class="submenu-item" onclick="window.location.href='第7章常微分方程.html';"><span class="submenu-icon"><i class="fa-solid fa-7"></i></span><span class="submenu-text">第7章 常微分方程</span></div>
            <div class="submenu-item" onclick="window.location.href='第8章多元函数微分学.html';"><span class="submenu-icon"><i class="fa-solid fa-8"></i></span><span class="submenu-text">第8章 多元函数微分学</span></div>
            <div class="submenu-item" onclick="window.location.href='第9章多元函数积分学初步.html';"><span class="submenu-icon"><i class="fa-solid fa-9"></i></span><span class="submenu-text">第9章 多元函数积分学初步</span></div>
            <div class="submenu-item" onclick="window.location.href='第10章线性代数.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第10章 线性代数</span></div>
            <div class="submenu-item" onclick="window.location.href='第11章无穷级数.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第11章 无穷级数</span></div>
            <div class="submenu-item" onclick="window.location.href='第12章向量代数与空间解析几何.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第12章 向量代数与空间解析几何</span></div>
            <div class="submenu-item" onclick="window.location.href='第13章概率与统计.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第13章 概率与统计</span></div>
        </div>
        <div class="submenu-close" onclick="toggleCourseSubmenu()">×</div>
    </div>
    
</div>

<script>
// 悬浮菜单互斥控制与切换
function closeAllSubmenus(exceptId) {
    ['lab-submenu','chapter-submenu','course-submenu'].forEach(id => {
        if (id !== exceptId) {
            const el = document.getElementById(id);
            if (el) el.style.display = 'none';
        }
    });
}
function toggleLabSubmenu() {
    const el = document.getElementById('lab-submenu');
    if (!el) return;
    const willOpen = el.style.display !== 'block';
    closeAllSubmenus('lab-submenu');
    el.style.display = willOpen ? 'block' : 'none';
}
function toggleChapterSubmenu() {
    const el = document.getElementById('chapter-submenu');
    if (!el) return;
    const willOpen = el.style.display !== 'block';
    closeAllSubmenus('chapter-submenu');
    if (willOpen) buildChapterMenuCh4();
    el.style.display = willOpen ? 'block' : 'none';
}
function toggleCourseSubmenu() {
    const el = document.getElementById('course-submenu');
    if (!el) return;
    const willOpen = el.style.display !== 'block';
    closeAllSubmenus('course-submenu');
    el.style.display = willOpen ? 'block' : 'none';
}
function initFloatingControl() {
    const floatingBtn = document.getElementById('floating-control-btn');
    const floatingMenu = document.getElementById('floating-menu-items');
    if (!floatingBtn || !floatingMenu) return;
    floatingBtn.addEventListener('click', function(e) {
        e.stopPropagation();
        floatingBtn.classList.toggle('active');
        floatingMenu.classList.toggle('active');
    });
}

// 自动构建“第四章目录”
function buildChapterMenuCh4() {
    const grid = document.getElementById('chapter-submenu-grid');
    if (!grid) return;
    grid.innerHTML = '';

    // 导览
    const cover = document.createElement('div');
    cover.className = 'submenu-item';
    cover.innerHTML = '<span class="submenu-icon"><i class="fa-solid fa-house"></i></span><span class="submenu-text">封面</span>';
    cover.onclick = function() { try{ goToSlide(0);}catch(_){} toggleChapterSubmenu(); };
    grid.appendChild(cover);
    const toc = document.createElement('div');
    toc.className = 'submenu-item';
    toc.innerHTML = '<span class="submenu-icon"><i class="fa-solid fa-list-ul"></i></span><span class="submenu-text">目录页</span>';
    toc.onclick = function() { try{ goToSlide(1);}catch(_){} toggleChapterSubmenu(); };
    grid.appendChild(toc);

    const slides = document.querySelectorAll('#slidesContainer > .slide');
    let currentGroup = null;
    const addHeader = (text) => {
        const header = document.createElement('div');
        header.className = 'submenu-item';
        header.style.cursor = 'default';
        header.style.background = 'rgba(15,23,42,0.06)';
        header.style.borderColor = 'rgba(15,23,42,0.12)';
        header.innerHTML = '<span class="submenu-icon"><i class="fa-solid fa-folder-open"></i></span><span class="submenu-text" style="font-weight:700;">' + text + '</span>';
        grid.appendChild(header);
    };

    slides.forEach((slide, idx) => {
        const h1 = slide.querySelector('.left-content h1');
        const h2 = slide.querySelector('.left-content h2');
        const title = (h1 && h1.textContent.trim()) || (h2 && h2.textContent.trim()) || '';
        if (!title) return;
        const partMatch = title.match(/^第[一二三四五六七八九十]+部分/);
        if (partMatch) {
            currentGroup = title;
            addHeader(currentGroup);
            return;
        }
        if (/^第.页/.test(title)) return; // 跳过仅编号标题
        if (title === '目录' || title === '导数是什么？' && idx === 11) {
            // 目录已添加；其余按正常加入
        }
        const item = document.createElement('div');
        item.className = 'submenu-item';
        item.innerHTML = '<span class="submenu-icon"><i class="fa-solid fa-file-lines"></i></span><span class="submenu-text">' + title.replace(/\s+/g,' ') + '</span>';
        item.onclick = function() { try{ goToSlide(idx);}catch(_){} toggleChapterSubmenu(); };
        grid.appendChild(item);
    });
}

// 初始化与关闭逻辑
document.addEventListener('DOMContentLoaded', function() {
    initFloatingControl();
    ['lab-submenu','chapter-submenu','course-submenu'].forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        const content = el.querySelector('.submenu-content');
        if (content) content.addEventListener('click', ev => ev.stopPropagation());
    });
    document.addEventListener('click', () => {
        closeAllSubmenus();
        const floatingBtn = document.getElementById('floating-control-btn');
        const floatingMenu = document.getElementById('floating-menu-items');
        if (floatingBtn && floatingMenu) {
            floatingBtn.classList.remove('active');
            floatingMenu.classList.remove('active');
        }
    });
    document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape') {
            closeAllSubmenus();
            const floatingBtn = document.getElementById('floating-control-btn');
            const floatingMenu = document.getElementById('floating-menu-items');
            if (floatingBtn && floatingMenu) {
                floatingBtn.classList.remove('active');
                floatingMenu.classList.remove('active');
            }
        }
    });
});

// ========== 凹凸性交互式演示 JavaScript ==========
(function() {
    let concavityCurrentSlide = 1;
    const concavityTotalSlides = 3;

    // Canvas 高DPI支持
    function concavitySetupCanvas(canvas) {
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        
        ctx.scale(dpr, dpr);
        
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        
        return ctx;
    }

    // 导航功能（内部幻灯片切换）
    function concavityShowSlide(n) {
        const container = document.querySelector('.concavity-interactive-slide');
        if (!container) return;
        const slides = container.querySelectorAll('.concavity-slide');
        if (slides.length === 0) return;
        if (n > concavityTotalSlides) concavityCurrentSlide = concavityTotalSlides;
        if (n < 1) concavityCurrentSlide = 1;
        
        slides.forEach(slide => slide.classList.remove('active'));
        if (slides[concavityCurrentSlide - 1]) {
            slides[concavityCurrentSlide - 1].classList.add('active');
        }
        // 更新内部计数器（若存在）
        const concavityCounterEl = document.getElementById('concavityCurrentSlide');
        if (concavityCounterEl) concavityCounterEl.textContent = concavityCurrentSlide;
        
        // 重绘当前幻灯片的图形
        setTimeout(() => {
            if (concavityCurrentSlide === 1) concavityDrawSlide1();
            if (concavityCurrentSlide === 2) concavityDrawSlide2();
            if (concavityCurrentSlide === 3) concavityDrawSlide3();
        }, 100);
    }

    // 绘制坐标轴
    function concavityDrawAxes(ctx, width, height, xMin, xMax, yMin, yMax) {
        const padding = 40;
        const centerX = width / 2;
        const centerY = height / 2;
        
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1.5;
        
        // X轴
        ctx.beginPath();
        ctx.moveTo(padding, centerY);
        ctx.lineTo(width - padding, centerY);
        ctx.stroke();
        
        // Y轴
        ctx.beginPath();
        ctx.moveTo(centerX, padding);
        ctx.lineTo(centerX, height - padding);
        ctx.stroke();
        
        // 箭头
        ctx.fillStyle = '#9ca3af';
        ctx.beginPath();
        ctx.moveTo(width - padding, centerY);
        ctx.lineTo(width - padding - 8, centerY - 4);
        ctx.lineTo(width - padding - 8, centerY + 4);
        ctx.closePath();
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(centerX, padding);
        ctx.lineTo(centerX - 4, padding + 8);
        ctx.lineTo(centerX + 4, padding + 8);
        ctx.closePath();
        ctx.fill();
        
        // 标签
        ctx.fillStyle = '#6b7280';
        ctx.font = '13px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('x', width - padding + 10, centerY + 20);
        ctx.fillText('y', centerX + 15, padding - 10);
        ctx.fillText('0', centerX - 15, centerY + 18);
        ctx.fillText(xMin.toString(), padding, centerY + 18);
        ctx.fillText(xMax.toString(), width - padding, centerY + 18);
    }

    // 坐标转换函数
    function concavityMapX(x, width, xMin, xMax) {
        const padding = 40;
        return padding + (x - xMin) / (xMax - xMin) * (width - 2 * padding);
    }

    function concavityMapY(y, height, yMin, yMax) {
        const padding = 40;
        return height - padding - (y - yMin) / (yMax - yMin) * (height - 2 * padding);
    }

    function concavityUnmapX(px, width, xMin, xMax) {
        const padding = 40;
        return xMin + (px - padding) / (width - 2 * padding) * (xMax - xMin);
    }

    // 绘制函数曲线
    function concavityDrawFunction(ctx, width, height, f, xMin, xMax, yMin, yMax) {
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        for (let px = 40; px < width - 40; px++) {
            const x = concavityUnmapX(px, width, xMin, xMax);
            const y = f(x);
            const py = concavityMapY(y, height, yMin, yMax);
            
            if (px === 40) {
                ctx.moveTo(px, py);
            } else {
                ctx.lineTo(px, py);
            }
        }
        ctx.stroke();
    }

    // 绘制切线
    function concavityDrawTangent(ctx, width, height, x0, f, df, xMin, xMax, yMin, yMax) {
        const y0 = f(x0);
        const m = df(x0);
        
        const extend = 1.5;
        const x1 = Math.max(xMin, x0 - extend);
        const x2 = Math.min(xMax, x0 + extend);
        const y1 = y0 + m * (x1 - x0);
        const y2 = y0 + m * (x2 - x0);
        
        ctx.strokeStyle = '#f59e0b';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(concavityMapX(x1, width, xMin, xMax), concavityMapY(y1, height, yMin, yMax));
        ctx.lineTo(concavityMapX(x2, width, xMin, xMax), concavityMapY(y2, height, yMin, yMax));
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // 绘制点和垂线
    function concavityDrawPoint(ctx, width, height, x, f, xMin, xMax, yMin, yMax) {
        const y = f(x);
        const px = concavityMapX(x, width, xMin, xMax);
        const py = concavityMapY(y, height, yMin, yMax);
        
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(px, height - 40);
        ctx.lineTo(px, py);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#2563eb';
        ctx.beginPath();
        ctx.arc(px, py, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // 幻灯片1: y = x^2 (凹向上)
    function concavityDrawSlide1() {
        const canvas = document.getElementById('concavity-canvas1');
        if (!canvas) return;
        const ctx = concavitySetupCanvas(canvas);
        const width = canvas.getBoundingClientRect().width;
        const height = canvas.getBoundingClientRect().height;
        
        const slider = document.getElementById('concavity-xSlider1');
        if (!slider) return;
        const x = parseFloat(slider.value);
        
        const f = x => x * x;
        const df = x => 2 * x;
        const ddf = x => 2;
        
        // 更新数据
        const xValueEl = document.getElementById('concavity-xValue1');
        const fpValueEl = document.getElementById('concavity-fpValue1');
        const fppValueEl = document.getElementById('concavity-fppValue1');
        const fpDescEl = document.getElementById('concavity-fpDesc1');
        
        if (xValueEl) xValueEl.textContent = x.toFixed(2);
        if (fpValueEl) fpValueEl.textContent = df(x).toFixed(2);
        if (fppValueEl) fppValueEl.textContent = ddf(x).toFixed(2);
        
        const fpVal = df(x);
        if (fpDescEl) {
            if (fpVal > 0.01) {
                fpDescEl.textContent = '递增';
            } else if (fpVal < -0.01) {
                fpDescEl.textContent = '递减';
            } else {
                fpDescEl.textContent = '水平';
            }
        }
        
        // 绘图
        ctx.clearRect(0, 0, width, height);
        concavityDrawAxes(ctx, width, height, -2, 2, -1, 5);
        concavityDrawFunction(ctx, width, height, f, -2, 2, -1, 5);
        concavityDrawTangent(ctx, width, height, x, f, df, -2, 2, -1, 5);
        concavityDrawPoint(ctx, width, height, x, f, -2, 2, -1, 5);
    }

    // 幻灯片2: y = -x^2 + 4 (凹向下)
    function concavityDrawSlide2() {
        const canvas = document.getElementById('concavity-canvas2');
        if (!canvas) return;
        const ctx = concavitySetupCanvas(canvas);
        const width = canvas.getBoundingClientRect().width;
        const height = canvas.getBoundingClientRect().height;
        
        const slider = document.getElementById('concavity-xSlider2');
        if (!slider) return;
        const x = parseFloat(slider.value);
        
        const f = x => -x * x + 4;
        const df = x => -2 * x;
        const ddf = x => -2;
        
        // 更新数据
        const xValueEl = document.getElementById('concavity-xValue2');
        const fpValueEl = document.getElementById('concavity-fpValue2');
        const fppValueEl = document.getElementById('concavity-fppValue2');
        const fpDescEl = document.getElementById('concavity-fpDesc2');
        
        if (xValueEl) xValueEl.textContent = x.toFixed(2);
        if (fpValueEl) fpValueEl.textContent = df(x).toFixed(2);
        if (fppValueEl) fppValueEl.textContent = ddf(x).toFixed(2);
        
        const fpVal = df(x);
        if (fpDescEl) {
            if (fpVal > 0.01) {
                fpDescEl.textContent = '递增';
            } else if (fpVal < -0.01) {
                fpDescEl.textContent = '递减';
            } else {
                fpDescEl.textContent = '水平';
            }
        }
        
        // 绘图
        ctx.clearRect(0, 0, width, height);
        concavityDrawAxes(ctx, width, height, -2, 2, -1, 5);
        concavityDrawFunction(ctx, width, height, f, -2, 2, -1, 5);
        concavityDrawTangent(ctx, width, height, x, f, df, -2, 2, -1, 5);
        concavityDrawPoint(ctx, width, height, x, f, -2, 2, -1, 5);
    }

    // 幻灯片3: y = x^3 (拐点)
    function concavityDrawSlide3() {
        const canvas = document.getElementById('concavity-canvas3');
        if (!canvas) return;
        const ctx = concavitySetupCanvas(canvas);
        const width = canvas.getBoundingClientRect().width;
        const height = canvas.getBoundingClientRect().height;
        
        const slider = document.getElementById('concavity-xSlider3');
        if (!slider) return;
        const x = parseFloat(slider.value);
        
        const f = x => x * x * x;
        const df = x => 3 * x * x;
        const ddf = x => 6 * x;
        
        // 更新数据
        const xValueEl = document.getElementById('concavity-xValue3');
        const fpValueEl = document.getElementById('concavity-fpValue3');
        const fppValueEl = document.getElementById('concavity-fppValue3');
        const fpDescEl = document.getElementById('concavity-fpDesc3');
        
        if (xValueEl) xValueEl.textContent = x.toFixed(2);
        if (fpValueEl) fpValueEl.textContent = df(x).toFixed(2);
        if (fppValueEl) fppValueEl.textContent = ddf(x).toFixed(2);
        
        const fpVal = df(x);
        if (fpDescEl) {
            if (fpVal > 0.01) {
                fpDescEl.textContent = '递增';
            } else if (fpVal < -0.01) {
                fpDescEl.textContent = '递减';
            } else {
                fpDescEl.textContent = '水平';
            }
        }
        
        // 更新凹凸性显示
        const fppCard = document.getElementById('concavity-fppCard3');
        const concavityIcon = document.getElementById('concavity-concavityIcon3');
        const concavityText = document.getElementById('concavity-concavityText3');
        const fppDescEl3 = document.getElementById('concavity-fppDesc3');
        const fppVal = ddf(x);
        
        if (fppCard) {
            fppCard.classList.remove('concavity-highlight-positive', 'concavity-highlight-negative', 'concavity-highlight-zero');
        }
        if (concavityIcon) {
            concavityIcon.classList.remove('concavity-concave-up', 'concavity-concave-down', 'concavity-inflection');
        }
        
        if (fppVal > 0.01) {
            if (fppDescEl3) fppDescEl3.textContent = '凹向上';
            if (fppCard) fppCard.classList.add('concavity-highlight-positive');
            if (concavityIcon) {
                concavityIcon.classList.add('concavity-concave-up');
                concavityIcon.textContent = '⌣';
            }
            if (concavityText) concavityText.textContent = '凹向上 (f\'\' > 0)';
        } else if (fppVal < -0.01) {
            if (fppDescEl3) fppDescEl3.textContent = '凹向下';
            if (fppCard) fppCard.classList.add('concavity-highlight-negative');
            if (concavityIcon) {
                concavityIcon.classList.add('concavity-concave-down');
                concavityIcon.textContent = '⌢';
            }
            if (concavityText) concavityText.textContent = '凹向下 (f\'\' < 0)';
        } else {
            if (fppDescEl3) fppDescEl3.textContent = '拐点';
            if (fppCard) fppCard.classList.add('concavity-highlight-zero');
            if (concavityIcon) {
                concavityIcon.classList.add('concavity-inflection');
                concavityIcon.textContent = '—';
            }
            if (concavityText) concavityText.textContent = '拐点 (f\'\' = 0)';
        }
        
        // 绘图
        ctx.clearRect(0, 0, width, height);
        concavityDrawAxes(ctx, width, height, -2, 2, -8, 8);
        concavityDrawFunction(ctx, width, height, f, -2, 2, -8, 8);
        concavityDrawTangent(ctx, width, height, x, f, df, -2, 2, -8, 8);
        concavityDrawPoint(ctx, width, height, x, f, -2, 2, -8, 8);
    }

    // 设置交互事件
    function concavitySetupInteractions() {
        // 滑块事件
        const slider1 = document.getElementById('concavity-xSlider1');
        const slider2 = document.getElementById('concavity-xSlider2');
        const slider3 = document.getElementById('concavity-xSlider3');
        
        if (slider1) slider1.addEventListener('input', concavityDrawSlide1);
        if (slider2) slider2.addEventListener('input', concavityDrawSlide2);
        if (slider3) slider3.addEventListener('input', concavityDrawSlide3);
        
        // Canvas点击事件
        const setupCanvasClick = (canvasId, slideNum, xMin, xMax) => {
            const canvas = document.getElementById(canvasId);
            const slider = document.getElementById(`concavity-xSlider${slideNum}`);
            
            if (!canvas || !slider) return;
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const worldX = concavityUnmapX(x, rect.width, xMin, xMax);
                
                if (worldX >= xMin && worldX <= xMax) {
                    slider.value = worldX;
                    if (slideNum === 1) concavityDrawSlide1();
                    if (slideNum === 2) concavityDrawSlide2();
                    if (slideNum === 3) concavityDrawSlide3();
                }
            });
        };
        
        setupCanvasClick('concavity-canvas1', 1, -2, 2);
        setupCanvasClick('concavity-canvas2', 2, -2, 2);
        setupCanvasClick('concavity-canvas3', 3, -2, 2);
    }

    window.concavityNextSlide = function(evt) {
        if (evt) {
            evt.stopPropagation();
            evt.preventDefault();
        }
        concavityCurrentSlide++;
        concavityShowSlide(concavityCurrentSlide);
    };
    window.concavityPrevSlide = function(evt) {
        if (evt) {
            evt.stopPropagation();
            evt.preventDefault();
        }
        concavityCurrentSlide--;
        concavityShowSlide(concavityCurrentSlide);
    };

    let concavityKeyHandler = null;
    let concavityInitialized = false;
    // 初始化（当凹凸性幻灯片显示时）
    function initConcavityInteractive() {
        const concavitySlide = document.querySelector('.concavity-interactive-slide');
        if (!concavitySlide) return;
        
        // 确保所有内部slide初始状态正确
        const internalSlides = concavitySlide.querySelectorAll('.concavity-slide');
        internalSlides.forEach((slide, index) => {
            if (index === 0) {
                slide.classList.add('active');
            } else {
                slide.classList.remove('active');
            }
        });
        
        const checkAndInit = () => {
            const isActive = concavitySlide.classList.contains('active');
            if (isActive) {
                if (!concavityInitialized) {
                    concavityInitialized = true;
                    concavityCurrentSlide = 1;
                    concavityShowSlide(1);
                    concavitySetupInteractions();
                    setTimeout(() => {
                        if (concavityCurrentSlide === 1) concavityDrawSlide1();
                        if (concavityCurrentSlide === 2) concavityDrawSlide2();
                        if (concavityCurrentSlide === 3) concavityDrawSlide3();
                    }, 200);
                    // 添加键盘导航（只添加一次）
                    if (!concavityKeyHandler) {
                        concavityKeyHandler = (e) => {
                            if (concavitySlide.classList.contains('active')) {
                                if (e.key === 'ArrowLeft') {
                                    e.stopPropagation();
                                    concavityPrevSlide();
                                } else if (e.key === 'ArrowRight') {
                                    e.stopPropagation();
                                    concavityNextSlide();
                                }
                            }
                        };
                        document.addEventListener('keydown', concavityKeyHandler, true);
                    }
                } else {
                    // 如果已经初始化，确保当前slide正确显示
                    concavityShowSlide(concavityCurrentSlide);
                }
            } else {
                concavityInitialized = false;
            }
        };
        
        // 初始检查
        setTimeout(checkAndInit, 100);
        // 监听主课件的slide切换
        const observer = new MutationObserver(checkAndInit);
        observer.observe(concavitySlide, { attributes: true, attributeFilter: ['class'] });
        // 监听所有slide的变化，以便在主课件切换时也能检测到
        const allSlides = document.querySelectorAll('.slide');
        allSlides.forEach(slide => {
            const slideObserver = new MutationObserver(() => {
                if (slide.classList.contains('active') && slide === concavitySlide) {
                    checkAndInit();
                }
            });
            slideObserver.observe(slide, { attributes: true, attributeFilter: ['class'] });
        });
    }

    // 窗口加载时初始化
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initConcavityInteractive);
    } else {
        initConcavityInteractive();
    }

    // 窗口调整
    window.addEventListener('resize', () => {
        if (concavityCurrentSlide === 1) concavityDrawSlide1();
        if (concavityCurrentSlide === 2) concavityDrawSlide2();
        if (concavityCurrentSlide === 3) concavityDrawSlide3();
    });
})();
// ========== 凹凸性交互式演示 JavaScript 结束 ==========
</script>

</div></body>
</html>
