<!DOCTYPE html>

<html lang="zh-CN">
<head>
    <link rel="stylesheet" href="../common-assets/css/fontawesome.min.css">
    <link rel="stylesheet" href="../common-assets/css/solid.min.css">
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>第六章：定积分基础 (交互式课件)</title>
<!-- D3.js 库 - 本地化资源 -->
<script src="../common-assets/js/d3-7.8.5.min.js"></script>
<script>
    // 验证 D3 已加载
    if (typeof d3 === 'undefined') {
        console.error('D3.js 加载失败！');
    } else {
        console.log('D3.js 已成功加载，版本:', d3.version);
    }
</script>
<!-- 使用统一的MathJax配置文件 -->
<!-- <script src="../common-assets/js/mathjax-config.js"></script> -->
<script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                pageReady: () => {
                    return window.MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax is ready!');
                    });
                }
            }
        };
    </script>
<!-- MathJax - 本地化资源 -->
<script async id="MathJax-script" src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js" type="text/javascript">
</script>
<script>
        window.themeColors = { text: '#ffffff' };
        (function () {
            try {
                const apply = () => { window.themeColors.text = '#ffffff'; };
                const mql = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
                if (mql && typeof mql.addEventListener === 'function') {
                    mql.addEventListener('change', apply);
                }
                apply();
            } catch (_) {}
        })();
    </script>
<style>
        /* === RESET AND BASE STYLES === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
            height: 100%;
        }

        body {
            font-family: 'Inter', 'Source Han Sans SC', 'Noto Sans SC', 'Microsoft YaHei', system-ui, -apple-system, sans-serif;
            background: #FAFAFA;
            overflow: hidden;
            color: #1a1a1a;
            height: 100%;
            line-height: 1.6;
            font-weight: 400;
        }

        /* === SLIDE LAYOUT === */
        .slide-container {
            width: 100%;
            height: 100vh;
            display: flex;
            position: relative;
            gap: 0;
            padding: 0;
        }

        /* Left Content Area - Academic Journal Style */
        .left-content {
            width: 50%;
            height: 100vh;
            padding: 60px 80px 60px 60px;
            background: #FBFBFB;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.6;
            border: none;
            box-shadow: none;
            border-radius: 0;
        }

        /* Right Visualization Area - Subtle Contrast */
        .right-visual {
            width: 50%;
            height: 100vh;
            background: #F8F9FA;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            border: none;
            box-shadow: none;
            border-radius: 0;
        }

        /* 可视化容器样式 */
        .right-visual > div {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: visible;
            padding: 20px;
            box-sizing: border-box;
        }
        
        /* 步骤内容统一样式 */
        .step-content {
            line-height: 1.4;
        }
        
        .step-content .tex2jax_process {
            line-height: 1.6;
        }

        /* === SLIDE TRANSITIONS === */
        .slide {
            display: none;
            animation: slideIn 0.5s ease-out;
        }

        .slide.active {
            display: flex;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* === 统一的字体系统 === */
        h1 {
            color: #003366;
            font-size: 28px;
            line-height: 1.3;
            font-weight: 700;
            margin: 0 0 24px 0;
            padding: 0;
            letter-spacing: -0.02em;
        }

        h2 {
            color: #008080;
            font-size: 22px;
            line-height: 1.4;
            font-weight: 600;
            margin: 32px 0 16px 0;
            position: relative;
            padding-left: 0;
        }

        h2::before {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #008080;
            border-radius: 2px;
        }

        h3 {
            color: #1a1a1a;
            font-size: 20px;
            line-height: 1.4;
            font-weight: 600;
            margin: 24px 0 12px 0;
        }

        h4 {
            color: #333333;
            font-size: 18px;
            line-height: 1.4;
            font-weight: 500;
            margin: 20px 0 8px 0;
        }

        h5 {
            color: #555555;
            font-size: 16px;
            line-height: 1.4;
            font-weight: 500;
            margin: 16px 0 8px 0;
        }

        p {
            margin-bottom: 16px;
            color: #2d2d2d;
            font-weight: 400;
            font-size: 16px;
            line-height: 1.6;
        }

        ul, ol {
            margin: 0 0 16px 0;
            line-height: 1.6;
            padding-left: 24px;
            font-size: 16px;
        }

        li {
            margin-bottom: 8px;
            color: #2d2d2d;
            font-size: 16px;
            line-height: 1.6;
        }

        /* === CONTENT MODULES - 去框化设计 === */
        .definition, .theorem, .example, .note {
            background: transparent;
            border: none;
            border-left: 4px solid;
            padding: 16px 0 16px 20px;
            margin: 20px 0;
        }

        .definition {
            border-left-color: #1e40af;
        }

        .theorem {
            border-left-color: #059669;
        }

        .example {
            border-left-color: #dc2626;
        }

        .note {
            border-left-color: #6b7280;
            font-style: italic;
            color: #4b5563;
        }

        .formula-highlight, .math-formula {
            background: transparent;
            padding: 24px 0;
            margin: 24px 0;
            text-align: center;
            font-size: 18px;
            border: none;
            box-shadow: none;
        }
        
        .formula-rule {
            background: transparent;
            padding: 16px 0;
            margin: 16px 0;
            text-align: center;
            font-size: 18px;
            line-height: 1.8;
        }
        
        .formula-table {
            width: 100%;
            margin: 16px 0;
            line-height: 1.8;
        }
        
        .formula-table td {
            padding: 8px;
            text-align: center;
            font-size: 16px;
        }

        .highlight {
            color: #008080;
            font-weight: 600;
        }

        /* === 封面导航链接样式 === */
        .home-link-btn {
            display: inline-block;
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .home-link-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        .home-link-btn span {
            font-size: 1.2rem;
        }

        /* === 导航控制 - 第二章极简设计 === */
        .nav-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 1000;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.15);
            color: transparent;
            border: none;
            padding: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0;
            transition: all 0.2s;
            position: relative;
        }

        .nav-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-top: 2px solid rgba(0, 0, 0, 0.5);
            border-right: 2px solid rgba(0, 0, 0, 0.5);
        }

        .nav-btn:first-child::before {
            transform: translate(-40%, -50%) rotate(-135deg);
        }

        .nav-btn:last-child::before {
            transform: translate(-60%, -50%) rotate(45deg);
        }

        .nav-btn:hover {
            background: rgba(0, 0, 0, 0.25);
        }

        .nav-btn:hover::before {
            border-color: rgba(0, 0, 0, 0.7);
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed !important;
        }

        .nav-btn:disabled:hover {
            background: rgba(0, 0, 0, 0.15);
        }

        .slide-number {
            font-size: 11px;
            color: #9ca3af;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 0;
            opacity: 0.6;
        }

        .slide-number input {
            width: 50px;
            text-align: right;
            border: none;
            background: transparent;
            font-size: 11px;
            padding: 0 2px;
            margin: 0;
            color: #000000;
            font-weight: 700;
        }

        .slide-number input::-webkit-outer-spin-button,
        .slide-number input::-webkit-inner-spin-button {
            display: none;
        }

        .slide-number input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .slide-number input:focus {
            outline: none;
            color: #000000;
        }

        #slideNumberTotal {
            color: #9ca3af;
        }

        /* === CANVAS STYLING === */
        canvas {
            max-width: 95%;
            max-height: 95%;
            border-radius: 0;
            box-shadow: none;
        }

        /* === CLEAN SCROLLBAR === */
        .left-content::-webkit-scrollbar {
            width: 6px;
        }

        .left-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .left-content::-webkit-scrollbar-thumb {
            background: #E5E7EB;
            border-radius: 3px;
        }

        .left-content::-webkit-scrollbar-thumb:hover {
            background: #D1D5DB;
        }

        @media print {
            body {
                overflow: visible;
            }
            .slide {
                display: block !important;
                page-break-after: always;
            }
            .nav-container {
                display: none !important;
            }
        }

        /* === 控制面板样式 === */
        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }

        .control-label {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
            margin-right: 10px;
        }

        .control-value {
            font-size: 14px;
            font-weight: 700;
            color: #3498db;
            margin-right: 10px;
        }

        .slider {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            opacity: 0.8;
            transition: opacity 0.2s;
            cursor: pointer;
        }

        .slider:hover {
            opacity: 1;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }

        /* === 按钮组样式 === */
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .interactive-btn {
            padding: 8px 16px;
            background: #f8f9fa;
            color: #2c3e50;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .interactive-btn:hover {
            background: #e9ecef;
            border-color: #3498db;
        }

        .interactive-btn.active {
            background: #3498db;
            color: white;
            border-color: #3498db;
        }

        /* === 矩形样式 === */
        .rectangle {
            transition: opacity 0.3s ease;
        }
    </style>
    <style>
        /* 悬浮主按钮与二级按钮（统一样式） */
        .floating-control-btn { position: fixed; bottom: 30px; left: 30px; width: 60px; height: 60px; border-radius: 50%; background: rgba(255,255,255,0.9); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 8px 24px rgba(0,0,0,0.12); cursor: pointer; z-index: 1100; transition: all 0.25s ease; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(10px); font-size: 24px; font-weight: 700; color: #1f2937; }
        .floating-control-btn:hover { transform: translateY(-2px); box-shadow: 0 12px 32px rgba(0,0,0,0.18); }
        .floating-control-btn .btn-icon { transition: transform 0.25s ease; }
        .floating-control-btn.active .btn-icon { transform: rotate(45deg); }
        .floating-menu-items { position: fixed; bottom: 30px; left: 30px; display: flex; align-items: center; gap: 10px; padding-left: 70px; z-index: 1099; pointer-events: none; }
        .floating-menu-item { background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); border-radius: 12px; padding: 10px 14px; box-shadow: 0 8px 24px rgba(0,0,0,0.12); cursor: pointer; transition: all 0.25s ease; display: flex; align-items: center; gap: 8px; min-width: 110px; border: 1px solid rgba(59,130,246,0.2); opacity: 0; transform: scale(0.98); pointer-events: none; }
        .floating-menu-items.active .floating-menu-item { opacity: 1; transform: scale(1); pointer-events: auto; }
        .floating-menu-item:hover { transform: translateY(-2px); box-shadow: 0 12px 32px rgba(0,0,0,0.18); background: rgba(59,130,246,0.06); }
        .floating-menu-item .item-icon { font-size: 16px; min-width: 20px; }
        .floating-menu-item .item-text { font-size: 13px; font-weight: 500; color: #374151; white-space: nowrap; }

        /* 弹层（实验室/本章目录/全部目录） */
        .lab-submenu { display: none; position: fixed; top: 12%; left: 50%; transform: translateX(-50%); width: 92vw; max-width: 1000px; max-height: 76vh; background: rgba(255,255,255,0.98); backdrop-filter: blur(20px); border-radius: 18px; box-shadow: 0 20px 60px rgba(0,0,0,0.25); z-index: 2000; overflow: hidden; }
        .submenu-content { display: flex; flex-direction: column; height: 100%; position: relative; }
        .submenu-title { background: linear-gradient(135deg, #4a90e2, #9b59b6); color: #fff; padding: 16px 24px; font-size: 18px; font-weight: 600; text-align: center; }
        .submenu-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 14px; padding: 20px; overflow-y: auto; max-height: calc(76vh - 96px); }
        .submenu-item { background: rgba(59,130,246,0.06); border: 1px solid rgba(59,130,246,0.18); border-radius: 10px; padding: 12px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 10px; }
        .submenu-item:hover { background: rgba(59,130,246,0.12); border-color: rgba(59,130,246,0.35); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(59,130,246,0.18); }
        .submenu-icon { font-size: 18px; min-width: 22px; }
        .submenu-text { font-size: 14px; color: #374151; font-weight: 500; }
        .submenu-close { position: absolute; top: 10px; right: 14px; width: 36px; height: 36px; border-radius: 50%; border: none; background: rgba(255,255,255,0.3); color: #fff; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
        .submenu-close:hover { background: rgba(255,255,255,0.45); transform: rotate(90deg); }
        /* 目录页样式（第6章） */
        .chapter-toc { margin-top: 28px; display: grid; grid-template-columns: 1fr; gap: 14px; }
         .toc-item { position: relative; padding: 18px; border-radius: 14px; background: rgba(255, 255, 255, 0.8); border: 1px solid rgba(0,0,0,0.06); box-shadow: 0 8px 20px rgba(0,0,0,0.08); transition: transform 0.2s ease, box-shadow 0.2s ease; overflow: hidden; cursor: pointer; }
        .toc-item::before { content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 4px; background: var(--accent-color, #4a90e2); }
        .toc-item:hover { transform: translateY(-2px); box-shadow: 0 14px 30px rgba(0,0,0,0.12); }
        .toc-title { margin: 0; color: var(--accent-color, #4a90e2); font-weight: 700; }
        .toc-desc { margin: 6px 0 0 0; color: #6b7280; }
        .toc-list { margin: 8px 0 0 0; padding-left: 1.2em; color: #6b7280; }
        .toc-list li { margin: 4px 0; }
        .accent-blue { --accent-color: #3498db; }
        .accent-green { --accent-color: #2ecc71; }
        .accent-red { --accent-color: #e74c3c; }
        .accent-purple { --accent-color: #9b59b6; }
        .accent-amber { --accent-color: #f39c12; }
        /* 右侧目录可视化背景增强 */
        #vis-contents { position: relative; }
        #vis-contents::before { content: ''; position: absolute; inset: 0; background:
                radial-gradient(600px 300px at 70% 40%, rgba(59,130,246,0.12), transparent 60%),
                linear-gradient(transparent 59px, rgba(59,130,246,0.06) 60px) repeat; background-size: auto, 60px 60px; z-index: 0; }
        #vis-contents svg { position: relative; z-index: 1; }
    </style>
    <style>
        /* 统一封面样式（与第1/2/3/4/5章一致） */
        .slide-container.cover {
            align-items: stretch;
        }
        .cover-left {
            padding: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .cover-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(90deg, #4a90e2, #9b59b6);
            color: #fff;
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 14px;
            width: fit-content;
            box-shadow: 0 6px 16px rgba(74,144,226,0.35);
        }
        .cover-title {
            font-size: 4rem;
            line-height: 1.1;
            margin: 18px 0 8px 0;
            color: #1a1a2e;
            background: linear-gradient(90deg, #1a1a2e 0%, #4a90e2 60%, #9b59b6 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .cover-subtitle {
            font-size: 1.6rem;
            color: #4f5b6a;
            margin: 10px 0 18px 0;
        }
        .cover-meta {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            color: #6b7b8c;
            font-size: 0.95rem;
        }
        .cover-meta span { display: inline-flex; align-items: center; gap: 6px; }
        .cover-actions {
            display: flex;
            gap: 14px;
            margin-top: 26px;
            flex-wrap: wrap;
        }
        .cover-right {
            position: relative;
            overflow: hidden;
        }
        .cover-visual {
            position: relative;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(1200px 800px at 80% 20%, rgba(155, 89, 182, 0.18), transparent 60%),
                radial-gradient(900px 700px at 20% 80%, rgba(74, 144, 226, 0.18), transparent 60%),
                linear-gradient(135deg, #ffffff 0%, #f7faff 50%, #f9f6ff 100%);
        }
        .cover-visual::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(600px 300px at 50% -10%, rgba(255,255,255,0.7), transparent 70%);
            pointer-events: none;
        }
        .math-badge {
            position: absolute;
            padding: 8px 12px;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(0,0,0,0.06);
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            color: #34495e;
            font-weight: 600;
            animation: floatY 6s ease-in-out infinite;
            backdrop-filter: blur(4px);
        }
        .math-badge.b1 { left: 12%; top: 22%; animation-delay: 0s; }
        .math-badge.b2 { right: 14%; top: 30%; animation-delay: 0.8s; }
        .math-badge.b3 { left: 20%; bottom: 18%; animation-delay: 1.5s; }
        .math-badge.b4 { right: 18%; bottom: 22%; animation-delay: 2.2s; }
        @keyframes floatY {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-12px); }
            100% { transform: translateY(0px); }
        }
        .orbit {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 320px;
            height: 320px;
            margin-left: -160px;
            margin-top: -160px;
            border-radius: 50%;
            border: 1px dashed rgba(52, 152, 219, 0.35);
            animation: spin 18s linear infinite;
        }
        .orbit .dot {
            position: absolute;
            top: -6px;
            left: 50%;
            width: 12px;
            height: 12px;
            margin-left: -6px;
            background: #4a90e2;
            border-radius: 50%;
            box-shadow: 0 0 0 6px rgba(74,144,226,0.15);
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
<style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
    <style>
        /* 返回按钮样式（统一为第1/2章风格） */
        .return-home-panel {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 9999;
            display: flex;
            gap: 10px;
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }
        .return-home-panel:hover { opacity: 1; }
        .return-home-panel .return-link {
            padding: 6px 12px;
            background: rgba(15, 23, 42, 0.7);
            color: #f8fafc;
            text-decoration: none;
            border-radius: 999px;
            font-size: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .return-home-panel .return-link:hover {
            background: rgba(15, 23, 42, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(15, 23, 42, 0.3);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.7);
        }
        .return-home-panel .return-link.return-main:hover {
            background: rgba(79, 70, 229, 0.9);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.3);
        }
    </style>
</head>
<body>
<div id="slidesContainer">
<div class="return-home-panel">
    <a class="return-link" href="../index.html"><i class="fa-solid fa-house"></i> 返回主站</a>
    <a class="return-link return-main" href="javascript:void(0)" onclick="event.stopPropagation(); toggleCourseSubmenu()"><i class="fa-solid fa-arrow-left"></i> 返回目录</a>
</div>
<!-- 第1页：封面 -->
<div class="slide active"><div class="slide-container cover"><div class="left-content tex2jax_process cover-left">
<div class="cover-badge"><i class="fa-solid fa-seedling"></i><span> 第六章</span></div>
<h1 class="cover-title">定积分</h1>
<p class="cover-subtitle">从面积到积分的奇妙之旅</p>
<div class="cover-meta">
<span><i class="fa-solid fa-book-open"></i> 基础篇</span>
<span><i class="fa-solid fa-bolt"></i> 关键概念速览</span>
</div>
<div class="cover-actions">
<a class="home-link-btn" href="../index.html"><span>主页</span></a>
<a class="home-link-btn" href="../故事书/第六章/尼莫的海洋.html"><span>故事书</span></a>
<a class="home-link-btn" href="../习题/assets/definite-integral.html"><span>习题</span></a>
<a class="home-link-btn" href="https://ai.projectmath.xyz/project/index.html"><span>慧工坊</span></a>
</div>
</div><div class="right-visual cover-right"><div class="cover-visual">
<div class="math-badge b1">∫</div>
<div class="math-badge b2">Riemann</div>
<div class="math-badge b3">Σ f(x)Δx</div>
<div class="math-badge b4">NL</div>
<div class="orbit"><span class="dot"></span></div>
<div id="vis-title"></div>
</div></div></div></div>
<!-- 第2页：目录 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>本章内容</h2>
<div class="chapter-toc">
<div class="toc-item accent-blue">
<h3 class="toc-title">1. 定积分的概念</h3>
<ul class="toc-list">
<li>问题引入：不规则图形面积</li>
<li>曲边梯形与分割思想</li>
<li>定积分的定义与几何意义</li>
</ul>
</div>
<div class="toc-item accent-green">
<h3 class="toc-title">2. 定积分的性质与计算</h3>
<ul class="toc-list">
<li>基本性质（线性性、可加性）</li>
<li>牛顿-莱布尼茨公式</li>
<li>计算实例</li>
</ul>
</div>
<div class="toc-item accent-amber">
<h3 class="toc-title">3. 定积分的应用</h3>
<ul class="toc-list">
<li>求平面图形面积</li>
<li>求旋转体体积</li>
<li>物理应用</li>
</ul>
</div>
<div class="toc-item accent-purple">
<h3 class="toc-title">4. 积分方法</h3>
<ul class="toc-list">
<li>常用积分公式</li>
<li>换元积分法</li>
<li>分部积分法</li>
<li>广义积分简介</li>
</ul>
</div>
</div>
</div><div class="right-visual"><div id="vis-contents"></div></div></div></div>
<!-- 第3页：过渡页 - 第一部分 定积分的概念 -->
<div class="slide"><div class="slide-container single-column"><div class="left-content tex2jax_process">
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center;">
<h1 style="font-size: 3rem; color: #3498db; margin-bottom: 2rem;">第一部分</h1>
<h2 style="font-size: 2.5rem; color: #2c3e50; margin-bottom: 1rem;">定积分的概念</h2>
<p style="font-size: 1.5rem; color: #666;">从不规则图形面积到定积分定义</p>
<div style="margin-top: 3rem; padding: 1.5rem; background: #f0f8ff; border-left: 5px solid #3498db; border-radius: 8px;">
<p style="font-size: 1.2rem; color: #2c3e50; margin: 0;">核心内容：曲边梯形、分割求和、极限、定积分定义</p>
</div>
</div>
</div></div></div>
<!-- 第4页：问题引入 - 生活实例 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>生活中的面积问题</h2>
<h3>规则图形很简单</h3>
<ul>
<li>矩形面积 = 长 × 宽</li>
<li>三角形面积 = 底 × 高 ÷ 2</li>
<li>圆形面积 = πr²</li>
</ul>
<h3>但是...</h3>
<p><span class="highlight">不规则图形</span>的面积怎么算？</p>
<p>比如：河流的横截面、山坡的侧面、抛物线下的面积...</p>
<p style="margin-top: 20px"><i class="fa-solid fa-lightbulb"></i> 古人的智慧：把复杂的变成简单的！</p>
</div><div class="right-visual"><div id="vis-intro"></div></div></div></div>
<!-- 第3页：曲边梯形的挑战 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>曲边梯形</h2>
<p>我们来看一个最简单的例子：</p>
<div class="math-formula">
                求 $y = x^2$ 在 $[0, 1]$ 区间下的面积
            </div>
<h3>特点</h3>
<ul>
<li>上边是<span class="highlight">曲线</span></li>
<li>下边是<span class="highlight">x轴</span></li>
<li>左右是<span class="highlight">垂直线</span></li>
</ul>
<p>这种图形叫做<span class="highlight">曲边梯形</span></p>
<p style="margin-top: 15px">问题：曲线让计算变得困难！</p>
</div><div class="right-visual"><div id="vis-curved-trapezoid"></div></div></div></div>
<!-- 第4页：分割思想 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>化曲为直：分割</h2>
<h3>聪明的想法</h3>
<p>把曲边梯形<span class="highlight">切成很多小块</span>！</p>
<p>就像切蛋糕一样，切得越细，越容易处理。</p>
<h3>怎么切？</h3>
<ul>
<li>把区间 [0, 1] 平均分成 n 份</li>
<li>每份宽度 = $\frac{1}{n}$</li>
<li>得到 n 个小条</li>
</ul>
<p style="margin-top: 15px">切分原理：分而治之！</p>
</div><div class="right-visual"><div id="vis-partition"></div></div></div></div>
<!-- 第5页：近似代替 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>以直代曲：近似</h2>
<h3>用矩形代替曲边</h3>
<p>每个小条可以<span class="highlight">近似看成矩形</span>！</p>
<ul>
<li>矩形的宽 = $\frac{1}{n}$</li>
<li>矩形的高 = 函数值 $f(x_i)$</li>
<li>矩形面积 = 宽 × 高</li>
</ul>
<p>虽然有误差，但是<span class="highlight">分得越细，误差越小</span>！</p>
<p style="margin-top: 15px"><i class="fa-solid fa-chart-bar"></i> 近似原理：用简单代替复杂！</p>
</div><div class="right-visual"><div id="vis-approximation"></div></div></div></div>
<!-- 第6页：求和 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>积少成多：求和</h2>
<h3>把所有小矩形面积加起来</h3>
<div class="math-formula">
                总面积 ≈ $\sum_{i=1}^{n} f(x_i) \cdot \frac{1}{n}$
            </div>
<p>这就是<span class="highlight">黎曼和</span>的思想！</p>
<ul>
<li>每个矩形贡献一点面积</li>
<li>加起来就接近真实面积</li>
<li>n 越大，越接近</li>
</ul>
<p style="margin-top: 15px">累加原理：积少成多！</p>
</div><div class="right-visual"><div id="vis-sum"></div></div></div></div>
<!-- 第7页：取极限 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>精益求精：取极限</h2>
<h3>让分割无限细</h3>
<p>当 n → ∞ 时，会发生什么？</p>
<ul>
<li>矩形越来越窄</li>
<li>近似越来越准确</li>
<li>最终得到<span class="highlight">精确值</span>！</li>
</ul>
<div class="math-formula">
                精确面积 = $\lim\limits_{n \to \infty} \sum_{i=1}^{n} f(x_i) \cdot \Delta x$
            </div>
<p style="margin-top: 15px">极限思想：无限接近真理！</p>
</div><div class="right-visual"><div id="vis-limit"></div></div></div></div>
<!-- 第8页：定积分定义 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>定积分</h2>
<h3>正式定义</h3>
<div class="math-formula">
                $\int_a^b f(x) dx = \lim\limits_{n \to \infty} \sum_{i=1}^{n} f(x_i) \cdot \Delta x$
            </div>
<h3>符号含义</h3>
<ul>
<li>$\int$ - 积分号（拉长的S，表示Sum）</li>
<li>$a, b$ - 积分区间</li>
<li>$f(x)$ - 被积函数</li>
<li>$dx$ - 微小的x增量</li>
</ul>
<p style="margin-top: 15px"><i class="fa-solid fa-bullseye"></i> 本质：无限求和的极限！</p>
</div><div class="right-visual"><div id="vis-definition"></div></div></div></div>
<!-- 第9页：几何意义 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>几何意义</h2>
<h3>定积分 = 面积（有符号）</h3>
<ul>
<li>曲线在x轴<span class="highlight">上方</span>：面积为正</li>
<li>曲线在x轴<span class="highlight">下方</span>：面积为负</li>
<li>上下都有：代数和</li>
</ul>
<p>这就是定积分的<span class="highlight">几何意义</span>！</p>
<p>它不仅能算面积，还能分辨正负。</p>
<p style="margin-top: 15px"><i class="fa-solid fa-drafting-compass"></i> 几何直观：有向面积！</p>
</div><div class="right-visual"><div id="vis-geometric-meaning"></div></div></div></div>
<!-- 第10页：过渡页 - 第二部分 定积分的性质与计算 -->
<div class="slide"><div class="slide-container single-column"><div class="left-content tex2jax_process">
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center;">
<h1 style="font-size: 3rem; color: #2ecc71; margin-bottom: 2rem;">第二部分</h1>
<h2 style="font-size: 2.5rem; color: #2c3e50; margin-bottom: 1rem;">定积分的性质与计算</h2>
<p style="font-size: 1.5rem; color: #666;">掌握计算方法，提高运算能力</p>
<div style="margin-top: 3rem; padding: 1.5rem; background: #f0fff4; border-left: 5px solid #2ecc71; border-radius: 8px;">
<p style="font-size: 1.2rem; color: #2c3e50; margin: 0;">核心内容：性质、牛顿-莱布尼茨公式、计算实例</p>
</div>
</div>
</div></div></div>
<!-- 第11页：基本性质 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>定积分的性质</h2>
<h3>1. 线性性质</h3>
<p>$\int_a^b [f(x) + g(x)] dx = \int_a^b f(x) dx + \int_a^b g(x) dx$</p>
<p>$\int_a^b k \cdot f(x) dx = k \cdot \int_a^b f(x) dx$</p>
<h3>2. 区间可加性</h3>
<p>$\int_a^c f(x) dx = \int_a^b f(x) dx + \int_b^c f(x) dx$</p>
<h3>3. 反向积分</h3>
<p>$\int_a^b f(x) dx = -\int_b^a f(x) dx$</p>
<p style="margin-top: 15px"><i class="fa-solid fa-palette"></i> 性质应用：灵活计算！</p>
</div><div class="right-visual"><div id="vis-properties"></div></div></div></div>
<!-- 第11页：牛顿-莱布尼茨公式 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>牛顿-莱布尼茨公式</h2>
<h3>微积分基本定理</h3>
<div class="math-formula">
                $\int_a^b f(x) dx = F(b) - F(a)$
            </div>
<p>其中 $F'(x) = f(x)$（F是f的原函数）</p>
<h3>意义重大！</h3>
<ul>
<li>把<span class="highlight">积分</span>转化为<span class="highlight">求原函数</span></li>
<li>大大简化了计算</li>
<li>连接了微分和积分</li>
</ul>
<p style="margin-top: 15px">🔗 伟大发现：微分与积分互逆！</p>
</div><div class="right-visual"><div id="vis-fundamental-theorem"></div></div></div></div>
<!-- 第12页：计算实例 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>计算实例</h2>
<h3>例1：计算 $\int_0^1 x^2 dx$</h3>
<p>步骤：</p>
<ol>
<li>找原函数：$F(x) = \frac{x^3}{3}$</li>
<li>代入上限：$F(1) = \frac{1}{3}$</li>
<li>代入下限：$F(0) = 0$</li>
<li>作差：$\frac{1}{3} - 0 = \frac{1}{3}$</li>
</ol>
<p>答案：<span class="highlight">$\frac{1}{3}$</span></p>
<p style="margin-top: 15px">验证：这正是我们前面求的面积！</p>
</div><div class="right-visual"><div id="vis-example1"></div></div></div></div>
<!-- 第13页：过渡页 - 第三部分 定积分的应用 -->
<div class="slide"><div class="slide-container single-column"><div class="left-content tex2jax_process">
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center;">
<h1 style="font-size: 3rem; color: #e74c3c; margin-bottom: 2rem;">第三部分</h1>
<h2 style="font-size: 2.5rem; color: #2c3e50; margin-bottom: 1rem;">定积分的应用</h2>
<p style="font-size: 1.5rem; color: #666;">从理论走向实践</p>
<div style="margin-top: 3rem; padding: 1.5rem; background: #fff5f5; border-left: 5px solid #e74c3c; border-radius: 8px;">
<p style="font-size: 1.2rem; color: #2c3e50; margin: 0;">核心内容：平面图形面积、旋转体体积、物理应用</p>
</div>
</div>
</div></div></div>
<!-- 第14页：求面积应用 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>应用：求面积</h2>
<h3>两条曲线围成的面积</h3>
<p>设上方曲线 $y = g(x)$，下方曲线 $y = f(x)$</p>
<div class="math-formula">
                面积 = $\int_a^b [g(x) - f(x)] dx$
            </div>
<h3>例：求 $y = x$ 和 $y = x^2$ 围成的面积</h3>
<ul>
<li>交点：(0,0) 和 (1,1)</li>
<li>$x &gt; x^2$ 在 [0,1] 内</li>
<li>面积 = $\int_0^1 (x - x^2) dx = \frac{1}{6}$</li>
</ul>
</div><div class="right-visual"><div id="vis-area-between"></div></div></div></div>
<!-- 第14页：求体积应用 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>应用：求体积</h2>
<h3>旋转体体积</h3>
<p>将曲线 $y = f(x)$ 绕x轴旋转一周</p>
<div class="math-formula">
                体积 = $\pi \int_a^b [f(x)]^2 dx$
            </div>
<h3>圆盘法</h3>
<ul>
<li>把旋转体切成薄片</li>
<li>每片是一个圆盘</li>
<li>圆盘体积 = $\pi r^2 \cdot \Delta x$</li>
<li>求和取极限得到公式</li>
</ul>
<p style="margin-top: 15px">3D思维：从平面到立体！</p>
</div><div class="right-visual"><div id="vis-volume"></div></div></div></div>
<!-- 第14-1页：面积应用例题详解 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>面积应用例题详解</h2>
<h3>例1：求抛物线与直线围成的面积</h3>
<p><strong>问题</strong>：求由抛物线 $y = x^2$ 和直线 $y = 2x$ 所围成的平面图形的面积。</p>
<div class="example">
<p><strong>解：</strong></p>
<p><span class="highlight">步骤1：求交点</span></p>
<p>令 $x^2 = 2x$，得 $x^2 - 2x = 0$</p>
<p>解得：$x = 0$ 或 $x = 2$</p>
<p>交点为 $(0, 0)$ 和 $(2, 4)$</p>
<p><span class="highlight">步骤2：确定上下曲线</span></p>
<p>在区间 $[0, 2]$ 内，$2x \geq x^2$（直线在上方）</p>
<p><span class="highlight">步骤3：计算面积</span></p>
<div class="math-formula">
$S = \int_0^2 (2x - x^2) dx$
</div>
<div class="math-formula">
$= \left[x^2 - \frac{x^3}{3}\right]_0^2 = 4 - \frac{8}{3} = \frac{4}{3}$
</div>
</div>
</div><div class="right-visual"><div id="vis-area-example1"></div></div></div></div>
<!-- 第14-2页：面积应用例题2 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>面积应用例题2</h2>
<h3>例2：求两条抛物线围成的面积</h3>
<p><strong>问题</strong>：求由 $y = x^2$ 和 $y = \sqrt{x}$ 围成的平面图形的面积。</p>
<div class="example">
<p><strong>解：</strong></p>
<p><span class="highlight">步骤1：求交点</span></p>
<p>令 $x^2 = \sqrt{x}$，即 $x^4 = x$</p>
<p>$x^4 - x = 0$，$x(x^3 - 1) = 0$</p>
<p>解得：$x = 0$ 或 $x = 1$</p>
<p><span class="highlight">步骤2：确定上下曲线</span></p>
<p>在区间 $[0, 1]$ 内，$\sqrt{x} \geq x^2$（根式函数在上方）</p>
<p><span class="highlight">步骤3：计算面积</span></p>
<div class="math-formula">
$S = \int_0^1 (\sqrt{x} - x^2) dx = \int_0^1 (x^{1/2} - x^2) dx$
</div>
<div class="math-formula">
$= \left[\frac{2}{3}x^{3/2} - \frac{x^3}{3}\right]_0^1 = \frac{2}{3} - \frac{1}{3} = \frac{1}{3}$
</div>
</div>
<p style="margin-top: 15px"><strong>关键技巧</strong>：准确判断哪条曲线在上方！</p>
</div><div class="right-visual"><div id="vis-area-example2"></div></div></div></div>
<!-- 第14-3页：旋转体体积例题详解 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>旋转体体积例题详解</h2>
<h3>例1：直线旋转体</h3>
<p><strong>问题</strong>：求由直线 $y = x$、$x = 0$、$x = 1$ 与 $x$ 轴围成的图形绕 $x$ 轴旋转一周所得旋转体的体积。</p>
<div class="example">
<p><strong>解：</strong></p>
<p><span class="highlight">步骤1：确定旋转体形状</span></p>
<p>该图形是一个直角三角形，旋转后形成一个圆锥。</p>
<p><span class="highlight">步骤2：应用圆盘法公式</span></p>
<div class="math-formula">
$V = \pi \int_0^1 [f(x)]^2 dx = \pi \int_0^1 x^2 dx$
</div>
<p><span class="highlight">步骤3：计算积分</span></p>
<div class="math-formula">
$V = \pi \left[\frac{x^3}{3}\right]_0^1 = \pi \cdot \frac{1}{3} = \frac{\pi}{3}$
</div>
</div>
<p style="margin-top: 15px"><strong>验证</strong>：圆锥体积公式 $V = \frac{1}{3}\pi r^2 h = \frac{1}{3}\pi \cdot 1^2 \cdot 1 = \frac{\pi}{3}$ ✓</p>
</div><div class="right-visual"><div id="vis-volume-example1"></div></div></div></div>
<!-- 第14-4页：旋转体体积例题2 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>旋转体体积例题2</h2>
<h3>例2：抛物线旋转体</h3>
<p><strong>问题</strong>：求由抛物线 $y = \sqrt{x}$、直线 $x = 4$ 与 $x$ 轴所围成的图形绕 $x$ 轴旋转一周所得旋转体的体积。</p>
<div class="example">
<p><strong>解：</strong></p>
<p><span class="highlight">步骤1：明确积分区间</span></p>
<p>区间为 $[0, 4]$，旋转函数为 $y = \sqrt{x}$</p>
<p><span class="highlight">步骤2：应用圆盘法</span></p>
<div class="math-formula">
$V = \pi \int_0^4 (\sqrt{x})^2 dx = \pi \int_0^4 x dx$
</div>
<p><span class="highlight">步骤3：计算积分</span></p>
<div class="math-formula">
$V = \pi \left[\frac{x^2}{2}\right]_0^4 = \pi \cdot \frac{16}{2} = 8\pi$
</div>
</div>
<h3>圆环法（两曲线之间旋转）</h3>
<p>若 $R(x) \geq r(x) \geq 0$，绕 $x$ 轴旋转：</p>
<div class="math-formula">
$V = \pi \int_a^b [R^2(x) - r^2(x)] dx$
</div>
<p style="margin-top: 10px"><i class="fa-solid fa-lightbulb"></i> 外半径平方减内半径平方</p>
</div><div class="right-visual"><div id="vis-volume-example2"></div></div></div></div>
<!-- 第14-5页：旋转体体积例题3 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>旋转体体积例题3</h2>
<h3>例3：圆环旋转体</h3>
<p><strong>问题</strong>：求由 $y = x$ 和 $y = x^2$ 在 $[0, 1]$ 上围成的图形绕 $x$ 轴旋转一周所得旋转体的体积。</p>
<div class="example">
<p><strong>解：</strong></p>
<p><span class="highlight">步骤1：判断外内半径</span></p>
<p>在 $[0, 1]$ 内，$x \geq x^2$</p>
<p>外半径：$R(x) = x$</p>
<p>内半径：$r(x) = x^2$</p>
<p><span class="highlight">步骤2：应用圆环法</span></p>
<div class="math-formula">
$V = \pi \int_0^1 [x^2 - (x^2)^2] dx = \pi \int_0^1 (x^2 - x^4) dx$
</div>
<p><span class="highlight">步骤3：计算积分</span></p>
<div class="math-formula">
$V = \pi \left[\frac{x^3}{3} - \frac{x^5}{5}\right]_0^1 = \pi \left(\frac{1}{3} - \frac{1}{5}\right) = \frac{2\pi}{15}$
</div>
</div>
<p style="margin-top: 15px"><strong>记忆口诀</strong>：外减内，平方后再积分！</p>
</div><div class="right-visual"><div id="vis-volume-example3"></div></div></div></div>
<!-- 第15页：物理应用 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>物理应用</h2>
<h3>变力做功</h3>
<p>力 $F(x)$ 从 $x = a$ 到 $x = b$ 做的功：</p>
<div class="math-formula">
                $W = \int_a^b F(x) dx$
            </div>
<h3>路程计算</h3>
<p>已知速度 $v(t)$，求路程：</p>
<div class="math-formula">
                $s = \int_{t_1}^{t_2} v(t) dt$
            </div>
<p>定积分把<span class="highlight">变化的量</span>累积起来！</p>
<p style="margin-top: 15px">实际应用：从理论到实践！</p>
</div><div class="right-visual"><div id="vis-physics"></div></div></div></div>
<!-- 第16页：过渡页 - 第四部分 积分方法 -->
<div class="slide"><div class="slide-container single-column"><div class="left-content tex2jax_process">
<div style="display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center;">
<h1 style="font-size: 3rem; color: #f39c12; margin-bottom: 2rem;">第四部分</h1>
<h2 style="font-size: 2.5rem; color: #2c3e50; margin-bottom: 1rem;">积分方法</h2>
<p style="font-size: 1.5rem; color: #666;">掌握技巧，灵活应用</p>
<div style="margin-top: 3rem; padding: 1.5rem; background: #fffaf0; border-left: 5px solid #f39c12; border-radius: 8px;">
<p style="font-size: 1.2rem; color: #2c3e50; margin: 0;">核心内容：常用公式、换元法、分部积分法、广义积分</p>
</div>
</div>
</div></div></div>
<!-- 第17页：常用积分公式 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>常用积分公式</h2>
<h3>幂函数</h3>
<p>$\int x^n dx = \frac{x^{n+1}}{n+1} + C$ （n ≠ -1）</p>
<h3>指数函数</h3>
<p>$\int e^x dx = e^x + C$</p>
<p>$\int a^x dx = \frac{a^x}{\ln a} + C$</p>
<h3>三角函数</h3>
<p>$\int \sin x dx = -\cos x + C$</p>
<p>$\int \cos x dx = \sin x + C$</p>
<h3>特殊函数</h3>
<p>$\int \frac{1}{x} dx = \ln |x| + C$</p>
<p style="margin-top: 15px">公式记忆：熟能生巧！</p>
</div><div class="right-visual"><div id="vis-formulas"></div></div></div></div>
<!-- 第17页：定积分的换元法 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>定积分的换元积分法</h2>
<h3>换元公式</h3>
<div class="formula-rule tex2jax_process">
$\int_a^b f(x)dx = \int_\alpha^\beta f[\varphi(t)]\varphi'(t)dt$
</div>
<p>其中 $x = \varphi(t)$，当 $x=a$ 时 $t=\alpha$，当 $x=b$ 时 $t=\beta$</p>
<h3>使用条件</h3>
<ul>
<li>$\varphi(t)$ 在 $[\alpha,\beta]$ 上单调且有连续导数</li>
<li>$\varphi(\alpha) = a$，$\varphi(\beta) = b$</li>
<li>$f[\varphi(t)]$ 在 $[\alpha,\beta]$ 上连续</li>
</ul>
<p style="margin-top: 15px">换元法：化难为易！</p>
</div><div class="right-visual"><div id="vis-substitution-method"></div></div></div></div>
<!-- 第18页：换元法例题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>换元法例题</h2>
<h3>例1：求 $\int_0^4 \frac{x}{\sqrt{1+x}}dx$</h3>
<p><span class="highlight">解法思路</span>：令 $t = \sqrt{1+x}$</p>
<ul>
<li>则 $x = t^2 - 1$，$dx = 2t dt$</li>
<li>当 $x=0$ 时，$t=1$；当 $x=4$ 时，$t=\sqrt{5}$</li>
</ul>
<h3>奇偶函数的对称区间积分</h3>
<div class="formula-rule tex2jax_process">
$\int_{-a}^a f(x)dx = \begin{cases} 2\int_0^a f(x)dx, & f(x)为偶函数 \\ 0, & f(x)为奇函数 \end{cases}$
</div>
<p style="margin-top: 15px">技巧：利用对称性简化计算！</p>
</div><div class="right-visual"><div id="vis-substitution-example"></div></div></div></div>
<!-- 第19页：分部积分法 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>定积分的分部积分法</h2>
<h3>分部积分公式</h3>
<div class="formula-rule tex2jax_process">
$\int_a^b u dv = [uv]_a^b - \int_a^b v du$
</div>
<p>或写成：$\int_a^b u(x)v'(x)dx = [u(x)v(x)]_a^b - \int_a^b v(x)u'(x)dx$</p>
<h3>选择u和dv的原则</h3>
<ul>
<li>v容易求：dv容易积分</li>
<li>$\int v du$ 更简单：积分后变简单</li>
<li>常见顺序：<span class="highlight">反对幂指三</span></li>
</ul>
<p style="margin-top: 15px"><i class="fa-solid fa-bullseye"></i> 口诀：反对幂指三，从左到右选u！</p>
</div><div class="right-visual"><div id="vis-parts-method"></div></div></div></div>
<!-- 第20页：分部积分例题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>分部积分例题</h2>
<h3>例：求 $\int_0^{\frac{\pi}{2}} x\sin x dx$</h3>
<p><span class="highlight">解法</span>：</p>
<ul>
<li>令 $u = x$，$dv = \sin x dx$</li>
<li>则 $du = dx$，$v = -\cos x$</li>
</ul>
<h3>天然气开采应用</h3>
<p>某天然气井第t年产量：$P(t) = 8.49 \times 10^6 te^{-t}$ (m³)</p>
<p>前4年总产量：$\int_0^4 P(t)dt$</p>
<p style="margin-top: 15px"><i class="fa-solid fa-lightbulb"></i> 实际应用：分部积分解决实际问题！</p>
</div><div class="right-visual"><div id="vis-parts-example"></div></div></div></div>
<!-- 第21页：广义积分 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>广义积分</h2>
<h3>类型一：无限区间</h3>
<div class="formula-rule tex2jax_process">
$\int_a^{+\infty} f(x)dx = \lim_{b \to +\infty} \int_a^b f(x)dx$
</div>
<h3>例：</h3>
<div class="math-formula">
$\int_0^{+\infty} e^{-x} dx = \lim_{b \to +\infty} \int_0^b e^{-x} dx = \lim_{b \to +\infty} [-e^{-x}]_0^b = \lim_{b \to +\infty} (1 - e^{-b}) = 1$
</div>
<h3>类型二：无界函数（瑕积分）</h3>
<p>若 $\lim\limits_{x \to a^+} f(x) = \infty$，则</p>
<div class="formula-rule tex2jax_process">
$\int_a^b f(x)dx = \lim_{\varepsilon \to 0^+} \int_{a+\varepsilon}^b f(x)dx$
</div>
<h3>例：</h3>
<div class="math-formula">
$\int_0^1 \frac{1}{\sqrt{x}} dx = \lim_{\varepsilon \to 0^+} \int_\varepsilon^1 x^{-\frac{1}{2}} dx = \lim_{\varepsilon \to 0^+} [2\sqrt{x}]_\varepsilon^1 = 2$
</div>
<p style="font-size: 0.9rem; color: #666;">（$x=0$ 为瑕点）</p>
<p style="margin-top: 15px">极限思想：处理无穷大和无界！</p>
</div><div class="right-visual"><div id="vis-improper-integral"></div></div></div></div>
<!-- 第22页：总结 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>总结</h2>
<div style="text-align: left; max-width: 600px; margin: 0 auto">
<h3>定积分的核心思想</h3>
<ul>
<li><span class="highlight">分割</span> - 把复杂问题分解</li>
<li><span class="highlight">近似</span> - 用简单图形代替</li>
<li><span class="highlight">求和</span> - 累积所有贡献</li>
<li><span class="highlight">取极限</span> - 得到精确结果</li>
</ul>
<h3>应用广泛</h3>
<ul>
<li>几何：面积、体积、弧长</li>
<li>物理：功、路程、质心</li>
<li>经济：总收益、总成本</li>
<li>概率：概率密度积分</li>
</ul>
<p style="font-size: 1.5rem; margin-top: 30px">
                    🎓 积分是微积分的核心！
                </p>
</div>
</div><div class="right-visual"><div id="vis-summary"></div></div></div></div>
<!-- 导航按钮 -->
<!-- 全局动画控制面板 -->
<div class="nav-controls" role="navigation" aria-label="幻灯片导航">
    <button class="nav-btn" onclick="previousSlide()" aria-label="上一页" title="上一页 (<i class="fa-solid fa-arrow-left"></i>)"><i class="fa-solid fa-arrow-left"></i> 上一页</button>
    <div class="slide-number" role="status" aria-live="polite">
        <input type="number" id="slideNumberInput" min="1" max="27" value="1"
               onchange="jumpToSlide(this.value)"
               aria-label="当前页码">/<span id="slideNumberTotal">27</span>
    </div>
    <button class="nav-btn" onclick="nextSlide()" aria-label="下一页" title="下一页 (→)">下一页 →</button>
</div>
</div>
<script>
    // 全局变量
    let slides, totalSlides, currentSlide = 0;
    let globalAnimationPlaying = true;
    let globalAnimationSpeed = 1.0;
    let animationFrames = [];
    let animations = {};

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
        console.log('课件初始化中...');
        
        // 检查 D3 是否加载
        if (typeof d3 === 'undefined') {
            console.error('D3.js 未加载！');
            alert('可视化库(D3.js)加载失败，请检查网络连接或刷新页面');
            return;
        }
        console.log('✓ D3.js 已加载，版本:', d3.version);
        
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        console.log('✓ 找到', totalSlides, '个幻灯片');
        
        const counter = document.getElementById('page-indicator');
        
        // 初始化全局动画控制
        initGlobalAnimationControls();
        
        // 初始化浮动菜单
        initFloatingMenu();
        
        // 显示第一页
        showSlide(0);
        console.log('✓ 课件初始化完成');
        
        // 键盘导航
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                nextSlide();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                previousSlide();
            }
        });
        
        // 鼠标滚轮导航
        document.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY > 0) {
                nextSlide();
            } else {
                previousSlide();
            }
        }, { passive: false });
    });

    // 初始化全局动画控制
    function initGlobalAnimationControls() {
        const playPauseBtn = document.getElementById('globalPlayPauseBtn');
        const speedBtn = document.getElementById('globalSpeedBtn');
        
        if (!playPauseBtn || !speedBtn) {
            console.log('全局动画控制按钮未找到，跳过初始化');
            return;
        }
        
        const speedOptions = [0.5, 1, 1.5, 2, 3];
        let currentSpeedIndex = 1;
        
        playPauseBtn.addEventListener('click', () => {
            globalAnimationPlaying = !globalAnimationPlaying;
            playPauseBtn.textContent = globalAnimationPlaying ? '暂停' : '播放';
            playPauseBtn.className = globalAnimationPlaying ? 'global-control-btn' : 'global-control-btn pause';
        });
        
        speedBtn.addEventListener('click', () => {
            currentSpeedIndex = (currentSpeedIndex + 1) % speedOptions.length;
            globalAnimationSpeed = speedOptions[currentSpeedIndex];
            speedBtn.textContent = globalAnimationSpeed.toFixed(1) + 'x';
        });
    }

    // 初始化浮动菜单
    function initFloatingMenu() {
        const menuToggle = document.querySelector('.menu-toggle');
        const menuContent = document.querySelector('.menu-content');
        
        if (menuToggle && menuContent) {
            menuToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                menuContent.classList.toggle('active');
            });
            
            document.addEventListener('click', function() {
                menuContent.classList.remove('active');
            });
            
            menuContent.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }
    }

    // 显示指定幻灯片
    function showSlide(index) {
        if (index < 0 || index >= totalSlides) return;
        
        // 清理上一个动画
        cleanupAnimations();
        
        // 隐藏所有幻灯片
        slides.forEach(slide => slide.classList.remove('active'));
        
        // 显示当前幻灯片
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        
        // 更新页码输入框
        const slideInput = document.getElementById('slideNumberInput');
        const slideTotal = document.getElementById('slideNumberTotal');
        if (slideInput) {
            slideInput.value = currentSlide + 1;
            slideInput.max = totalSlides;
        }
        if (slideTotal) {
            slideTotal.textContent = totalSlides;
        }
        
        // 更新按钮状态
        updateNavButtons();
        
        // 运行对应的可视化
        runVisualization(currentSlide);
        
        // 渲染数学公式
        if (window.MathJax && MathJax.typesetPromise) {
            MathJax.typesetPromise();
        }
    }

    // 下一页
    function nextSlide() {
        if (currentSlide < totalSlides - 1) {
            showSlide(currentSlide + 1);
        }
    }

    // 上一页
    function previousSlide() {
        if (currentSlide > 0) {
            showSlide(currentSlide - 1);
        }
    }

    // 跳转到指定页
    function jumpToSlide(value) {
        const slideNumber = parseInt(value);
        if (slideNumber >= 1 && slideNumber <= totalSlides) {
            currentSlide = slideNumber - 1;
            showSlide(currentSlide);
        }
    }

    // 统一导航API，兼容前面章节用法
    function goToSlide(index) {
        if (typeof showSlide === 'function') {
            showSlide(index);
        } else if (typeof jumpToSlide === 'function') {
            jumpToSlide(index + 1);
        }
    }

    // 更新导航按钮状态
    function updateNavButtons() {
        const navButtons = document.querySelectorAll('.nav-controls .nav-btn');
        if (navButtons.length >= 2) {
            const prevBtn = navButtons[0];
            const nextBtn = navButtons[1];
            
            prevBtn.disabled = (currentSlide === 0);
            nextBtn.disabled = (currentSlide === totalSlides - 1);
            
            // 更新按钮样式
            if (currentSlide === 0) {
                prevBtn.style.opacity = '0.5';
                prevBtn.style.cursor = 'not-allowed';
            } else {
                prevBtn.style.opacity = '1';
                prevBtn.style.cursor = 'pointer';
            }
            
            if (currentSlide === totalSlides - 1) {
                nextBtn.style.opacity = '0.5';
                nextBtn.style.cursor = 'not-allowed';
            } else {
                nextBtn.style.opacity = '1';
                nextBtn.style.cursor = 'pointer';
            }
        }
    }

    // 清理动画
    function cleanupAnimations() {
        animationFrames.forEach(frame => {
            cancelAnimationFrame(frame);
        });
        animationFrames = [];
        
        // 清理各种定时器
        Object.values(animations).forEach(anim => {
            if (anim.timer) clearTimeout(anim.timer);
            if (anim.interval) clearInterval(anim.interval);
        });
        animations = {};
    }

    // ========== 通用辅助函数 ==========
    
    // D3 容器设置辅助函数
    function setupD3(containerId) {
        const container = d3.select(`#${containerId}`);
        if (!container.node()) {
            console.error(`容器 #${containerId} 不存在`);
            return null;
        }
        
        container.selectAll('*').remove();
        
        const rect = container.node().getBoundingClientRect();
        const width = rect.width - 40 || 460;  // 减去padding
        const height = rect.height - 40 || 360;
        
        if (width <= 0 || height <= 0) {
            console.error(`容器 #${containerId} 尺寸无效: ${width}x${height}`);
            return null;
        }
        
        const svg = container.append('svg')
            .attr('width', width + 40)
            .attr('height', height + 40)
            .style('position', 'absolute')
            .style('top', 0)
            .style('left', 0);
        
        const g = svg.append('g')
            .attr('transform', 'translate(20, 20)');
        
        return { container, svg, g, width, height };
    }
    
    // 步骤化可视化：展示解题步骤（支持MathJax渲染）
    function visualizeStepByStep(containerId, steps) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        // 清空容器
        container.innerHTML = '';
        
        // 获取容器尺寸
        const rect = container.getBoundingClientRect();
        const width = rect.width - 40 || 460;
        const height = rect.height - 40 || 360;
        
        // 计算每个步骤的高度
        const stepHeight = Math.max(Math.min((height - 20) / steps.length, 85), 60);
        const totalHeight = stepHeight * steps.length;
        const startY = Math.max((height - totalHeight) / 2, 10);
        
        // 创建SVG用于装饰元素
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width + 40)
            .attr('height', height + 40)
            .style('position', 'absolute')
            .style('top', 0)
            .style('left', 0)
            .style('pointer-events', 'none');
        
        const g = svg.append('g')
            .attr('transform', 'translate(20, 20)');
        
        // 为每个步骤创建内容
        steps.forEach((step, i) => {
            const yPos = startY + i * stepHeight;
            
            // SVG圆圈和序号
            const stepGroup = g.append('g')
                .attr('transform', `translate(0, ${yPos})`)
                .style('opacity', 0);
            
            stepGroup.append('circle')
                .attr('cx', 25)
                .attr('cy', stepHeight / 2)
                .attr('r', 14)
                .attr('fill', step.color)
                .attr('stroke', '#fff')
                .attr('stroke-width', 2);
            
            stepGroup.append('text')
                .attr('x', 25)
                .attr('y', stepHeight / 2)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('fill', 'white')
                .attr('font-weight', 'bold')
                .attr('font-size', '11px')
                .text(i + 1);
            
            // 创建HTML内容区域
            const contentDiv = document.createElement('div');
            contentDiv.className = 'step-content';
            contentDiv.style.position = 'absolute';
            contentDiv.style.left = '65px';
            contentDiv.style.top = `${yPos + 20}px`;
            contentDiv.style.width = `${width - 55}px`;
            contentDiv.style.minHeight = `${stepHeight - 10}px`;
            contentDiv.style.display = 'flex';
            contentDiv.style.flexDirection = 'column';
            contentDiv.style.justifyContent = 'center';
            contentDiv.style.opacity = '0';
            contentDiv.style.transition = 'opacity 0.5s';
            
            // 标题
            if (step.title) {
                const titleDiv = document.createElement('div');
                titleDiv.style.fontSize = '12px';
                titleDiv.style.color = '#7f8c8d';
                titleDiv.style.marginBottom = '4px';
                titleDiv.style.fontWeight = '500';
                titleDiv.textContent = step.title;
                contentDiv.appendChild(titleDiv);
            }
            
            // 公式或文本
            const formulaDiv = document.createElement('div');
            formulaDiv.className = 'tex2jax_process';
            formulaDiv.style.fontSize = '15px';
            formulaDiv.style.color = '#2c3e50';
            formulaDiv.style.lineHeight = '1.8';
            formulaDiv.innerHTML = step.formula ? `\\[${step.formula}\\]` : step.text || '';
            contentDiv.appendChild(formulaDiv);
            
            container.appendChild(contentDiv);
            
            // 动画显示
            setTimeout(() => {
                stepGroup.style('opacity', 1);
                contentDiv.style.opacity = '1';
            }, i * 350);
        });
        
        // 触发MathJax重新渲染
        setTimeout(() => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([container]).catch((err) => console.log(err));
            }
        }, steps.length * 350 + 300);
    }
    
    // 运行可视化
    function runVisualization(slideIndex) {
        console.log('运行可视化，幻灯片索引:', slideIndex);
        
        try {
            switch(slideIndex) {
                case 0: visualizeTitlePage(); break;
                case 1: visualizeContents(); break;
                case 2: visualizeSection1(); break; // 新增：第一部分过渡页
                case 3: visualizeIntro(); break;
                case 4: visualizeCurvedTrapezoid(); break;
                case 5: visualizePartition(); break;
                case 6: visualizeApproximation(); break;
                case 7: visualizeSum(); break;
                case 8: visualizeLimit(); break;
                case 9: visualizeDefinition(); break;
                case 10: visualizeGeometricMeaning(); break;
                case 11: visualizeSection2(); break; // 新增：第二部分过渡页
                case 12: visualizeProperties(); break;
                case 13: visualizeFundamentalTheorem(); break;
                case 14: visualizeExample1(); break;
                case 15: visualizeSection3(); break; // 新增：第三部分过渡页
                case 16: visualizeAreaBetween(); break;
                case 17: visualizeVolume(); break;
                case 18: visualizeAreaExample1(); break;
                case 19: visualizeAreaExample2(); break;
                case 20: visualizeVolumeExample1(); break;
                case 21: visualizeVolumeExample2(); break;
                case 22: visualizeVolumeExample3(); break;
                case 23: visualizePhysics(); break;
                case 24: visualizeSection4(); break; // 新增：第四部分过渡页
                case 25: visualizeFormulas(); break;
                case 26: visualizeSubstitutionMethod(); break;
                case 27: visualizeSubstitutionExample(); break;
                case 28: visualizePartsMethod(); break;
                case 29: visualizePartsExample(); break;
                case 30: visualizeImproperIntegral(); break;
                case 31: visualizeSummary(); break;
                default:
                    console.warn('没有为幻灯片', slideIndex, '定义可视化');
            }
        } catch (error) {
            console.error('可视化错误:', error);
        }
    }

    // 第1页：标题页可视化
    function visualizeTitlePage() {
        console.log('visualizeTitlePage 被调用');
        const container = d3.select('#vis-title');
        console.log('容器元素:', container.node());
        
        if (!container.node()) {
            console.error('容器元素 #vis-title 不存在！');
            return;
        }
        
        container.selectAll('*').remove();
        
        const rect = container.node().getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        console.log('容器尺寸:', width, 'x', height);
        
        if (width === 0 || height === 0) {
            console.error('容器尺寸为0！');
            return;
        }
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 创建积分符号和区域
        const integralSymbol = g.append('text')
            .attr('text-anchor', 'middle')
            .attr('font-size', '100px')
            .attr('fill', '#3498db')
            .attr('font-weight', 'bold')
            .text('∫')
            .style('opacity', 0);
        
        integralSymbol.transition()
            .duration(1000)
            .style('opacity', 1);
        
        // 添加上下限
        g.append('text')
            .attr('x', 50)
            .attr('y', -30)
            .attr('font-size', '24px')
            .attr('fill', '#e74c3c')
            .text('b')
            .style('opacity', 0)
            .transition()
            .delay(800)
            .duration(800)
            .style('opacity', 1);
        
        g.append('text')
            .attr('x', 50)
            .attr('y', 40)
            .attr('font-size', '24px')
            .attr('fill', '#e74c3c')
            .text('a')
            .style('opacity', 0)
            .transition()
            .delay(800)
            .duration(800)
            .style('opacity', 1);
        
        // 添加f(x)dx
        g.append('text')
            .attr('x', 100)
            .attr('font-size', '40px')
            .attr('fill', '#2ecc71')
            .text('f(x)dx')
            .style('opacity', 0)
            .transition()
            .delay(1500)
            .duration(1000)
            .style('opacity', 1);
        
        // 添加装饰性面积形状
        const areaPath = d3.area()
            .x((d, i) => (i - 10) * 15)
            .y0(80)
            .y1(d => 80 - Math.sin(d * 0.5) * 30)
            .curve(d3.curveBasis);
        
        const areaData = d3.range(0, 20).map(i => i);
        
        g.append('path')
            .datum(areaData)
            .attr('d', areaPath)
            .attr('fill', '#9b59b6')
            .attr('opacity', 0.3)
            .style('opacity', 0)
            .transition()
            .delay(2000)
            .duration(1200)
            .style('opacity', 1);
    }

    // ========== 可视化函数（优化版） ==========

    // 第2页：目录页可视化
    function visualizeContents() {
        const container = d3.select('#vis-contents');
        if (!container.node()) return;
        
        container.selectAll('*').remove();
        
        const rect = container.node().getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        if (width === 0 || height === 0) return;
        
        const svg = container.append('svg').attr('width', width).attr('height', height);
        const g = svg.append('g').attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 数据（含跳转索引）
        const sections = [
            { num: '1', color: '#3498db', angle: 0,                 label: '概念',         slide: 2 },
            { num: '2', color: '#2ecc71', angle: Math.PI / 2,       label: '性质与计算',   slide: 11 },
            { num: '3', color: '#f39c12', angle: Math.PI,           label: '应用',         slide: 15 },
            { num: '4', color: '#9b59b6', angle: 3 * Math.PI / 2,   label: '方法',         slide: 24 }
        ];
        const radius = Math.min(width, height) * 0.28;
        
        // 从中心发出的连接线
        sections.forEach((sec, i) => {
            const x = radius * Math.cos(sec.angle);
            const y = radius * Math.sin(sec.angle);
            g.append('line')
                .attr('x1', 0).attr('y1', 0)
                .attr('x2', 0).attr('y2', 0)
                .attr('stroke', sec.color)
                .attr('stroke-opacity', 0.28)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '4 8')
                .transition().delay(200 + i * 200).duration(800)
                .attr('x2', x).attr('y2', y);
        });
        
        // 中心圆与符号
        const center = g.append('g').style('opacity', 0);
        center.append('circle')
            .attr('r', 52)
            .attr('fill', '#ffffff')
            .attr('stroke', '#93c5fd')
            .attr('stroke-width', 2)
            .attr('opacity', 0.95);
        center.append('text')
            .attr('text-anchor', 'middle')
            .attr('dy', '0.35em')
            .attr('font-size', '42px')
            .attr('fill', '#3b82f6')
            .attr('font-weight', '700')
            .text('∫');
        center.transition().delay(400).duration(800).style('opacity', 1);
        
        // 节点与标签
        sections.forEach((sec, i) => {
            const x = radius * Math.cos(sec.angle);
            const y = radius * Math.sin(sec.angle);
            const node = g.append('g')
                .attr('transform', `translate(${x}, ${y})`)
                .style('opacity', 0)
                .style('cursor', 'pointer')
                .on('mouseover', function() { d3.select(this).select('circle.core').transition().duration(150).attr('r', 22); })
                .on('mouseout', function() { d3.select(this).select('circle.core').transition().duration(150).attr('r', 20); })
                .on('click', function() { if (window.goToSlide && sec.slide != null) { try { goToSlide(sec.slide); } catch (_) {} } });
            
            node.append('circle').attr('r', 36).attr('fill', sec.color).attr('opacity', 0.14);
            node.append('circle').attr('class', 'core').attr('r', 20).attr('fill', '#ffffff').attr('stroke', sec.color).attr('stroke-width', 3);
            node.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                .attr('font-size', '18px')
                .attr('fill', sec.color)
                .attr('font-weight', 'bold')
                .text(sec.num);
            
            // 标签
            node.append('text')
                .attr('text-anchor', 'middle')
                .attr('y', 36)
                .attr('font-size', '14px')
                .attr('fill', '#666')
                .text(sec.label);
            
            node.transition().delay(450 + i * 250).duration(800).style('opacity', 1);
        });
    }

    // 第3页：第一部分过渡页可视化
    function visualizeSection1() {
        visualizeSectionTransition('vis-section1', '1', '#3498db');
    }

    // 第11页：第二部分过渡页可视化
    function visualizeSection2() {
        visualizeSectionTransition('vis-section2', '2', '#2ecc71');
    }

    // 第15页：第三部分过渡页可视化
    function visualizeSection3() {
        visualizeSectionTransition('vis-section3', '3', '#e74c3c');
    }

    // 第24页：第四部分过渡页可视化
    function visualizeSection4() {
        visualizeSectionTransition('vis-section4', '4', '#f39c12');
    }

    // 通用的section过渡页可视化函数
    function visualizeSectionTransition(containerId, sectionNumber, color) {
        const container = d3.select('#' + containerId);
        if (!container.node()) return;
        
        container.selectAll('*').remove();
        
        const rect = container.node().getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        
        if (width === 0 || height === 0) return;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const g = svg.append('g')
            .attr('transform', `translate(${width/2}, ${height/2})`);
        
        // 创建大号数字
        g.append('text')
            .attr('text-anchor', 'middle')
            .attr('font-size', '120px')
            .attr('fill', color)
            .attr('font-weight', 'bold')
            .text(sectionNumber)
            .style('opacity', 0)
            .transition()
            .duration(1000)
            .style('opacity', 0.3);
        
        // 创建装饰圆圈
        const circles = [
            { r: 80, delay: 0 },
            { r: 120, delay: 200 },
            { r: 160, delay: 400 }
        ];
        
        circles.forEach(c => {
            g.append('circle')
                .attr('r', c.r)
                .attr('fill', 'none')
                .attr('stroke', color)
                .attr('stroke-width', 2)
                .style('opacity', 0)
                .transition()
                .delay(c.delay)
                .duration(1000)
                .style('opacity', 0.4);
        });
    }

    // 第4页：引入可视化 - 增强版
    function visualizeIntro() {
        const container = d3.select('#vis-intro');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        // 创建渐变
        const defs = svg.append('defs');
        const gradient = defs.append('linearGradient')
            .attr('id', 'intro-gradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        
        gradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#667eea')
            .style('stop-opacity', 0.8);
        
        gradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#764ba2')
            .style('stop-opacity', 0.8);
        
        const margin = {top: 40, right: 40, bottom: 40, left: 40};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 动画展示不同图形
        const shapes = [
            { type: 'rect', x: innerWidth * 0.15, y: innerHeight * 0.3, label: '矩形', color: '#3498db' },
            { type: 'triangle', x: innerWidth * 0.4, y: innerHeight * 0.3, label: '三角形', color: '#2ecc71' },
            { type: 'circle', x: innerWidth * 0.65, y: innerHeight * 0.3, label: '圆形', color: '#f39c12' },
            { type: 'curve', x: innerWidth * 0.85, y: innerHeight * 0.3, label: '？？？', color: '#e74c3c' }
        ];
        
        shapes.forEach((shape, i) => {
            const shapeG = g.append('g')
                .attr('transform', `translate(${shape.x}, ${shape.y})`)
                .style('opacity', 0);
            
            if (shape.type === 'rect') {
                shapeG.append('rect')
                    .attr('x', -50)
                    .attr('y', -30)
                    .attr('width', 100)
                    .attr('height', 60)
                    .attr('fill', shape.color)
                    .attr('opacity', 0.6);
            } else if (shape.type === 'triangle') {
                shapeG.append('polygon')
                    .attr('points', '0,-30 -50,30 50,30')
                    .attr('fill', shape.color)
                    .attr('opacity', 0.6);
            } else if (shape.type === 'circle') {
                shapeG.append('circle')
                    .attr('r', 35)
                    .attr('fill', shape.color)
                    .attr('opacity', 0.6);
            } else if (shape.type === 'curve') {
                // 创建一个动态的曲线
                const curveData = d3.range(-50, 51, 2).map(x => ({
                    x: x,
                    y: 20 * Math.sin(x * 0.1) * Math.cos(x * 0.05)
                }));
                
                const line = d3.line()
                    .x(d => d.x)
                    .y(d => d.y)
                    .curve(d3.curveCardinal);
                
                shapeG.append('path')
                    .datum(curveData)
                    .attr('d', line)
                    .attr('fill', 'none')
                    .attr('stroke', shape.color)
                    .attr('stroke-width', 3);
                
                // 问号动画
                const question = shapeG.append('text')
                    .attr('y', -50)
                    .attr('text-anchor', 'middle')
                    .text('?')
                    .style('font-size', '48px')
                    .style('fill', shape.color)
                    .style('font-weight', 'bold');
                
                question.transition()
                    .duration(1000)
                    .attr('transform', 'rotate(360)')
                    .transition()
                    .duration(1000)
                    .attr('transform', 'rotate(0)')
                    .on('end', function repeat() {
                        d3.select(this)
                            .transition()
                            .duration(2000)
                            .attr('transform', 'rotate(360)')
                            .transition()
                            .duration(2000)
                            .attr('transform', 'rotate(0)')
                            .on('end', repeat);
                    });
            }
            
            shapeG.append('text')
                .attr('y', 60)
                .attr('text-anchor', 'middle')
                .text(shape.label)
                .style('font-size', '16px')
                .style('fill', '#2c3e50')
                .style('font-weight', 'bold');
            
            shapeG.transition()
                .delay(i * 300)
                .duration(800)
                .style('opacity', 1)
                .attr('transform', `translate(${shape.x}, ${shape.y}) scale(1.1)`)
                .transition()
                .duration(400)
                .attr('transform', `translate(${shape.x}, ${shape.y}) scale(1)`);
        });
    }

    // 第3页：曲边梯形可视化 - 增强版
    function visualizeCurvedTrapezoid() {
        const container = d3.select('#vis-curved-trapezoid');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 1])
            .range([innerHeight, 0]);
        
        // X轴
        g.append('g')
            .attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale))
            .append('text')
            .attr('x', innerWidth)
            .attr('y', 35)
            .attr('fill', 'black')
            .text('x')
            .style('font-size', '16px');
        
        // Y轴
        g.append('g')
            .call(d3.axisLeft(yScale))
            .append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -35)
            .attr('x', 0)
            .attr('fill', 'black')
            .text('y')
            .style('font-size', '16px');
        
        // 曲线数据
        const curveData = d3.range(0, 1.01, 0.01).map(x => ({
            x: x,
            y: x * x
        }));
        
        // 填充区域 - 渐变效果
        const areaGradient = svg.append('defs')
            .append('linearGradient')
            .attr('id', 'area-gradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '0%').attr('y2', '100%');
        
        areaGradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#3498db')
            .style('stop-opacity', 0.6);
        
        areaGradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#3498db')
            .style('stop-opacity', 0.1);
        
        const area = d3.area()
            .x(d => xScale(d.x))
            .y0(innerHeight)
            .y1(d => yScale(d.y));
        
        const areaPath = g.append('path')
            .datum(curveData)
            .attr('d', area)
            .attr('fill', 'url(#area-gradient)')
            .attr('opacity', 0);
        
        // 动画填充
        areaPath.transition()
            .duration(1500)
            .attr('opacity', 1);
        
        // 曲线
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        const path = g.append('path')
            .datum(curveData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        // 曲线绘制动画
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);
        
        // 标注
        g.append('text')
            .attr('x', xScale(0.7))
            .attr('y', yScale(0.7 * 0.7))
            .text('y = x²')
            .style('font-size', '18px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .transition()
            .delay(2000)
            .duration(500)
            .style('opacity', 1);
        
        // 垂直线动画
        const leftLine = g.append('line')
            .attr('x1', xScale(0))
            .attr('x2', xScale(0))
            .attr('y1', yScale(0))
            .attr('y2', yScale(0))
            .attr('stroke', '#2c3e50')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        
        leftLine.transition()
            .delay(500)
            .duration(1000)
            .attr('y2', yScale(1));
        
        const rightLine = g.append('line')
            .attr('x1', xScale(1))
            .attr('x2', xScale(1))
            .attr('y1', yScale(0))
            .attr('y2', yScale(0))
            .attr('stroke', '#2c3e50')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        
        rightLine.transition()
            .delay(1000)
            .duration(1000)
            .attr('y2', yScale(1));
    }

    // 第4页：分割可视化 - 增强版
    function visualizePartition() {
        const container = d3.select('#vis-partition');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 创建控制面板
        const controlPanel = container.append('div')
            .attr('class', 'control-panel');
        
        controlPanel.append('label')
            .attr('class', 'control-label')
            .style('font-size', '14px')
            .text('分割数量 n = ');
        
        const nValue = controlPanel.append('span')
            .attr('class', 'control-value')
            .style('font-size', '15px')
            .text('4');
        
        const slider = controlPanel.append('input')
            .attr('type', 'range')
            .attr('class', 'slider')
            .attr('min', '2')
            .attr('max', '50')
            .attr('value', '4');
        
        // 坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 1])
            .range([innerHeight, 0]);
        
        // X轴
        g.append('g')
            .attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        // Y轴
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 曲线
        const curveData = d3.range(0, 1.01, 0.01).map(x => ({
            x: x,
            y: x * x
        }));
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .datum(curveData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        // 更新函数
        function update(n) {
            nValue.text(n);
            
            // 清除旧的分割线和矩形
            g.selectAll('.partition-line').remove();
            g.selectAll('.partition-rect').remove();
            
            // 绘制矩形
            for (let i = 0; i < n; i++) {
                const x = i / n;
                const width = 1 / n;
                const height = x * x;
                
                // 矩形
                g.append('rect')
                    .attr('class', 'partition-rect')
                    .attr('x', xScale(x))
                    .attr('y', yScale(height))
                    .attr('width', xScale(width) - xScale(0))
                    .attr('height', yScale(0) - yScale(height))
                    .attr('fill', d3.interpolateRainbow(i / n))
                    .attr('stroke', '#2980b9')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0)
                    .transition()
                    .delay(i * (500 / n))
                    .duration(300)
                    .attr('opacity', 0.3);
                
                // 分割线
                g.append('line')
                    .attr('class', 'partition-line')
                    .attr('x1', xScale(x))
                    .attr('x2', xScale(x))
                    .attr('y1', yScale(0))
                    .attr('y2', yScale(height))
                    .attr('stroke', '#3498db')
                    .attr('stroke-width', 1)
                    .attr('stroke-dasharray', '3,3')
                    .attr('opacity', 0)
                    .transition()
                    .delay(i * (500 / n))
                    .duration(300)
                    .attr('opacity', 0.7);
            }
        }
        
        // 初始显示
        update(4);
        
        // 滑块事件
        slider.on('input', function() {
            update(+this.value);
        });
        
        // 自动演示
        let autoN = 4;
        let direction = 1;
        const autoPlay = setInterval(() => {
            if (!globalAnimationPlaying) return;
            
            autoN += direction * 2;
            if (autoN >= 20) direction = -1;
            if (autoN <= 4) direction = 1;
            
            slider.property('value', autoN);
            update(autoN);
        }, 2000 / globalAnimationSpeed);
        
        animations.partition = { interval: autoPlay };
    }

    // 继续优化其他可视化函数...
    // 由于代码过长，我将提供关键的优化示例

    // 第7页：取极限可视化 - 增强版
    function visualizeLimit() {
        const container = d3.select('#vis-limit');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 60, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 标题
        g.append('text')
            .attr('x', innerWidth / 2)
            .attr('y', -30)
            .attr('text-anchor', 'middle')
            .style('font-size', '20px')
            .style('font-weight', 'bold')
            .text('n → ∞ 时的极限过程');
        
        // 坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 1])
            .range([innerHeight, 0]);
        
        // X轴
        g.append('g')
            .attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        // Y轴
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 曲线
        const curveData = d3.range(0, 1.01, 0.01).map(x => ({
            x: x,
            y: x * x
        }));
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .datum(curveData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        // 显示精确值
        const exactValue = g.append('text')
            .attr('x', innerWidth / 2)
            .attr('y', -10)
            .attr('text-anchor', 'middle')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .style('fill', '#2ecc71')
            .text('精确值 = 1/3 ≈ 0.3333');
        
        // 当前信息显示
        const infoDisplay = g.append('g')
            .attr('transform', `translate(${innerWidth - 150}, 30)`);
        
        infoDisplay.append('rect')
            .attr('x', -10)
            .attr('y', -25)
            .attr('width', 160)
            .attr('height', 80)
            .attr('fill', 'rgba(255, 255, 255, 0.9)')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2)
            .attr('rx', 5);
        
        const nText = infoDisplay.append('text')
            .attr('y', 0)
            .style('font-size', '15px')
            .style('font-weight', '600')
            .text('n = 2');
        
        const sumText = infoDisplay.append('text')
            .attr('y', 25)
            .style('font-size', '15px')
            .style('font-weight', '600')
            .text('Sum ≈ 0.2500');
        
        const errorText = infoDisplay.append('text')
            .attr('y', 50)
            .style('font-size', '14px')
            .style('font-weight', '600')
            .style('fill', '#e74c3c')
            .text('Error: 25.0%');
        
        // 动画：逐渐增加矩形数量
        let currentN = 2;
        
        function animate() {
            if (!globalAnimationPlaying) {
                setTimeout(animate, 100);
                return;
            }
            
            if (currentN > 100) {
                currentN = 2;
            }
            
            g.selectAll('.rect').remove();
            
            let sum = 0;
            for (let i = 0; i < currentN; i++) {
                const x = i / currentN;
                const width = 1 / currentN;
                const height = x * x;
                sum += width * height;
                
                g.append('rect')
                    .attr('class', 'rect')
                    .attr('x', xScale(x))
                    .attr('y', yScale(height))
                    .attr('width', xScale(width) - xScale(0))
                    .attr('height', yScale(0) - yScale(height))
                    .attr('fill', '#3498db')
                    .attr('stroke', '#2980b9')
                    .attr('stroke-width', 0.5)
                    .attr('opacity', 0.3 + 0.3 * (1 - currentN / 100));
            }
            
            // 更新显示
            nText.text(`n = ${currentN}`);
            sumText.text(`Sum ≈ ${sum.toFixed(4)}`);
            const error = Math.abs(sum - 1/3) / (1/3) * 100;
            errorText.text(`Error: ${error.toFixed(1)}%`);
            
            // 更新颜色
            if (error < 5) {
                errorText.style('fill', '#2ecc71');
            } else if (error < 10) {
                errorText.style('fill', '#f39c12');
            } else {
                errorText.style('fill', '#e74c3c');
            }
            
            currentN = Math.min(currentN * 1.2, 100);
            if (currentN >= 100) currentN = Math.floor(currentN);
            
            setTimeout(animate, 1500 / globalAnimationSpeed);
        }
        
        animate();
    }

    // 其他可视化函数保持原有逻辑，但添加更多动画效果和交互性...
    
    // 第5页：近似代替可视化
    function visualizeApproximation() {
        const container = d3.select('#vis-approximation');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 创建按钮组
        const buttonGroup = container.append('div')
            .attr('class', 'button-group')
            .style('position', 'absolute')
            .style('bottom', '20px')
            .style('left', '50%')
            .style('transform', 'translateX(-50%)');
        
        const leftBtn = buttonGroup.append('button')
            .attr('class', 'interactive-btn')
            .text('左端点');
        
        const midBtn = buttonGroup.append('button')
            .attr('class', 'interactive-btn')
            .text('中点');
        
        const rightBtn = buttonGroup.append('button')
            .attr('class', 'interactive-btn')
            .text('右端点');
        
        // 坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 1])
            .range([innerHeight, 0]);
        
        // X轴
        g.append('g')
            .attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        // Y轴
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 曲线
        const curveData = d3.range(0, 1.01, 0.01).map(x => ({
            x: x,
            y: x * x
        }));
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .datum(curveData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        const n = 8;
        
        // 绘制矩形函数
        function drawRectangles(type) {
            g.selectAll('.rect').remove();
            g.selectAll('.point').remove();
            
            buttonGroup.selectAll('button').classed('active', false);
            if (type === 'left') leftBtn.classed('active', true);
            else if (type === 'mid') midBtn.classed('active', true);
            else rightBtn.classed('active', true);
            
            for (let i = 0; i < n; i++) {
                const x = i / n;
                const width = 1 / n;
                let height, pointX;
                
                if (type === 'left') {
                    height = x * x;
                    pointX = x;
                } else if (type === 'right') {
                    height = (x + width) * (x + width);
                    pointX = x + width;
                } else {
                    height = (x + width/2) * (x + width/2);
                    pointX = x + width/2;
                }
                
                // 绘制矩形
                const rect = g.append('rect')
                    .attr('class', 'rect rectangle')
                    .attr('x', xScale(x))
                    .attr('y', yScale(height))
                    .attr('width', xScale(width) - xScale(0))
                    .attr('height', yScale(0) - yScale(height))
                    .attr('fill', d3.interpolateBlues(0.3 + i * 0.7 / n))
                    .attr('stroke', '#2980b9')
                    .attr('stroke-width', 1)
                    .attr('opacity', 0);
                
                rect.transition()
                    .delay(i * 50)
                    .duration(300)
                    .attr('opacity', 0.5);
                
                // 绘制采样点
                g.append('circle')
                    .attr('class', 'point')
                    .attr('cx', xScale(pointX))
                    .attr('cy', yScale(pointX * pointX))
                    .attr('r', 0)
                    .attr('fill', '#e74c3c')
                    .transition()
                    .delay(i * 50 + 150)
                    .duration(300)
                    .attr('r', 4);
                
                // 添加鼠标悬停事件
                rect.on('mouseover', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('opacity', 0.8);
                    
                    // 显示面积
                    const area = width * height;
                    g.append('text')
                        .attr('class', 'area-text')
                        .attr('x', xScale(x + width/2))
                        .attr('y', yScale(height/2))
                        .attr('text-anchor', 'middle')
                        .style('font-size', '12px')
                        .style('fill', '#2c3e50')
                        .style('font-weight', 'bold')
                        .text(area.toFixed(4));
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .transition()
                        .duration(200)
                        .attr('opacity', 0.5);
                    g.selectAll('.area-text').remove();
                });
            }
        }
        
        // 初始显示左端点
        drawRectangles('left');
        
        // 按钮事件
        leftBtn.on('click', () => drawRectangles('left'));
        midBtn.on('click', () => drawRectangles('mid'));
        rightBtn.on('click', () => drawRectangles('right'));
        
        // 自动轮播
        let currentType = 0;
        const types = ['left', 'mid', 'right'];
        const autoPlay = setInterval(() => {
            if (!globalAnimationPlaying) return;
            currentType = (currentType + 1) % 3;
            drawRectangles(types[currentType]);
        }, 3000 / globalAnimationSpeed);
        
        animations.approximation = { interval: autoPlay };
    }

    // 第6页：求和可视化
    function visualizeSum() {
        const container = d3.select('#vis-sum');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 60, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 1])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 1])
            .range([innerHeight, 0]);
        
        // X轴
        g.append('g')
            .attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        // Y轴
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 曲线
        const curveData = d3.range(0, 1.01, 0.01).map(x => ({
            x: x,
            y: x * x
        }));
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        g.append('path')
            .datum(curveData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        const n = 10;
        let sum = 0;
        
        // 显示求和过程
        const sumDisplay = g.append('text')
            .attr('x', innerWidth / 2)
            .attr('y', -30)
            .attr('text-anchor', 'middle')
            .style('font-size', '20px')
            .style('font-weight', 'bold')
            .text('Sum = 0');
        
        // 进度条
        const progressBar = g.append('rect')
            .attr('x', 0)
            .attr('y', -10)
            .attr('width', 0)
            .attr('height', 5)
            .attr('fill', '#2ecc71');
        
        // 绘制矩形并计算和
        for (let i = 0; i < n; i++) {
            setTimeout(() => {
                const x = i / n;
                const width = 1 / n;
                const height = x * x;
                const area = width * height;
                
                // 矩形
                g.append('rect')
                    .attr('x', xScale(x))
                    .attr('y', yScale(height))
                    .attr('width', xScale(width) - xScale(0))
                    .attr('height', yScale(0) - yScale(height))
                    .attr('fill', d3.interpolateViridis(i / n))
                    .attr('stroke', '#2980b9')
                    .attr('stroke-width', 1)
                    .attr('opacity', 0)
                    .transition()
                    .duration(300)
                    .attr('opacity', 0.5);
                
                sum += area;
                sumDisplay.text(`Sum ≈ ${sum.toFixed(4)}`);
                
                // 更新进度条
                progressBar.transition()
                    .duration(300)
                    .attr('width', (i + 1) / n * innerWidth);
                
                // 显示当前矩形的贡献
                const contribution = g.append('text')
                    .attr('x', xScale(x + width/2))
                    .attr('y', yScale(height/2))
                    .attr('text-anchor', 'middle')
                    .style('font-size', '14px')
                    .style('fill', '#2c3e50')
                    .style('font-weight', 'bold')
                    .text(`+${area.toFixed(3)}`);
                
                contribution.transition()
                    .duration(300)
                    .attr('y', yScale(height/2) - 20)
                    .transition()
                    .delay(1000)
                    .duration(300)
                    .style('opacity', 0);
                
            }, i * 500 / globalAnimationSpeed);
        }
    }

    // 第8页：定义可视化
    function visualizeDefinition() {
        const container = d3.select('#vis-definition');
        container.selectAll('*').remove();
        
        const div = container.append('div')
            .style('width', '100%')
            .style('height', '100%')
            .style('display', 'flex')
            .style('flex-direction', 'column')
            .style('justify-content', 'center')
            .style('align-items', 'center')
            .style('background', 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)')
            .style('color', '#ffffff')
            .style('padding', '40px');
        
        // 积分符号动画
        const svg = div.append('svg')
            .attr('width', 400)
            .attr('height', 250);
        
        // 创建积分符号路径
        const integralPath = "M100,50 Q80,100 100,150 Q120,200 100,250";
        
        const integral = svg.append('path')
            .attr('d', integralPath)
            .attr('stroke', '#ffd700')
            .attr('stroke-width', 8)
            .attr('fill', 'none')
            .attr('stroke-linecap', 'round');
        
        // 动画效果
        const totalLength = integral.node().getTotalLength();
        integral
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0)
            .on('end', function repeat() {
                integral.transition()
                    .duration(1000)
                    .attr('stroke', '#ffffff')
                    .transition()
                    .duration(1000)
                    .attr('stroke', '#ffd700')
                    .on('end', repeat);
            });
        
        // 添加Σ符号
        const sigma = svg.append('text')
            .attr('x', 250)
            .attr('y', 150)
            .style('font-size', '100px')
            .style('fill', '#ffd700')
            .style('opacity', 0)
            .text('Σ');
        
        // Σ符号动画
        sigma.transition()
            .delay(1000)
            .duration(1000)
            .style('opacity', 1)
            .attr('transform', 'translate(0, -10)')
            .transition()
            .duration(1000)
            .attr('transform', 'translate(0, 0)');
        
        // 文字说明
        const textDiv = div.append('div')
            .style('text-align', 'center')
            .style('margin-top', '30px');
        
        textDiv.append('h3')
            .text('定积分 = 无限求和的极限')
            .style('font-size', '28px')
            .style('margin-bottom', '20px')
            .style('text-shadow', '2px 2px 4px rgba(15, 23, 42, 0.2)');
        
        const explanations = [
            { text: '∫ 是拉长的 S (Sum)', delay: 500 },
            { text: 'dx 是无限小的增量', delay: 1000 },
            { text: '把无限多个无限小相加', delay: 1500 }
        ];
        
        explanations.forEach(exp => {
            textDiv.append('p')
                .text(exp.text)
                .style('font-size', '20px')
                .style('margin-bottom', '10px')
                .style('opacity', 0)
                .transition()
                .delay(exp.delay)
                .duration(500)
                .style('opacity', 1);
        });
    }

    // 第9页：几何意义可视化
    function visualizeGeometricMeaning() {
        const container = d3.select('#vis-geometric-meaning');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 坐标轴
        const xScale = d3.scaleLinear()
            .domain([-1, 2])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([-2, 2])
            .range([innerHeight, 0]);
        
        // X轴
        g.append('g')
            .attr('transform', `translate(0,${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .append('text')
            .attr('x', innerWidth)
            .attr('y', -5)
            .attr('text-anchor', 'end')
            .style('fill', 'black')
            .text('x');
        
        // Y轴
        g.append('g')
            .attr('transform', `translate(${xScale(0)},0)`)
            .call(d3.axisLeft(yScale))
            .append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', 15)
            .attr('text-anchor', 'end')
            .style('fill', 'black')
            .text('y');
        
        // 正面积区域
        const posData = d3.range(0, 1.01, 0.01).map(x => ({
            x: x,
            y: Math.sin(x * Math.PI)
        }));
        
        const posArea = d3.area()
            .x(d => xScale(d.x))
            .y0(yScale(0))
            .y1(d => yScale(d.y));
        
        const posPath = g.append('path')
            .datum(posData)
            .attr('d', posArea)
            .attr('fill', '#2ecc71')
            .attr('opacity', 0);
        
        posPath.transition()
            .delay(500)
            .duration(1000)
            .attr('opacity', 0.5);
        
        // 负面积区域
        const negData = d3.range(1, 2.01, 0.01).map(x => ({
            x: x,
            y: Math.sin(x * Math.PI)
        }));
        
        const negArea = d3.area()
            .x(d => xScale(d.x))
            .y0(yScale(0))
            .y1(d => yScale(d.y));
        
        const negPath = g.append('path')
            .datum(negData)
            .attr('d', negArea)
            .attr('fill', '#e74c3c')
            .attr('opacity', 0);
        
        negPath.transition()
            .delay(1500)
            .duration(1000)
            .attr('opacity', 0.5);
        
        // 曲线
        const allData = d3.range(0, 2.01, 0.01).map(x => ({
            x: x,
            y: Math.sin(x * Math.PI)
        }));
        
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        const path = g.append('path')
            .datum(allData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#34495e')
            .attr('stroke-width', 3);
        
        // 曲线绘制动画
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);
        
        // 标注
        const posLabel = g.append('text')
            .attr('x', xScale(0.5))
            .attr('y', yScale(0.8))
            .attr('text-anchor', 'middle')
            .text('正面积 (+)')
            .style('font-size', '16px')
            .style('fill', '#2ecc71')
            .style('font-weight', 'bold')
            .style('opacity', 0);
        
        posLabel.transition()
            .delay(1000)
            .duration(500)
            .style('opacity', 1);
        
        const negLabel = g.append('text')
            .attr('x', xScale(1.5))
            .attr('y', yScale(-0.8))
            .attr('text-anchor', 'middle')
            .text('负面积 (-)')
            .style('font-size', '16px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold')
            .style('opacity', 0);
        
        negLabel.transition()
            .delay(2000)
            .duration(500)
            .style('opacity', 1);
        
        // 添加动态效果
        const plusSign = g.append('text')
            .attr('x', xScale(0.5))
            .attr('y', yScale(0.4))
            .attr('text-anchor', 'middle')
            .text('+')
            .style('font-size', '36px')
            .style('fill', '#2ecc71')
            .style('font-weight', 'bold')
            .style('opacity', 0);
        
        const minusSign = g.append('text')
            .attr('x', xScale(1.5))
            .attr('y', yScale(-0.4))
            .attr('text-anchor', 'middle')
            .text('-')
            .style('font-size', '36px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold')
            .style('opacity', 0);
        
        // 符号动画
        plusSign.transition()
            .delay(1500)
            .duration(500)
            .style('opacity', 1)
            .transition()
            .duration(1000)
            .attr('transform', `translate(0, -10)`)
            .transition()
            .duration(1000)
            .attr('transform', `translate(0, 0)`);
        
        minusSign.transition()
            .delay(2500)
            .duration(500)
            .style('opacity', 1)
            .transition()
            .duration(1000)
            .attr('transform', `translate(0, 10)`)
            .transition()
            .duration(1000)
            .attr('transform', `translate(0, 0)`);
    }

    // 第10页：性质可视化
    function visualizeProperties() {
        const container = d3.select('#vis-properties');
        container.selectAll('*').remove();
        
        const div = container.append('div')
            .style('width', '100%')
            .style('height', '100%')
            .style('display', 'flex')
            .style('flex-direction', 'column')
            .style('justify-content', 'center')
            .style('padding', '20px');
        
        // 创建三个小图展示不同性质
        const row = div.append('div')
            .style('display', 'flex')
            .style('justify-content', 'space-around')
            .style('margin-bottom', '20px');
        
        // 线性性质
        const linear = row.append('div')
            .style('text-align', 'center')
            .style('flex', '1')
            .style('margin', '0 10px');
        
        linear.append('h4')
            .text('线性性质')
            .style('margin-bottom', '10px')
            .style('color', '#3498db');
        
        const svg1 = linear.append('svg')
            .attr('width', '100%')
            .attr('height', 150);
        
        // 创建动画展示 f + g
        const g1 = svg1.append('g')
            .attr('transform', 'translate(50, 75)');
        
        // f函数
        const fRect = g1.append('rect')
            .attr('x', 0)
            .attr('y', -30)
            .attr('width', 60)
            .attr('height', 60)
            .attr('fill', '#3498db')
            .attr('opacity', 0.5);
        
        g1.append('text')
            .attr('x', 30)
            .attr('y', 5)
            .attr('text-anchor', 'middle')
            .text('f')
            .style('fill', '#2c3e50')
            .style('font-weight', 'bold');
        
        // 加号
        g1.append('text')
            .attr('x', 90)
            .attr('y', 5)
            .attr('text-anchor', 'middle')
            .text('+')
            .style('font-size', '24px');
        
        // g函数
        const gRect = g1.append('rect')
            .attr('x', 120)
            .attr('y', -30)
            .attr('width', 60)
            .attr('height', 60)
            .attr('fill', '#e74c3c')
            .attr('opacity', 0.5);
        
        g1.append('text')
            .attr('x', 150)
            .attr('y', 5)
            .attr('text-anchor', 'middle')
            .text('g')
            .style('fill', '#2c3e50')
            .style('font-weight', 'bold');
        
        // 动画
        fRect.transition()
            .duration(1000)
            .attr('transform', 'scale(1.1)')
            .transition()
            .duration(1000)
            .attr('transform', 'scale(1)');
        
        gRect.transition()
            .delay(500)
            .duration(1000)
            .attr('transform', 'scale(1.1)')
            .transition()
            .duration(1000)
            .attr('transform', 'scale(1)');
        
        // 区间可加性
        const additive = row.append('div')
            .style('text-align', 'center')
            .style('flex', '1')
            .style('margin', '0 10px');
        
        additive.append('h4')
            .text('区间可加性')
            .style('margin-bottom', '10px')
            .style('color', '#2ecc71');
        
        const svg2 = additive.append('svg')
            .attr('width', '100%')
            .attr('height', 150);
        
        const g2 = svg2.append('g')
            .attr('transform', 'translate(30, 75)');
        
        // 画一条线段
        const lineLength = 200;
        g2.append('line')
            .attr('x1', 0)
            .attr('x2', lineLength)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke', 'black')
            .attr('stroke-width', 3);
        
        // 三个点
        const points = [0, lineLength * 0.4, lineLength];
        const labels = ['a', 'b', 'c'];
        
        points.forEach((x, i) => {
            const circle = g2.append('circle')
                .attr('cx', x)
                .attr('cy', 0)
                .attr('r', 0)
                .attr('fill', i === 1 ? '#e74c3c' : 'black');
            
            circle.transition()
                .delay(i * 300)
                .duration(500)
                .attr('r', 5);
            
            g2.append('text')
                .attr('x', x)
                .attr('y', 25)
                .attr('text-anchor', 'middle')
                .text(labels[i])
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .transition()
                .delay(i * 300 + 200)
                .duration(500)
                .style('opacity', 1);
        });
        
        // 反向积分
        const reverse = row.append('div')
            .style('text-align', 'center')
            .style('flex', '1')
            .style('margin', '0 10px');
        
        reverse.append('h4')
            .text('反向积分')
            .style('margin-bottom', '10px')
            .style('color', '#9b59b6');
        
        const svg3 = reverse.append('svg')
            .attr('width', '100%')
            .attr('height', 150);
        
        const g3 = svg3.append('g')
            .attr('transform', 'translate(50, 75)');
        
        // 创建箭头
        svg3.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('markerWidth', 10)
            .attr('markerHeight', 7)
            .attr('refX', 9)
            .attr('refY', 3.5)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 10 3.5, 0 7')
            .attr('fill', '#3498db');
        
        svg3.append('defs').append('marker')
            .attr('id', 'arrowhead2')
            .attr('markerWidth', 10)
            .attr('markerHeight', 7)
            .attr('refX', 9)
            .attr('refY', 3.5)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 10 3.5, 0 7')
            .attr('fill', '#e74c3c');
        
        // 正向箭头
        const arrow1 = g3.append('path')
            .attr('d', 'M0,0 L150,0')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .attr('marker-end', 'url(#arrowhead)')
            .attr('stroke-dasharray', '150')
            .attr('stroke-dashoffset', '150');
        
        arrow1.transition()
            .duration(1000)
            .attr('stroke-dashoffset', '0');
        
        // 反向箭头
        const arrow2 = g3.append('path')
            .attr('d', 'M150,30 L0,30')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('marker-end', 'url(#arrowhead2)')
            .attr('stroke-dasharray', '150')
            .attr('stroke-dashoffset', '150');
        
        arrow2.transition()
            .delay(1000)
            .duration(1000)
            .attr('stroke-dashoffset', '0');
        
        // 负号
        g3.append('text')
            .attr('x', 180)
            .attr('y', 20)
            .text('= -')
            .style('font-size', '24px')
            .style('opacity', 0)
            .transition()
            .delay(2000)
            .duration(500)
            .style('opacity', 1);
    }

    // 其他可视化函数继续优化...
    // 第11页等其他页面保持类似的优化模式

    // 第11页：牛顿-莱布尼茨公式可视化
    function visualizeFundamentalTheorem() {
        const container = d3.select('#vis-fundamental-theorem');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 60, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 标题
        g.append('text')
            .attr('x', innerWidth / 2)
            .attr('y', -30)
            .attr('text-anchor', 'middle')
            .style('font-size', '22px')
            .style('font-weight', 'bold')
            .text('微积分基本定理演示');
        
        // 坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 2])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 5])
            .range([innerHeight, 0]);
        
        // X轴
        g.append('g')
            .attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        // Y轴
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 原函数 F(x) = x³/3
        const FData = d3.range(0, 2.01, 0.01).map(x => ({
            x: x,
            y: Math.pow(x, 3) / 3
        }));
        
        const FLine = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));
        
        const FPath = g.append('path')
            .datum(FData)
            .attr('d', FLine)
            .attr('fill', 'none')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3)
            .attr('opacity', 0);
        
        FPath.transition()
            .delay(500)
            .duration(1000)
            .attr('opacity', 1);
        
        g.append('text')
            .attr('x', xScale(1.5))
            .attr('y', yScale(4))
            .text('F(x) = x³/3')
            .style('fill', '#2ecc71')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .transition()
            .delay(1000)
            .duration(500)
            .style('opacity', 1);
        
        // 导函数 f(x) = x²
        const fData = d3.range(0, 2.01, 0.01).map(x => ({
            x: x,
            y: x * x
        }));
        
        const fLine = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y) * 0.8 + innerHeight * 0.2);
        
        const fPath = g.append('path')
            .datum(fData)
            .attr('d', fLine)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5')
            .attr('opacity', 0);
        
        fPath.transition()
            .delay(1500)
            .duration(1000)
            .attr('opacity', 1);
        
        g.append('text')
            .attr('x', xScale(1.8))
            .attr('y', yScale(1))
            .text("f(x) = x²")
            .style('fill', '#e74c3c')
            .style('font-size', '14px')
            .style('opacity', 0)
            .transition()
            .delay(2000)
            .duration(500)
            .style('opacity', 1);
        
        // 标记点动画
        const a = 0.5, b = 1.5;
        
        // F(a)
        const Fa = g.append('circle')
            .attr('cx', xScale(a))
            .attr('cy', yScale(Math.pow(a, 3) / 3))
            .attr('r', 0)
            .attr('fill', '#f39c12');
        
        Fa.transition()
            .delay(2500)
            .duration(500)
            .attr('r', 6);
        
        g.append('text')
            .attr('x', xScale(a) - 20)
            .attr('y', yScale(Math.pow(a, 3) / 3) - 10)
            .text('F(a)')
            .style('fill', '#f39c12')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .transition()
            .delay(3000)
            .duration(500)
            .style('opacity', 1);
        
        // F(b)
        const Fb = g.append('circle')
            .attr('cx', xScale(b))
            .attr('cy', yScale(Math.pow(b, 3) / 3))
            .attr('r', 0)
            .attr('fill', '#f39c12');
        
        Fb.transition()
            .delay(3000)
            .duration(500)
            .attr('r', 6);
        
        g.append('text')
            .attr('x', xScale(b) + 10)
            .attr('y', yScale(Math.pow(b, 3) / 3) - 10)
            .text('F(b)')
            .style('fill', '#f39c12')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .transition()
            .delay(3500)
            .duration(500)
            .style('opacity', 1);
        
        // 连接线
        const connectionLine = g.append('line')
            .attr('x1', xScale(a))
            .attr('y1', yScale(Math.pow(a, 3) / 3))
            .attr('x2', xScale(a))
            .attr('y2', yScale(Math.pow(a, 3) / 3))
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '3,3');
        
        connectionLine.transition()
            .delay(4000)
            .duration(1000)
            .attr('x2', xScale(b))
            .attr('y2', yScale(Math.pow(b, 3) / 3));
        
        // 结果显示
        const result = Math.pow(b, 3) / 3 - Math.pow(a, 3) / 3;
        const resultText = g.append('text')
            .attr('x', innerWidth / 2)
            .attr('y', innerHeight / 2)
            .attr('text-anchor', 'middle')
            .style('font-size', '20px')
            .style('font-weight', 'bold')
            .style('fill', '#9b59b6')
            .text(`F(b) - F(a) = ${result.toFixed(3)}`)
            .style('opacity', 0);
        
        resultText.transition()
            .delay(5000)
            .duration(1000)
            .style('opacity', 1)
            .attr('transform', 'scale(1.2)')
            .transition()
            .duration(500)
            .attr('transform', 'scale(1)');
    }

    // 第12页：计算实例可视化
    function visualizeExample1() {
        const containerId = 'vis-example1';
        
        // 使用步骤化可视化展示计算过程
        const steps = [
            {
                title: '题目',
                formula: '\\int_0^1 x^2 dx',
                color: '#3498db'
            },
            {
                title: '找原函数 F(x)',
                formula: 'F(x) = \\frac{x^3}{3}',
                color: '#2ecc71'
            },
            {
                title: '应用牛顿-莱布尼茨公式',
                formula: '\\int_0^1 x^2 dx = \\left[\\frac{x^3}{3}\\right]_0^1',
                color: '#f39c12'
            },
            {
                title: '代入上下限',
                formula: '= \\frac{1^3}{3} - \\frac{0^3}{3}',
                color: '#9b59b6'
            },
            {
                title: '计算结果',
                formula: '= \\frac{1}{3}',
                color: '#e74c3c'
            }
        ];
        
        visualizeStepByStep(containerId, steps);
    }


    function visualizeAreaBetween() {
        const container = d3.select('#vis-area-between');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 坐标轴
        const xScale = d3.scaleLinear()
            .domain([0, 1.2])
            .range([0, innerWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([0, 1.2])
            .range([innerHeight, 0]);
        
        // X轴
        g.append('g')
            .attr('transform', `translate(0,${innerHeight})`)
            .call(d3.axisBottom(xScale));
        
        // Y轴
        g.append('g')
            .call(d3.axisLeft(yScale));
        
        // 数据
        const data = d3.range(0, 1.01, 0.01).map(x => ({
            x: x,
            y1: x,
            y2: x * x
        }));
        
        // 填充区域 - 渐变效果
        const areaGradient = svg.append('defs')
            .append('linearGradient')
            .attr('id', 'between-gradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '100%');
        
        areaGradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#9b59b6')
            .style('stop-opacity', 0.6);
        
        areaGradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#f39c12')
            .style('stop-opacity', 0.4);
        
        const area = d3.area()
            .x(d => xScale(d.x))
            .y0(d => yScale(d.y2))
            .y1(d => yScale(d.y1));
        
        const areaPath = g.append('path')
            .datum(data)
            .attr('d', area)
            .attr('fill', 'url(#between-gradient)')
            .attr('opacity', 0);
        
        // 动画填充
        areaPath.transition()
            .delay(1000)
            .duration(1500)
            .attr('opacity', 1);
        
        // 曲线1: y = x
        const line1 = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y1));
        
        const path1 = g.append('path')
            .datum(data)
            .attr('d', line1)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        // 曲线2: y = x²
        const line2 = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y2));
        
        const path2 = g.append('path')
            .datum(data)
            .attr('d', line2)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        // 曲线绘制动画
        [path1, path2].forEach((path, i) => {
            const totalLength = path.node().getTotalLength();
            path.attr('stroke-dasharray', totalLength + ' ' + totalLength)
                .attr('stroke-dashoffset', totalLength)
                .transition()
                .delay(i * 300)
                .duration(1500)
                .attr('stroke-dashoffset', 0);
        });
        
        // 标注
        g.append('text')
            .attr('x', xScale(0.2))
            .attr('y', yScale(0.2))
            .text('y = x')
            .style('font-size', '15px')
            .style('fill', '#3498db')
            .style('font-weight', '600')
            .style('opacity', 0)
            .transition()
            .delay(500)
            .duration(500)
            .style('opacity', 1);
        
        g.append('text')
            .attr('x', xScale(0.8))
            .attr('y', yScale(0.8 * 0.8))
            .text('y = x²')
            .style('font-size', '15px')
            .style('fill', '#e74c3c')
            .style('font-weight', '600')
            .style('opacity', 0)
            .transition()
            .delay(800)
            .duration(500)
            .style('opacity', 1);
        
        // 交点标记
        const intersections = [
            {x: 0, y: 0},
            {x: 1, y: 1}
        ];
        
        intersections.forEach((point, i) => {
            const circle = g.append('circle')
                .attr('cx', xScale(point.x))
                .attr('cy', yScale(point.y))
                .attr('r', 0)
                .attr('fill', '#f39c12')
                .attr('stroke', '#2c3e50')
                .attr('stroke-width', 2);
            
            circle.transition()
                .delay(2000 + i * 300)
                .duration(500)
                .attr('r', 6);
            
            g.append('text')
                .attr('x', xScale(point.x) + (i === 0 ? -20 : 20))
                .attr('y', yScale(point.y) + (i === 0 ? 20 : -10))
                .text(`(${point.x}, ${point.y})`)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('opacity', 0)
                .transition()
                .delay(2500 + i * 300)
                .duration(500)
                .style('opacity', 1);
        });
        
        // 面积值显示
        const areaValue = g.append('text')
            .attr('x', xScale(0.5))
            .attr('y', yScale(0.3))
            .attr('text-anchor', 'middle')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .style('fill', '#9b59b6')
            .text('Area = 1/6')
            .style('opacity', 0);
        
        areaValue.transition()
            .delay(3000)
            .duration(1000)
            .style('opacity', 1)
            .attr('transform', 'scale(1.1)')
            .transition()
            .duration(500)
            .attr('transform', 'scale(1)');
    }

    // 第14页：旋转体体积可视化
    function visualizeVolume() {
        const container = d3.select('#vis-volume');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        const g = svg.append('g')
            .attr('transform', `translate(${centerX},${centerY})`);
        
        // 创建3D效果的旋转体
        const n = 50; // 圆盘数量
        const maxRadius = 100;
        const length = 300;
        
        // 绘制坐标轴
        g.append('line')
            .attr('x1', -length/2 - 50)
            .attr('x2', length/2 + 50)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke', '#2c3e50')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');
        
        // 绘制曲线 y = x²
        const curveData = d3.range(-1, 1.01, 0.05).map(x => ({
            x: x * length/2,
            y: -Math.pow(x, 2) * maxRadius
        }));
        
        const line = d3.line()
            .x(d => d.x)
            .y(d => d.y)
            .curve(d3.curveNatural);
        
        g.append('path')
            .datum(curveData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        // 创建圆盘组
        const diskGroup = g.append('g');
        
        // 绘制圆盘
        for (let i = 0; i < n; i++) {
            const x = -1 + 2 * i / (n - 1);
            const xPos = x * length/2;
            const radius = Math.pow(x, 2) * maxRadius;
            
            // 椭圆（模拟3D圆盘）
            const ellipse = diskGroup.append('ellipse')
                .attr('cx', xPos)
                .attr('cy', 0)
                .attr('rx', 0)
                .attr('ry', 0)
                .attr('fill', d3.interpolatePlasma(0.3 + 0.4 * (i / n)))
                .attr('stroke', '#2980b9')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0.4);
            
            // 动画
            ellipse.transition()
                .delay(i * 30)
                .duration(500)
                .attr('rx', 5)
                .attr('ry', radius);
        }
        
        // 旋转动画
        let angle = 0;
        function rotate() {
            if (!globalAnimationPlaying) {
                setTimeout(rotate, 100);
                return;
            }
            
            angle += 1 * globalAnimationSpeed;
            diskGroup.attr('transform', `rotate(${angle} 0 0)`);
            requestAnimationFrame(rotate);
        }
        rotate();
        
        // 标注
        g.append('text')
            .attr('x', 0)
            .attr('y', -maxRadius - 50)
            .attr('text-anchor', 'middle')
            .text('旋转体：y = x² 绕 x 轴旋转')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .style('fill', '#2c3e50');
        
        // 公式显示
        const formula = g.append('g')
            .attr('transform', `translate(0, ${maxRadius + 80})`);
        
        formula.append('rect')
            .attr('x', -150)
            .attr('y', -25)
            .attr('width', 300)
            .attr('height', 50)
            .attr('fill', 'rgba(255, 255, 255, 0.9)')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2)
            .attr('rx', 5);
        
        formula.append('text')
            .attr('text-anchor', 'middle')
            .text('V = π∫[f(x)]² dx')
            .style('font-size', '20px')
            .style('font-weight', 'bold')
            .style('fill', '#3498db');
        
        // 添加控制按钮
        const controlGroup = svg.append('g')
            .attr('transform', `translate(${width - 150}, ${height - 50})`);
        
        const pauseBtn = controlGroup.append('g')
            .style('cursor', 'pointer');
        
        pauseBtn.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', 100)
            .attr('height', 30)
            .attr('fill', '#3498db')
            .attr('rx', 15);
        
        pauseBtn.append('text')
            .attr('x', 50)
            .attr('y', 20)
            .attr('text-anchor', 'middle')
            .text('暂停旋转')
            .style('fill', '#ffffff')
            .style('font-size', '14px');
        
        let isPaused = false;
        pauseBtn.on('click', function() {
            isPaused = !isPaused;
            globalAnimationPlaying = !isPaused;
            d3.select(this).select('text')
                .text(isPaused ? '继续旋转' : '暂停旋转');
        });
    }

    // 第14-1页：面积应用例题1可视化（抛物线与直线）
    function visualizeAreaExample1() {
        const container = d3.select('#vis-area-example1');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const plotWidth = width - margin.left - margin.right;
        const plotHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 创建比例尺
        const xScale = d3.scaleLinear()
            .domain([-0.5, 2.5])
            .range([0, plotWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([-0.5, 4.5])
            .range([plotHeight, 0]);
        
        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0,${plotHeight})`)
            .call(d3.axisBottom(xScale).ticks(6))
            .style('font-size', '12px');
        
        g.append('g')
            .call(d3.axisLeft(yScale).ticks(6))
            .style('font-size', '12px');
        
        // 坐标轴标签
        g.append('text')
            .attr('x', plotWidth)
            .attr('y', plotHeight - 10)
            .text('x')
            .style('font-size', '16px')
            .style('font-weight', 'bold');
        
        g.append('text')
            .attr('x', 10)
            .attr('y', -10)
            .text('y')
            .style('font-size', '16px')
            .style('font-weight', 'bold');
        
        // 绘制抛物线 y = x²
        const parabolaData = d3.range(0, 2.1, 0.05).map(x => ({
            x: x,
            y: x * x
        }));
        
        const lineGenerator = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveNatural);
        
        g.append('path')
            .datum(parabolaData)
            .attr('d', lineGenerator)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .style('opacity', 0)
            .transition()
            .duration(1000)
            .style('opacity', 1);
        
        // 绘制直线 y = 2x
        const lineData = [{x: 0, y: 0}, {x: 2, y: 4}];
        
        g.append('path')
            .datum(lineData)
            .attr('d', lineGenerator)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .style('opacity', 0)
            .transition()
            .delay(500)
            .duration(1000)
            .style('opacity', 1);
        
        // 填充区域
        const areaData = d3.range(0, 2.01, 0.05).map(x => ({
            x: x,
            y1: x * x,
            y2: 2 * x
        }));
        
        const areaGenerator = d3.area()
            .x(d => xScale(d.x))
            .y0(d => yScale(d.y1))
            .y1(d => yScale(d.y2))
            .curve(d3.curveNatural);
        
        g.append('path')
            .datum(areaData)
            .attr('d', areaGenerator)
            .attr('fill', '#2ecc71')
            .attr('opacity', 0)
            .transition()
            .delay(1500)
            .duration(1000)
            .attr('opacity', 0.3);
        
        // 标注交点
        const points = [{x: 0, y: 0, label: '(0,0)'}, {x: 2, y: 4, label: '(2,4)'}];
        
        points.forEach((point, i) => {
            const pointGroup = g.append('g')
                .style('opacity', 0);
            
            pointGroup.append('circle')
                .attr('cx', xScale(point.x))
                .attr('cy', yScale(point.y))
                .attr('r', 5)
                .attr('fill', '#9b59b6');
            
            pointGroup.append('text')
                .attr('x', xScale(point.x) + (i === 0 ? -30 : 30))
                .attr('y', yScale(point.y) + (i === 0 ? 20 : -10))
                .text(point.label)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#9b59b6')
                .attr('text-anchor', i === 0 ? 'end' : 'start');
            
            pointGroup.transition()
                .delay(2000 + i * 300)
                .duration(500)
                .style('opacity', 1);
        });
        
        // 添加曲线标签
        g.append('text')
            .attr('x', xScale(1.8))
            .attr('y', yScale(1.8 * 1.8) - 10)
            .text('y = x²')
            .style('font-size', '14px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .transition()
            .delay(2500)
            .duration(500)
            .style('opacity', 1);
        
        g.append('text')
            .attr('x', xScale(1.5))
            .attr('y', yScale(1.5 * 2) + 20)
            .text('y = 2x')
            .style('font-size', '14px')
            .style('fill', '#3498db')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .transition()
            .delay(2700)
            .duration(500)
            .style('opacity', 1);
        
        // 面积标注
        g.append('text')
            .attr('x', xScale(1))
            .attr('y', yScale(1.5))
            .text('S = 4/3')
            .style('font-size', '18px')
            .style('fill', '#2ecc71')
            .style('font-weight', 'bold')
            .attr('text-anchor', 'middle')
            .style('opacity', 0)
            .transition()
            .delay(3000)
            .duration(800)
            .style('opacity', 1);
    }

    // 第14-2页：面积应用例题2可视化（两条抛物线）
    function visualizeAreaExample2() {
        const container = d3.select('#vis-area-example2');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const margin = {top: 40, right: 40, bottom: 60, left: 60};
        const plotWidth = width - margin.left - margin.right;
        const plotHeight = height - margin.top - margin.bottom;
        
        const g = svg.append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);
        
        // 创建比例尺
        const xScale = d3.scaleLinear()
            .domain([-0.2, 1.2])
            .range([0, plotWidth]);
        
        const yScale = d3.scaleLinear()
            .domain([-0.2, 1.2])
            .range([plotHeight, 0]);
        
        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0,${plotHeight})`)
            .call(d3.axisBottom(xScale).ticks(6))
            .style('font-size', '12px');
        
        g.append('g')
            .call(d3.axisLeft(yScale).ticks(6))
            .style('font-size', '12px');
        
        // 绘制 y = x²
        const parabolaData = d3.range(0, 1.01, 0.02).map(x => ({
            x: x,
            y: x * x
        }));
        
        const lineGenerator = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveNatural);
        
        g.append('path')
            .datum(parabolaData)
            .attr('d', lineGenerator)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .style('opacity', 0)
            .transition()
            .duration(1000)
            .style('opacity', 1);
        
        // 绘制 y = √x
        const sqrtData = d3.range(0, 1.01, 0.02).map(x => ({
            x: x,
            y: Math.sqrt(x)
        }));
        
        g.append('path')
            .datum(sqrtData)
            .attr('d', lineGenerator)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3)
            .style('opacity', 0)
            .transition()
            .delay(500)
            .duration(1000)
            .style('opacity', 1);
        
        // 填充区域
        const areaData = d3.range(0, 1.01, 0.02).map(x => ({
            x: x,
            y1: x * x,
            y2: Math.sqrt(x)
        }));
        
        const areaGenerator = d3.area()
            .x(d => xScale(d.x))
            .y0(d => yScale(d.y1))
            .y1(d => yScale(d.y2))
            .curve(d3.curveNatural);
        
        g.append('path')
            .datum(areaData)
            .attr('d', areaGenerator)
            .attr('fill', '#2ecc71')
            .attr('opacity', 0)
            .transition()
            .delay(1500)
            .duration(1000)
            .attr('opacity', 0.3);
        
        // 标注交点
        const points = [{x: 0, y: 0, label: '(0,0)'}, {x: 1, y: 1, label: '(1,1)'}];
        
        points.forEach((point, i) => {
            const pointGroup = g.append('g')
                .style('opacity', 0);
            
            pointGroup.append('circle')
                .attr('cx', xScale(point.x))
                .attr('cy', yScale(point.y))
                .attr('r', 5)
                .attr('fill', '#9b59b6');
            
            pointGroup.append('text')
                .attr('x', xScale(point.x) + (i === 0 ? -30 : 30))
                .attr('y', yScale(point.y) + (i === 0 ? 20 : -10))
                .text(point.label)
                .style('font-size', '14px')
                .style('font-weight', 'bold')
                .style('fill', '#9b59b6')
                .attr('text-anchor', i === 0 ? 'end' : 'start');
            
            pointGroup.transition()
                .delay(2000 + i * 300)
                .duration(500)
                .style('opacity', 1);
        });
        
        // 添加曲线标签
        g.append('text')
            .attr('x', xScale(0.8))
            .attr('y', yScale(0.8 * 0.8) + 20)
            .text('y = x²')
            .style('font-size', '14px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .transition()
            .delay(2500)
            .duration(500)
            .style('opacity', 1);
        
        g.append('text')
            .attr('x', xScale(0.7))
            .attr('y', yScale(Math.sqrt(0.7)) - 10)
            .text('y = √x')
            .style('font-size', '14px')
            .style('fill', '#3498db')
            .style('font-weight', 'bold')
            .style('opacity', 0)
            .transition()
            .delay(2700)
            .duration(500)
            .style('opacity', 1);
        
        // 面积标注
        g.append('text')
            .attr('x', xScale(0.5))
            .attr('y', yScale(0.6))
            .text('S = 1/3')
            .style('font-size', '18px')
            .style('fill', '#2ecc71')
            .style('font-weight', 'bold')
            .attr('text-anchor', 'middle')
            .style('opacity', 0)
            .transition()
            .delay(3000)
            .duration(800)
            .style('opacity', 1);
    }

    // 第14-3页：旋转体体积例题1可视化（圆锥）- 绕x轴旋转
    function visualizeVolumeExample1() {
        const container = d3.select('#vis-volume-example1');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        const g = svg.append('g')
            .attr('transform', `translate(${centerX},${centerY})`);
        
        // 绘制x轴（水平，旋转轴）
        g.append('line')
            .attr('x1', -180)
            .attr('x2', 80)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke', '#2c3e50')
            .attr('stroke-width', 3)
            .attr('marker-end', 'url(#arrowhead)');
        
        // 添加箭头标记
        const defs = svg.append('defs');
        defs.append('marker')
            .attr('id', 'arrowhead')
            .attr('markerWidth', 10)
            .attr('markerHeight', 10)
            .attr('refX', 9)
            .attr('refY', 3)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 10 3, 0 6')
            .attr('fill', '#2c3e50');
        
        // x轴标签
        g.append('text')
            .attr('x', 90)
            .attr('y', 5)
            .text('x轴（旋转轴）')
            .style('font-size', '12px')
            .style('fill', '#2c3e50')
            .style('font-weight', 'bold');
        
        // 绘制原始直线 y = x（在x-y平面上）
        const lineGroup = g.append('g').style('opacity', 0);
        lineGroup.append('line')
            .attr('x1', -150)
            .attr('x2', 0)
            .attr('y1', 0)
            .attr('y2', -150)
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        lineGroup.append('text')
            .attr('x', -100)
            .attr('y', -80)
            .text('y = x')
            .style('font-size', '14px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold');
        
        lineGroup.transition()
            .duration(1000)
            .style('opacity', 1);
        
        // 绘制圆盘（垂直于x轴）
        const diskGroup = g.append('g');
        const numDisks = 15;
        
        for (let i = 0; i < numDisks; i++) {
            const x = -150 + (150 * i / (numDisks - 1));  // x从-150到0
            const radius = Math.abs(x);  // 半径 = |x|（因为y=x）
            
            // 绘制圆盘（椭圆表示垂直于x轴的圆）
            const disk = diskGroup.append('ellipse')
                .attr('cx', x)
                .attr('cy', 0)
                .attr('rx', 8)  // 厚度
                .attr('ry', 0)  // 半径
                .attr('fill', d3.interpolateBlues(0.4 + 0.4 * (i / numDisks)))
                .attr('stroke', '#2980b9')
                .attr('stroke-width', 1)
                .attr('opacity', 0.6);
            
            disk.transition()
                .delay(1200 + i * 40)
                .duration(600)
                .attr('ry', radius);
        }
        
        // 添加旋转箭头提示
        const rotationHint = g.append('g')
            .style('opacity', 0);
        
        // 画圆弧箭头表示旋转
        rotationHint.append('path')
            .attr('d', 'M -80 -80 A 80 80 0 0 1 -80 80')
            .attr('fill', 'none')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#rotation-arrow)');
        
        defs.append('marker')
            .attr('id', 'rotation-arrow')
            .attr('markerWidth', 8)
            .attr('markerHeight', 8)
            .attr('refX', 7)
            .attr('refY', 3)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 8 3, 0 6')
            .attr('fill', '#f39c12');
        
        rotationHint.append('text')
            .attr('x', -130)
            .attr('y', 0)
            .text('绕x轴旋转')
            .style('font-size', '12px')
            .style('fill', '#f39c12')
            .style('font-weight', 'bold');
        
        rotationHint.transition()
            .delay(2000)
            .duration(800)
            .style('opacity', 1);
        
        // 标注
        g.append('text')
            .attr('x', 0)
            .attr('y', -180)
            .attr('text-anchor', 'middle')
            .text('直线 y = x 绕 x 轴旋转形成圆锥')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .style('fill', '#2c3e50')
            .style('opacity', 0)
            .transition()
            .delay(1500)
            .duration(800)
            .style('opacity', 1);
        
        // 体积公式（使用foreignObject以支持MathJax）
        const formulaGroup = g.append('g')
            .attr('transform', 'translate(0, 130)')
            .style('opacity', 0);
        
        formulaGroup.append('rect')
            .attr('x', -140)
            .attr('y', -30)
            .attr('width', 280)
            .attr('height', 60)
            .attr('fill', 'rgba(231, 76, 60, 0.1)')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('rx', 5);
        
        const fo = formulaGroup.append('foreignObject')
            .attr('x', -140)
            .attr('y', -30)
            .attr('width', 280)
            .attr('height', 60);
        
        const formulaDiv = fo.append('xhtml:div')
            .style('display', 'flex')
            .style('align-items', 'center')
            .style('justify-content', 'center')
            .style('height', '100%')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .style('color', '#e74c3c')
            .attr('class', 'tex2jax_process')
            .html('$V = \\pi \\int_0^1 x^2 dx = \\frac{\\pi}{3}$');
        
        formulaGroup.transition()
            .delay(2800)
            .duration(800)
            .style('opacity', 1)
            .on('end', () => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise([formulaDiv.node()]).catch((err) => console.log(err));
                }
            });
    }

    // 第14-4页：旋转体体积例题2可视化（抛物线旋转体）- 绕x轴旋转
    function visualizeVolumeExample2() {
        const container = d3.select('#vis-volume-example2');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        const g = svg.append('g')
            .attr('transform', `translate(${centerX},${centerY})`);
        
        // 绘制x轴（水平，旋转轴）
        g.append('line')
            .attr('x1', -200)
            .attr('x2', 80)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke', '#2c3e50')
            .attr('stroke-width', 3)
            .attr('marker-end', 'url(#arrowhead2)');
        
        // 添加箭头标记
        const defs = svg.append('defs');
        defs.append('marker')
            .attr('id', 'arrowhead2')
            .attr('markerWidth', 10)
            .attr('markerHeight', 10)
            .attr('refX', 9)
            .attr('refY', 3)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 10 3, 0 6')
            .attr('fill', '#2c3e50');
        
        // x轴标签
        g.append('text')
            .attr('x', 90)
            .attr('y', 5)
            .text('x')
            .style('font-size', '14px')
            .style('fill', '#2c3e50')
            .style('font-weight', 'bold');
        
        // 绘制曲线 y = √x
        const curveGroup = g.append('g').style('opacity', 0);
        const curveData = d3.range(0, 4.1, 0.1).map(x => ({
            x: -180 + (x / 4) * 180,  // x从-180到0
            y: -Math.sqrt(x) * 30
        }));
        
        const line = d3.line()
            .x(d => d.x)
            .y(d => d.y)
            .curve(d3.curveNatural);
        
        curveGroup.append('path')
            .datum(curveData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        curveGroup.append('text')
            .attr('x', -120)
            .attr('y', -70)
            .text('y = √x')
            .style('font-size', '14px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold');
        
        curveGroup.transition()
            .duration(1000)
            .style('opacity', 1);
        
        // 绘制圆盘（垂直于x轴）
        const diskGroup = g.append('g');
        const numDisks = 20;
        
        for (let i = 0; i < numDisks; i++) {
            const x = i / (numDisks - 1) * 4;  // 0到4
            const xPos = -180 + (x / 4) * 180;
            const radius = Math.sqrt(x) * 30;
            
            // 绘制圆盘
            const disk = diskGroup.append('ellipse')
                .attr('cx', xPos)
                .attr('cy', 0)
                .attr('rx', 6)  // 厚度
                .attr('ry', 0)  // 半径
                .attr('fill', d3.interpolateViridis(i / numDisks))
                .attr('stroke', '#2980b9')
                .attr('stroke-width', 0.8)
                .attr('opacity', 0.5);
            
            disk.transition()
                .delay(1200 + i * 30)
                .duration(500)
                .attr('ry', radius);
        }
        
        // 添加旋转提示
        const rotationHint = g.append('g')
            .style('opacity', 0);
        
        rotationHint.append('path')
            .attr('d', 'M -100 -60 A 60 60 0 0 1 -100 60')
            .attr('fill', 'none')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#rotation-arrow2)');
        
        defs.append('marker')
            .attr('id', 'rotation-arrow2')
            .attr('markerWidth', 8)
            .attr('markerHeight', 8)
            .attr('refX', 7)
            .attr('refY', 3)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 8 3, 0 6')
            .attr('fill', '#f39c12');
        
        rotationHint.append('text')
            .attr('x', -145)
            .attr('y', 0)
            .text('绕x轴')
            .style('font-size', '11px')
            .style('fill', '#f39c12')
            .style('font-weight', 'bold');
        
        rotationHint.transition()
            .delay(2000)
            .duration(800)
            .style('opacity', 1);
        
        // 标注
        g.append('text')
            .attr('x', 0)
            .attr('y', -140)
            .attr('text-anchor', 'middle')
            .text('y = √x, x ∈ [0,4] 绕 x 轴旋转')
            .style('font-size', '14px')
            .style('font-weight', 'bold')
            .style('fill', '#2c3e50')
            .style('opacity', 0)
            .transition()
            .delay(1500)
            .duration(800)
            .style('opacity', 1);
        
        // 体积公式（使用foreignObject以支持MathJax）
        const formulaGroup = g.append('g')
            .attr('transform', 'translate(0, 110)')
            .style('opacity', 0);
        
        formulaGroup.append('rect')
            .attr('x', -140)
            .attr('y', -30)
            .attr('width', 280)
            .attr('height', 60)
            .attr('fill', 'rgba(231, 76, 60, 0.1)')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('rx', 5);
        
        const fo = formulaGroup.append('foreignObject')
            .attr('x', -140)
            .attr('y', -30)
            .attr('width', 280)
            .attr('height', 60);
        
        const formulaDiv = fo.append('xhtml:div')
            .style('display', 'flex')
            .style('align-items', 'center')
            .style('justify-content', 'center')
            .style('height', '100%')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .style('color', '#e74c3c')
            .attr('class', 'tex2jax_process')
            .html('$V = \\pi \\int_0^4 x \\, dx = 8\\pi$');
        
        formulaGroup.transition()
            .delay(2800)
            .duration(800)
            .style('opacity', 1)
            .on('end', () => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise([formulaDiv.node()]).catch((err) => console.log(err));
                }
            });
    }

    // 第14-5页：旋转体体积例题3可视化（圆环）- 绕x轴旋转
    function visualizeVolumeExample3() {
        const container = d3.select('#vis-volume-example3');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        const g = svg.append('g')
            .attr('transform', `translate(${centerX},${centerY})`);
        
        // 绘制x轴（水平，旋转轴）
        g.append('line')
            .attr('x1', -150)
            .attr('x2', 80)
            .attr('y1', 0)
            .attr('y2', 0)
            .attr('stroke', '#2c3e50')
            .attr('stroke-width', 3)
            .attr('marker-end', 'url(#arrowhead3)');
        
        // 添加箭头标记
        const defs = svg.append('defs');
        defs.append('marker')
            .attr('id', 'arrowhead3')
            .attr('markerWidth', 10)
            .attr('markerHeight', 10)
            .attr('refX', 9)
            .attr('refY', 3)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 10 3, 0 6')
            .attr('fill', '#2c3e50');
        
        // x轴标签
        g.append('text')
            .attr('x', 90)
            .attr('y', 5)
            .text('x')
            .style('font-size', '14px')
            .style('fill', '#2c3e50')
            .style('font-weight', 'bold');
        
        // 绘制两条曲线
        const curvesGroup = g.append('g').style('opacity', 0);
        
        // 直线 y = x
        curvesGroup.append('line')
            .attr('x1', -120)
            .attr('x2', 0)
            .attr('y1', 0)
            .attr('y2', -120)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2.5);
        
        curvesGroup.append('text')
            .attr('x', -80)
            .attr('y', -65)
            .text('y = x')
            .style('font-size', '12px')
            .style('fill', '#3498db')
            .style('font-weight', 'bold');
        
        // 抛物线 y = x²
        const parabolaData = d3.range(0, 1.01, 0.05).map(t => ({
            x: -120 * (1 - t),
            y: -120 * 120 * (1 - t) * (1 - t) / 120
        }));
        
        const line = d3.line()
            .x(d => d.x)
            .y(d => d.y)
            .curve(d3.curveNatural);
        
        curvesGroup.append('path')
            .datum(parabolaData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2.5);
        
        curvesGroup.append('text')
            .attr('x', -80)
            .attr('y', -35)
            .text('y = x²')
            .style('font-size', '12px')
            .style('fill', '#e74c3c')
            .style('font-weight', 'bold');
        
        curvesGroup.transition()
            .duration(1000)
            .style('opacity', 1);
        
        // 绘制圆环（垂直于x轴的圆盘，外圆减内圆）
        const ringGroup = g.append('g');
        const numRings = 16;
        
        for (let i = 0; i < numRings; i++) {
            const t = i / (numRings - 1);  // 0到1
            const xPos = -120 * (1 - t);
            const outerRadius = 120 * (1 - t);  // R(x) = x
            const innerRadius = 120 * (1 - t) * (1 - t);  // r(x) = x²
            
            // 外圆（蓝色）
            const outerCircle = ringGroup.append('ellipse')
                .attr('cx', xPos)
                .attr('cy', 0)
                .attr('rx', 5)
                .attr('ry', 0)
                .attr('fill', 'none')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 1.5)
                .attr('opacity', 0.4);
            
            outerCircle.transition()
                .delay(1200 + i * 40)
                .duration(500)
                .attr('ry', outerRadius);
            
            // 内圆（红色）
            if (innerRadius > 3) {
                const innerCircle = ringGroup.append('ellipse')
                    .attr('cx', xPos)
                    .attr('cy', 0)
                    .attr('rx', 5)
                    .attr('ry', 0)
                    .attr('fill', 'none')
                    .attr('stroke', '#e74c3c')
                    .attr('stroke-width', 1.5)
                    .attr('opacity', 0.4);
                
                innerCircle.transition()
                    .delay(1300 + i * 40)
                    .duration(500)
                    .attr('ry', innerRadius);
            }
            
            // 填充圆环区域
            if (i % 2 === 0 && outerRadius > innerRadius + 3) {
                const avgRadius = (outerRadius + innerRadius) / 2;
                const ring = ringGroup.append('ellipse')
                    .attr('cx', xPos)
                    .attr('cy', 0)
                    .attr('rx', 6)
                    .attr('ry', 0)
                    .attr('fill', d3.interpolateCool(t))
                    .attr('opacity', 0);
                
                ring.transition()
                    .delay(1500 + i * 40)
                    .duration(500)
                    .attr('ry', avgRadius)
                    .attr('opacity', 0.3);
            }
        }
        
        // 添加旋转提示
        const rotationHint = g.append('g')
            .style('opacity', 0);
        
        rotationHint.append('path')
            .attr('d', 'M -60 -70 A 70 70 0 0 1 -60 70')
            .attr('fill', 'none')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#rotation-arrow3)');
        
        defs.append('marker')
            .attr('id', 'rotation-arrow3')
            .attr('markerWidth', 8)
            .attr('markerHeight', 8)
            .attr('refX', 7)
            .attr('refY', 3)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 8 3, 0 6')
            .attr('fill', '#f39c12');
        
        rotationHint.append('text')
            .attr('x', -105)
            .attr('y', 0)
            .text('绕x轴')
            .style('font-size', '11px')
            .style('fill', '#f39c12')
            .style('font-weight', 'bold');
        
        rotationHint.transition()
            .delay(2200)
            .duration(800)
            .style('opacity', 1);
        
        // 标注
        g.append('text')
            .attr('x', 0)
            .attr('y', -150)
            .attr('text-anchor', 'middle')
            .text('圆环：y=x 与 y=x² (x∈[0,1]) 绕 x 轴旋转')
            .style('font-size', '13px')
            .style('font-weight', 'bold')
            .style('fill', '#2c3e50')
            .style('opacity', 0)
            .transition()
            .delay(1500)
            .duration(800)
            .style('opacity', 1);
        
        // 体积公式（使用foreignObject以支持MathJax）
        const formulaGroup = g.append('g')
            .attr('transform', 'translate(0, 125)')
            .style('opacity', 0);
        
        formulaGroup.append('rect')
            .attr('x', -155)
            .attr('y', -35)
            .attr('width', 310)
            .attr('height', 70)
            .attr('fill', 'rgba(231, 76, 60, 0.1)')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('rx', 5);
        
        const fo = formulaGroup.append('foreignObject')
            .attr('x', -155)
            .attr('y', -35)
            .attr('width', 310)
            .attr('height', 70);
        
        const formulaDiv = fo.append('xhtml:div')
            .style('display', 'flex')
            .style('flex-direction', 'column')
            .style('align-items', 'center')
            .style('justify-content', 'center')
            .style('height', '100%')
            .style('font-weight', 'bold')
            .style('color', '#e74c3c')
            .attr('class', 'tex2jax_process')
            .html(`
                <div style="font-size: 16px; margin-bottom: 5px;">
                    $V = \\pi \\int_0^1 (x^2 - x^4) \\, dx$
                </div>
                <div style="font-size: 18px;">
                    $= \\dfrac{2\\pi}{15}$
                </div>
            `);
        
        formulaGroup.transition()
            .delay(3000)
            .duration(800)
            .style('opacity', 1)
            .on('end', () => {
                if (window.MathJax && window.MathJax.typesetPromise) {
                    MathJax.typesetPromise([formulaDiv.node()]).catch((err) => console.log(err));
                }
            });
    }

    // 第15页：物理应用可视化
    function visualizePhysics() {
        const container = d3.select('#vis-physics');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const mainDiv = container.append('div')
            .style('width', '100%')
            .style('height', '100%')
            .style('display', 'flex')
            .style('flex-direction', 'column');
        
        // 上半部分：变力做功
        const workDiv = mainDiv.append('div')
            .style('flex', '1')
            .style('position', 'relative');
        
        const svg1 = workDiv.append('svg')
            .attr('width', '100%')
            .attr('height', '100%');
        
        const g1 = svg1.append('g')
            .attr('transform', 'translate(60, 30)');
        
        const workWidth = width - 120;
        const workHeight = height / 2 - 60;
        
        // 力的图像 F(x) = 2x + 1
        const xScale1 = d3.scaleLinear()
            .domain([0, 5])
            .range([0, workWidth]);
        
        const yScale1 = d3.scaleLinear()
            .domain([0, 12])
            .range([workHeight, 0]);
        
        // 坐标轴
        g1.append('g')
            .attr('transform', `translate(0,${workHeight})`)
            .call(d3.axisBottom(xScale1))
            .append('text')
            .attr('x', workWidth)
            .attr('y', 35)
            .attr('fill', 'black')
            .text('x (m)');
        
        g1.append('g')
            .call(d3.axisLeft(yScale1))
            .append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -35)
            .attr('x', 0)
            .attr('fill', 'black')
            .text('F (N)');
        
        // 力的曲线
        const forceData = d3.range(0, 5.1, 0.1).map(x => ({
            x: x,
            y: 2 * x + 1
        }));
        
        const forceLine = d3.line()
            .x(d => xScale1(d.x))
            .y(d => yScale1(d.y));
        
        // 填充区域（功）
        const workArea = d3.area()
            .x(d => xScale1(d.x))
            .y0(workHeight)
            .y1(d => yScale1(d.y));
        
        const workPath = g1.append('path')
            .datum(forceData.slice(0, 31))  // 从0到3
            .attr('d', workArea)
            .attr('fill', '#3498db')
            .attr('opacity', 0);
        
        workPath.transition()
            .duration(1500)
            .attr('opacity', 0.3);
        
        g1.append('path')
            .datum(forceData)
            .attr('d', forceLine)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3);
        
        // 标注
        g1.append('text')
            .attr('x', xScale1(1.5))
            .attr('y', yScale1(7))
            .attr('text-anchor', 'middle')
            .text('W = ∫F(x)dx')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .style('fill', '#3498db');
        
        g1.append('text')
            .attr('x', xScale1(4))
            .attr('y', yScale1(10))
            .text('F = 2x + 1')
            .style('font-size', '14px')
            .style('fill', '#e74c3c');
        
        // 下半部分：速度-路程
        const velocityDiv = mainDiv.append('div')
            .style('flex', '1')
            .style('position', 'relative');
        
        const svg2 = velocityDiv.append('svg')
            .attr('width', '100%')
            .attr('height', '100%');
        
        const g2 = svg2.append('g')
            .attr('transform', 'translate(60, 30)');
        
        // 速度图像 v(t) = 3sin(t) + 5
        const xScale2 = d3.scaleLinear()
            .domain([0, 2 * Math.PI])
            .range([0, workWidth]);
        
        const yScale2 = d3.scaleLinear()
            .domain([0, 10])
            .range([workHeight, 0]);
        
        // 坐标轴
        g2.append('g')
            .attr('transform', `translate(0,${workHeight})`)
            .call(d3.axisBottom(xScale2).tickFormat(d => d === 0 ? '0' : d === Math.PI ? 'π' : d === 2*Math.PI ? '2π' : d.toFixed(1)))
            .append('text')
            .attr('x', workWidth)
            .attr('y', 35)
            .attr('fill', 'black')
            .text('t (s)');
        
        g2.append('g')
            .call(d3.axisLeft(yScale2))
            .append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -35)
            .attr('x', 0)
            .attr('fill', 'black')
            .text('v (m/s)');
        
        // 速度曲线
        const velocityData = d3.range(0, 2 * Math.PI + 0.1, 0.1).map(t => ({
            t: t,
            v: 3 * Math.sin(t) + 5
        }));
        
        const velocityLine = d3.line()
            .x(d => xScale2(d.t))
            .y(d => yScale2(d.v));
        
        g2.append('path')
            .datum(velocityData)
            .attr('d', velocityLine)
            .attr('fill', 'none')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3);
        
        // 动态填充路程
        let currentT = 0;
        const pathArea = d3.area()
            .x(d => xScale2(d.t))
            .y0(workHeight)
            .y1(d => yScale2(d.v));
        
        const distancePath = g2.append('path')
            .attr('fill', '#2ecc71')
            .attr('opacity', 0.3);
        
        function animateDistance() {
            if (!globalAnimationPlaying) {
                setTimeout(animateDistance, 100);
                return;
            }
            
            currentT += 0.05 * globalAnimationSpeed;
            if (currentT > 2 * Math.PI) currentT = 0;
            
            const currentData = velocityData.filter(d => d.t <= currentT);
            distancePath.datum(currentData)
                .attr('d', pathArea);
            
            // 更新路程显示
            const distance = currentData.reduce((sum, d, i) => {
                if (i > 0) {
                    const dt = d.t - currentData[i-1].t;
                    return sum + d.v * dt;
                }
                return sum;
            }, 0);
            
            if (!g2.select('.distance-text').node()) {
                g2.append('text')
                    .attr('class', 'distance-text')
                    .attr('x', xScale2(Math.PI))
                    .attr('y', yScale2(8))
                    .attr('text-anchor', 'middle')
                    .style('font-size', '16px')
                    .style('font-weight', 'bold')
                    .style('fill', '#2ecc71');
            }
            
            g2.select('.distance-text')
                .text(`s = ${distance.toFixed(1)} m`);
            
            requestAnimationFrame(animateDistance);
        }
        
        animateDistance();
        
        // 标注
        g2.append('text')
            .attr('x', xScale2(Math.PI * 1.5))
            .attr('y', yScale2(9))
            .text('v = 3sin(t) + 5')
            .style('font-size', '14px')
            .style('fill', '#2ecc71');
    }

    // 第16页：常用积分公式可视化
    function visualizeFormulas() {
        const container = d3.select('#vis-formulas');
        container.selectAll('*').remove();
        
        const div = container.append('div')
            .style('width', '100%')
            .style('height', '100%')
            .style('overflow-y', 'auto')
            .style('padding', '20px')
            .style('background', 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)');
        
        // 创建公式卡片容器
        const cardsContainer = div.append('div')
            .style('display', 'grid')
            .style('grid-template-columns', 'repeat(auto-fit, minmax(250px, 1fr))')
            .style('gap', '20px')
            .style('max-width', '1000px')
            .style('margin', '0 auto');
        
        // 公式数据
        const formulas = [
            { 
                category: '幂函数', 
                formula: '∫xⁿdx = xⁿ⁺¹/(n+1) + C',
                color: '#3498db',
                icon: 'xⁿ'
            },
            { 
                category: '指数函数', 
                formula: '∫eˣdx = eˣ + C',
                color: '#2ecc71',
                icon: 'eˣ'
            },
            { 
                category: '对数函数', 
                formula: '∫(1/x)dx = ln|x| + C',
                color: '#e74c3c',
                icon: 'ln'
            },
            { 
                category: '正弦函数', 
                formula: '∫sin x dx = -cos x + C',
                color: '#f39c12',
                icon: 'sin'
            },
            { 
                category: '余弦函数', 
                formula: '∫cos x dx = sin x + C',
                color: '#9b59b6',
                icon: 'cos'
            },
            { 
                category: '正切函数', 
                formula: '∫tan x dx = -ln|cos x| + C',
                color: '#1abc9c',
                icon: 'tan'
            }
        ];
        
        // 创建公式卡片
        formulas.forEach((item, i) => {
            const card = cardsContainer.append('div')
                .style('background', '#ffffff')
                .style('border-radius', '15px')
                .style('padding', '20px')
                .style('box-shadow', '0 10px 30px rgba(15, 23, 42, 0.18)')
                .style('transform', 'translateY(50px)')
                .style('opacity', '0')
                .style('transition', 'all 0.5s ease')
                .style('cursor', 'pointer');
            
            // 添加图标
            card.append('div')
                .style('width', '60px')
                .style('height', '60px')
                .style('background', item.color)
                .style('border-radius', '50%')
                .style('display', 'flex')
                .style('align-items', 'center')
                .style('justify-content', 'center')
                .style('margin', '0 auto 15px')
                .style('color', '#ffffff')
                .style('font-size', '24px')
                .style('font-weight', 'bold')
                .text(item.icon);
            
            // 添加分类标题
            card.append('h4')
                .style('text-align', 'center')
                .style('color', item.color)
                .style('margin', '10px 0')
                .text(item.category);
            
            // 添加公式
            card.append('div')
                .style('background', '#f8f9fa')
                .style('padding', '10px')
                .style('border-radius', '8px')
                .style('text-align', 'center')
                .style('font-family', 'monospace')
                .style('font-size', '14px')
                .style('color', '#2c3e50')
                .text(item.formula);
            
            // 动画效果
            setTimeout(() => {
                card.style('transform', 'translateY(0)')
                    .style('opacity', '1');
            }, i * 100);
            
            // 悬停效果
            card.on('mouseover', function() {
                d3.select(this)
                    .style('transform', 'translateY(-10px) scale(1.05)')
                    .style('box-shadow', '0 15px 40px rgba(15, 23, 42, 0.2)');
            })
            .on('mouseout', function() {
                d3.select(this)
                    .style('transform', 'translateY(0) scale(1)')
                    .style('box-shadow', '0 10px 30px rgba(15, 23, 42, 0.18)');
            });
            
            // 点击效果
            card.on('click', function() {
                // 创建展开效果
                const expansion = d3.select(this);
                expansion.style('transform', 'scale(1.1)')
                    .transition()
                    .duration(200)
                    .style('transform', 'scale(0.95)')
                    .transition()
                    .duration(200)
                    .style('transform', 'scale(1)');
                
                // 添加示例（可选）
                if (!d3.select(this).select('.example').node()) {
                    const example = d3.select(this).append('div')
                        .attr('class', 'example')
                        .style('margin-top', '15px')
                        .style('padding-top', '15px')
                        .style('border-top', '1px solid #e0e0e0')
                        .style('font-size', '12px')
                        .style('color', '#666')
                        .style('opacity', '0');
                    
                    let exampleText = '';
                    switch(item.category) {
                        case '幂函数':
                            exampleText = '例: ∫x²dx = x³/3 + C';
                            break;
                        case '指数函数':
                            exampleText = '例: ∫2eˣdx = 2eˣ + C';
                            break;
                        case '对数函数':
                            exampleText = '例: ∫(1/2x)dx = ½ln|x| + C';
                            break;
                        case '正弦函数':
                            exampleText = '例: ∫3sin x dx = -3cos x + C';
                            break;
                        case '余弦函数':
                            exampleText = '例: ∫2cos x dx = 2sin x + C';
                            break;
                        case '正切函数':
                            exampleText = '例: ∫tan x dx = -ln|cos x| + C';
                            break;
                    }
                    
                    example.text(exampleText);
                    example.transition()
                        .duration(300)
                        .style('opacity', '1');
                } else {
                    d3.select(this).select('.example')
                        .transition()
                        .duration(300)
                        .style('opacity', '0')
                        .remove();
                }
            });
        });
        
        // 添加标题
        div.insert('h2', ':first-child')
            .style('text-align', 'center')
            .style('color', '#ffffff')
            .style('font-size', '32px')
            .style('margin-bottom', '30px')
            .style('text-shadow', '2px 2px 4px rgba(15, 23, 42, 0.2)')
            .text('常用积分公式速查')
            .style('opacity', '0')
            .transition()
            .duration(500)
            .style('opacity', '1');
        
        // 添加提示文字
        div.append('p')
            .style('text-align', 'center')
            .style('color', 'rgba(255,255,255,0.9)')
            .style('margin-top', '20px')
            .style('font-size', '14px')
            .text('<i class="fa-solid fa-lightbulb"></i> 点击卡片查看示例')
            .style('opacity', '0')
            .transition()
            .delay(600)
            .duration(500)
            .style('opacity', '1');
    }

    // 第17页：总结页可视化
    function visualizeSummary() {
        const container = d3.select('#vis-summary');
        container.selectAll('*').remove();
        
        const width = container.node().getBoundingClientRect().width;
        const height = container.node().getBoundingClientRect().height;
        
        const svg = container.append('svg')
            .attr('width', width)
            .attr('height', height);
        
        const centerX = width / 2;
        const centerY = height / 2;
        
        // 创建渐变背景
        const defs = svg.append('defs');
        const gradient = defs.append('radialGradient')
            .attr('id', 'summary-gradient')
            .attr('cx', '50%')
            .attr('cy', '50%')
            .attr('r', '50%');
        
        gradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#667eea')
            .style('stop-opacity', 0.2);
        
        gradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#764ba2')
            .style('stop-opacity', 0.1);
        
        svg.append('rect')
            .attr('width', width)
            .attr('height', height)
            .attr('fill', 'url(#summary-gradient)');
        
        // 创建中心的积分符号
        const mainG = svg.append('g')
            .attr('transform', `translate(${centerX}, ${centerY})`);
        
        // 积分符号
        mainG.append('text')
            .attr('text-anchor', 'middle')
            .attr('font-size', '120px')
            .attr('fill', '#3498db')
            .attr('font-weight', 'bold')
            .text('∫')
            .style('opacity', 0)
            .transition()
            .duration(1000)
            .style('opacity', 0.8);
        
        // 四个关键词环绕
        const keywords = [
            { text: '分割', angle: 0, color: '#3498db' },
            { text: '近似', angle: 90, color: '#2ecc71' },
            { text: '求和', angle: 180, color: '#f39c12' },
            { text: '极限', angle: 270, color: '#e74c3c' }
        ];
        
        const radius = 150;
        keywords.forEach((kw, i) => {
            const angle = (kw.angle - 90) * Math.PI / 180;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            
            const kwG = mainG.append('g')
                .attr('transform', `translate(${x}, ${y})`);
            
            // 圆形背景
            kwG.append('circle')
                .attr('r', 0)
                .attr('fill', kw.color)
                .attr('opacity', 0.3)
                .transition()
                .delay(500 + i * 200)
                .duration(500)
                .attr('r', 50);
            
            // 文字
            kwG.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                .attr('font-size', '24px')
                .attr('font-weight', 'bold')
                .attr('fill', kw.color)
                .text(kw.text)
                .style('opacity', 0)
                .transition()
                .delay(700 + i * 200)
                .duration(500)
                .style('opacity', 1);
            
            // 连接线
            mainG.append('line')
                .attr('x1', 0)
                .attr('y1', 0)
                .attr('x2', 0)
                .attr('y2', 0)
                .attr('stroke', kw.color)
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5')
                .attr('opacity', 0.5)
                .transition()
                .delay(600 + i * 200)
                .duration(500)
                .attr('x2', x * 0.6)
                .attr('y2', y * 0.6);
        });
        
        // 应用领域小图标
        const applications = [
            { text: '△', label: '几何', x: -180, y: -100 },
            { text: 'F', label: '物理', x: 180, y: -100 },
            { text: '$', label: '经济', x: -180, y: 100 },
            { text: 'P', label: '概率', x: 180, y: 100 }
        ];
        
        applications.forEach((app, i) => {
            const appG = mainG.append('g')
                .attr('transform', `translate(${app.x}, ${app.y})`);
            
            appG.append('text')
                .attr('text-anchor', 'middle')
                .attr('font-size', '36px')
                .text(app.text)
                .style('opacity', 0)
                .transition()
                .delay(1500 + i * 150)
                .duration(500)
                .style('opacity', 1);
            
            appG.append('text')
                .attr('text-anchor', 'middle')
                .attr('y', 30)
                .attr('font-size', '14px')
                .attr('fill', '#2c3e50')
                .attr('font-weight', 'bold')
                .text(app.label)
                .style('opacity', 0)
                .transition()
                .delay(1700 + i * 150)
                .duration(500)
                .style('opacity', 1);
        });
        
        // 底部标语
        mainG.append('text')
            .attr('y', 250)
            .attr('text-anchor', 'middle')
            .attr('font-size', '20px')
            .attr('font-weight', 'bold')
            .attr('fill', '#9b59b6')
            .text('定积分 - 微积分的基石')
            .style('opacity', 0)
            .transition()
            .delay(2500)
            .duration(1000)
            .style('opacity', 1);
        
        // 添加旋转动画
        let angle = 0;
        function rotate() {
            if (!globalAnimationPlaying) {
                setTimeout(rotate, 100);
                return;
            }
            
            angle += 0.2 * globalAnimationSpeed;
            
            // 让关键词组轻微旋转
            keywords.forEach((kw, i) => {
                const kwAngle = (kw.angle + angle) * Math.PI / 180;
                const x = Math.cos(kwAngle - Math.PI / 2) * radius;
                const y = Math.sin(kwAngle - Math.PI / 2) * radius;
                
                d3.select(mainG.selectAll('g').nodes()[i + 1])
                    .attr('transform', `translate(${x}, ${y})`);
                
                d3.select(mainG.selectAll('line').nodes()[i])
                    .attr('x2', x * 0.6)
                    .attr('y2', y * 0.6);
            });
            
            requestAnimationFrame(rotate);
        }
        
        setTimeout(() => rotate(), 2000);
    }

    // 第17页：换元积分法可视化
    function visualizeSubstitutionMethod() {
        const containerId = 'vis-substitution-method';
        const steps = [
            {
                title: '原积分',
                formula: '\\int_a^b f(x)dx',
                color: '#3498db'
            },
            {
                title: '换元 x = φ(t)',
                formula: 'dx = \\varphi\'(t)dt',
                color: '#2ecc71'
            },
            {
                title: '变换积分限',
                formula: 'x=a \\Rightarrow t=\\alpha, \\quad x=b \\Rightarrow t=\\beta',
                color: '#f39c12'
            },
            {
                title: '新积分',
                formula: '\\int_\\alpha^\\beta f[\\varphi(t)]\\varphi\'(t)dt',
                color: '#e74c3c'
            }
        ];
        visualizeStepByStep(containerId, steps);
    }

    // 第18页：换元法例题可视化
    function visualizeSubstitutionExample() {
        const containerId = 'vis-substitution-example';
        const steps = [
            {
                title: '题目',
                formula: '\\int_0^4 \\frac{x}{\\sqrt{1+x}}dx',
                color: '#3498db'
            },
            {
                title: '换元',
                formula: 't = \\sqrt{1+x}, \\quad x = t^2-1, \\quad dx = 2t\\,dt',
                color: '#2ecc71'
            },
            {
                title: '变换积分限',
                formula: 'x=0 \\Rightarrow t=1, \\quad x=4 \\Rightarrow t=\\sqrt{5}',
                color: '#f39c12'
            },
            {
                title: '代入并简化',
                formula: '\\int_1^{\\sqrt{5}} \\frac{t^2-1}{t} \\cdot 2t\\,dt = 2\\int_1^{\\sqrt{5}} (t^2-1)dt',
                color: '#9b59b6'
            },
            {
                title: '计算结果',
                formula: '= 2\\left[\\frac{t^3}{3} - t\\right]_1^{\\sqrt{5}} = \\frac{20\\sqrt{5} - 8}{3}',
                color: '#e74c3c'
            }
        ];
        visualizeStepByStep(containerId, steps);
    }

    // 第19页：分部积分法可视化
    function visualizePartsMethod() {
        const containerId = 'vis-parts-method';
        const steps = [
            {
                title: '分部积分公式',
                formula: '\\int_a^b u\\,dv = [uv]_a^b - \\int_a^b v\\,du',
                color: '#3498db'
            },
            {
                title: '选择u和dv',
                formula: '\\text{u: 反对幂指三} \\quad \\text{dv: 容易积分}',
                color: '#2ecc71'
            },
            {
                title: '求导和积分',
                formula: 'du = u\'dx, \\quad v = \\int dv',
                color: '#f39c12'
            },
            {
                title: '代入公式计算',
                formula: '= [uv]_a^b - \\int_a^b v\\,du',
                color: '#e74c3c'
            }
        ];
        visualizeStepByStep(containerId, steps);
    }

    // 第20页：分部积分例题可视化
    function visualizePartsExample() {
        const containerId = 'vis-parts-example';
        const steps = [
            {
                title: '题目',
                formula: '\\int_0^{\\frac{\\pi}{2}} x\\sin x\\,dx',
                color: '#3498db'
            },
            {
                title: '选择u和dv',
                formula: 'u = x, \\quad dv = \\sin x\\,dx',
                color: '#2ecc71'
            },
            {
                title: '求导和积分',
                formula: 'du = dx, \\quad v = -\\cos x',
                color: '#f39c12'
            },
            {
                title: '应用公式',
                formula: '= [-x\\cos x]_0^{\\frac{\\pi}{2}} + \\int_0^{\\frac{\\pi}{2}} \\cos x\\,dx',
                color: '#9b59b6'
            },
            {
                title: '计算结果',
                formula: '= 0 + [\\sin x]_0^{\\frac{\\pi}{2}} = 1',
                color: '#e74c3c'
            }
        ];
        visualizeStepByStep(containerId, steps);
    }

    // 第21页：广义积分可视化
    function visualizeImproperIntegral() {
        const containerId = 'vis-improper-integral';
        const setup = setupD3(containerId);
        if (!setup) return;
        const { g, width, height } = setup;

        // 标题
        g.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .style('font-size', '20px')
            .style('font-weight', 'bold')
            .style('fill', '#2c3e50')
            .text('广义积分的两种类型');

        // 类型1：无限区间
        const type1G = g.append('g')
            .attr('transform', `translate(0, 80)`);

        type1G.append('rect')
            .attr('x', 20)
            .attr('y', 0)
            .attr('width', width - 40)
            .attr('height', 140)
            .attr('fill', '#e8f4f8')
            .attr('rx', 10)
            .style('opacity', 0)
            .transition()
            .duration(800)
            .style('opacity', 1);

        type1G.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .style('fill', '#3498db')
            .text('类型一：无限区间')
            .style('opacity', 0)
            .transition()
            .delay(400)
            .duration(600)
            .style('opacity', 1);

        type1G.append('text')
            .attr('x', width / 2)
            .attr('y', 70)
            .attr('text-anchor', 'middle')
            .attr('class', 'tex2jax_process')
            .style('font-size', '15px')
            .style('fill', '#2c3e50')
            .text('\\[\\int_a^{+\\infty} f(x)dx = \\lim_{b \\to +\\infty} \\int_a^b f(x)dx\\]')
            .style('opacity', 0)
            .transition()
            .delay(800)
            .duration(600)
            .style('opacity', 1);

        type1G.append('text')
            .attr('x', width / 2)
            .attr('y', 100)
            .attr('text-anchor', 'middle')
            .style('font-size', '13px')
            .style('fill', '#555')
            .style('font-style', 'italic')
            .text('例：')
            .style('opacity', 0)
            .transition()
            .delay(1200)
            .duration(600)
            .style('opacity', 1);
            
        const fo1 = type1G.append('foreignObject')
            .attr('x', 50)
            .attr('y', 108)
            .attr('width', width - 100)
            .attr('height', 40)
            .style('opacity', 0);
            
        fo1.append('xhtml:div')
            .attr('class', 'tex2jax_process')
            .style('text-align', 'center')
            .style('font-size', '14px')
            .style('color', '#7f8c8d')
            .html('$\\int_0^{+\\infty} e^{-x} dx = 1$');
            
        fo1.transition()
            .delay(1200)
            .duration(600)
            .style('opacity', 1);

        // 类型2：无界函数
        const type2G = g.append('g')
            .attr('transform', `translate(0, 240)`);

        type2G.append('rect')
            .attr('x', 20)
            .attr('y', 0)
            .attr('width', width - 40)
            .attr('height', 140)
            .attr('fill', '#fef5e7')
            .attr('rx', 10)
            .style('opacity', 0)
            .transition()
            .delay(600)
            .duration(800)
            .style('opacity', 1);

        type2G.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .style('font-size', '16px')
            .style('font-weight', 'bold')
            .style('fill', '#f39c12')
            .text('类型二：无界函数（瑕积分）')
            .style('opacity', 0)
            .transition()
            .delay(1000)
            .duration(600)
            .style('opacity', 1);

        type2G.append('text')
            .attr('x', width / 2)
            .attr('y', 70)
            .attr('text-anchor', 'middle')
            .attr('class', 'tex2jax_process')
            .style('font-size', '15px')
            .style('fill', '#2c3e50')
            .text('\\[\\int_a^b f(x)dx = \\lim_{\\varepsilon \\to 0^+} \\int_{a+\\varepsilon}^b f(x)dx\\]')
            .style('opacity', 0)
            .transition()
            .delay(1400)
            .duration(600)
            .style('opacity', 1);

        type2G.append('text')
            .attr('x', width / 2)
            .attr('y', 100)
            .attr('text-anchor', 'middle')
            .style('font-size', '13px')
            .style('fill', '#555')
            .style('font-style', 'italic')
            .text('例：')
            .style('opacity', 0)
            .transition()
            .delay(1800)
            .duration(600)
            .style('opacity', 1);
            
        const fo2 = type2G.append('foreignObject')
            .attr('x', 50)
            .attr('y', 108)
            .attr('width', width - 100)
            .attr('height', 40)
            .style('opacity', 0);
            
        fo2.append('xhtml:div')
            .attr('class', 'tex2jax_process')
            .style('text-align', 'center')
            .style('font-size', '14px')
            .style('color', '#7f8c8d')
            .html('$\\int_0^1 \\frac{1}{\\sqrt{x}} dx$ ($x=0$ 为瑕点)');
            
        fo2.transition()
            .delay(1800)
            .duration(600)
            .style('opacity', 1);

        // 触发MathJax渲染
        setTimeout(() => {
            if (window.MathJax && window.MathJax.typesetPromise) {
                const container = document.getElementById(containerId);
                MathJax.typesetPromise([container]).catch((err) => console.log(err));
            }
        }, 2500);
    }
 </script>

 <!-- 悬浮控制按钮与二级菜单（统一样式） -->
 <button class="floating-control-btn" id="floating-control-btn"><span class="btn-icon">+</span></button>
 <div class="floating-menu-items" id="floating-menu-items">
     <div class="floating-menu-item" onclick="event.stopPropagation(); toggleLabSubmenu()">
         <span class="item-icon"><i class="fa-solid fa-flask"></i></span>
         <span class="item-text">实验室</span>
     </div>
     <div class="floating-menu-item" onclick="event.stopPropagation(); toggleChapterSubmenu()">
         <span class="item-icon"><i class="fa-solid fa-clipboard-list"></i></span>
         <span class="item-text">本章目录</span>
     </div>
 </div>

 <!-- 实验室弹层（第六章） -->
 <div class="lab-submenu" id="lab-submenu" style="display: none;">
     <div class="submenu-content">
         <div class="submenu-title">第六章实验室</div>
         <div class="submenu-grid">
             <div class="submenu-item" onclick="window.open('../网页资源/index.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-list"></i></span><span class="submenu-text">资源总览</span></div>
             <div class="submenu-item" onclick="window.open('../网页资源/lab 6-1.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">定积分概念与黎曼和实验室</span></div>
             <div class="submenu-item" onclick="window.open('../网页资源/lab 6-2.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">牛顿-莱布尼茨公式实验室</span></div>
             <div class="submenu-item" onclick="window.open('../网页资源/lab 6-3.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">定积分的换元与分部积分实验室</span></div>
             <div class="submenu-item" onclick="window.open('../网页资源/lab 6-4.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">微元法与面积建模实验室</span></div>
             <div class="submenu-item" onclick="window.open('../网页资源/lab 6-5.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">定积分物理应用实验室</span></div>
         </div>
         <div class="submenu-close" onclick="toggleLabSubmenu()">×</div>
     </div>
 </div>

 <!-- 本章目录弹层（自动生成） -->
 <div class="lab-submenu" id="chapter-submenu" style="display:none;">
     <div class="submenu-content">
         <div class="submenu-title">第六章目录</div>
         <div class="submenu-grid" id="chapter-submenu-grid"></div>
         <div class="submenu-close" onclick="toggleChapterSubmenu()">×</div>
     </div>
 </div>

 <!-- 全部课件目录弹层 -->
 <div class="lab-submenu" id="course-submenu" style="display: none;">
     <div class="submenu-content">
         <div class="submenu-title">全部课件目录</div>
         <div class="submenu-grid">
             <div class="submenu-item" onclick="window.location.href='第1章代数.html';"><span class="submenu-icon"><i class="fa-solid fa-1"></i></span><span class="submenu-text">第1章 代数</span></div>
             <div class="submenu-item" onclick="window.location.href='第2章极限与连续.html';"><span class="submenu-icon"><i class="fa-solid fa-2"></i></span><span class="submenu-text">第2章 极限与连续</span></div>
             <div class="submenu-item" onclick="window.location.href='第3章导数与微分.html';"><span class="submenu-icon"><i class="fa-solid fa-3"></i></span><span class="submenu-text">第3章 导数与微分</span></div>
             <div class="submenu-item" onclick="window.location.href='第4章导数应用.html';"><span class="submenu-icon"><i class="fa-solid fa-4"></i></span><span class="submenu-text">第4章 导数应用</span></div>
             <div class="submenu-item" onclick="window.location.href='第5章不定积分.html';"><span class="submenu-icon"><i class="fa-solid fa-5"></i></span><span class="submenu-text">第5章 不定积分</span></div>
             <div class="submenu-item" onclick="window.location.href='第6章定积分.html';"><span class="submenu-icon"><i class="fa-solid fa-6"></i></span><span class="submenu-text">第6章 定积分</span></div>
             <div class="submenu-item" onclick="window.location.href='第7章常微分方程.html';"><span class="submenu-icon"><i class="fa-solid fa-7"></i></span><span class="submenu-text">第7章 常微分方程</span></div>
             <div class="submenu-item" onclick="window.location.href='第8章多元函数微分学.html';"><span class="submenu-icon"><i class="fa-solid fa-8"></i></span><span class="submenu-text">第8章 多元函数微分学</span></div>
             <div class="submenu-item" onclick="window.location.href='第9章多元函数积分学初步.html';"><span class="submenu-icon"><i class="fa-solid fa-9"></i></span><span class="submenu-text">第9章 多元函数积分学初步</span></div>
             <div class="submenu-item" onclick="window.location.href='第10章线性代数.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第10章 线性代数</span></div>
             <div class="submenu-item" onclick="window.location.href='第11章无穷级数.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第11章 无穷级数</span></div>
             <div class="submenu-item" onclick="window.location.href='第12章向量代数与空间解析几何.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第12章 向量代数与空间解析几何</span></div>
             <div class="submenu-item" onclick="window.location.href='第13章概率与统计.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第13章 概率与统计</span></div>
         </div>
         <div class="submenu-close" onclick="toggleCourseSubmenu()">×</div>
     </div>
 </div>

 <script>
 // 悬浮菜单互斥控制与切换
 function closeAllSubmenus(exceptId) {
     ['lab-submenu','chapter-submenu','course-submenu'].forEach(id => {
         if (id !== exceptId) {
             const el = document.getElementById(id);
             if (el) el.style.display = 'none';
         }
     });
 }
 function toggleLabSubmenu() {
     const el = document.getElementById('lab-submenu');
     if (!el) return;
     const willOpen = el.style.display !== 'block';
     closeAllSubmenus('lab-submenu');
     el.style.display = willOpen ? 'block' : 'none';
 }
 function toggleChapterSubmenu() {
     const el = document.getElementById('chapter-submenu');
     if (!el) return;
     const willOpen = el.style.display !== 'block';
     closeAllSubmenus('chapter-submenu');
     if (willOpen) buildChapterMenuCh6();
     el.style.display = willOpen ? 'block' : 'none';
 }
 function toggleCourseSubmenu() {
     const el = document.getElementById('course-submenu');
     if (!el) return;
     const willOpen = el.style.display !== 'block';
     closeAllSubmenus('course-submenu');
     el.style.display = willOpen ? 'block' : 'none';
 }
 function initFloatingControl() {
     const floatingBtn = document.getElementById('floating-control-btn');
     const floatingMenu = document.getElementById('floating-menu-items');
     if (!floatingBtn || !floatingMenu) return;
     floatingBtn.addEventListener('click', function(e) {
         e.stopPropagation();
         floatingBtn.classList.toggle('active');
         floatingMenu.classList.toggle('active');
     });
 }
 // 自动构建“第六章目录”
 function buildChapterMenuCh6() {
     const grid = document.getElementById('chapter-submenu-grid');
     if (!grid) return;
     grid.innerHTML = '';
     const cover = document.createElement('div');
     cover.className = 'submenu-item';
     cover.innerHTML = '<span class="submenu-icon"><i class="fa-solid fa-house"></i></span><span class="submenu-text">封面</span>';
     cover.onclick = function() { try { goToSlide(0); } catch(_) {} toggleChapterSubmenu(); };
     grid.appendChild(cover);
     const toc = document.createElement('div');
     toc.className = 'submenu-item';
     toc.innerHTML = '<span class="submenu-icon"><i class="fa-solid fa-list-ul"></i></span><span class="submenu-text">目录页</span>';
     toc.onclick = function() { try { goToSlide(1); } catch(_) {} toggleChapterSubmenu(); };
     grid.appendChild(toc);
     const slides = document.querySelectorAll('#slidesContainer > .slide');
     slides.forEach((slide, idx) => {
         const h1 = slide.querySelector('.left-content h1');
         const h2 = slide.querySelector('.left-content h2');
         const title = (h1 && h1.textContent.trim()) || (h2 && h2.textContent.trim()) || '';
         if (!title) return;
         if (title === '目录') return;
         const item = document.createElement('div');
         item.className = 'submenu-item';
         item.innerHTML = '<span class="submenu-icon"><i class="fa-solid fa-file-lines"></i></span><span class="submenu-text">' + title.replace(/\s+/g,' ') + '</span>';
         item.onclick = function() { try { goToSlide(idx); } catch(_) {} toggleChapterSubmenu(); };
         grid.appendChild(item);
     });
 }
 document.addEventListener('DOMContentLoaded', function() {
     initFloatingControl();
     ['lab-submenu','chapter-submenu','course-submenu'].forEach(id => {
         const el = document.getElementById(id);
         if (!el) return;
         const content = el.querySelector('.submenu-content');
         if (content) content.addEventListener('click', ev => ev.stopPropagation());
     });
     document.addEventListener('click', () => {
         closeAllSubmenus();
         const floatingBtn = document.getElementById('floating-control-btn');
         const floatingMenu = document.getElementById('floating-menu-items');
         if (floatingBtn && floatingMenu) {
             floatingBtn.classList.remove('active');
             floatingMenu.classList.remove('active');
         }
     });
     document.addEventListener('keydown', (ev) => {
         if (ev.key === 'Escape') {
             closeAllSubmenus();
             const floatingBtn = document.getElementById('floating-control-btn');
             const floatingMenu = document.getElementById('floating-menu-items');
             if (floatingBtn && floatingMenu) {
                 floatingBtn.classList.remove('active');
                 floatingMenu.classList.remove('active');
             }
         }
     });
 });
 </script>

 </body>
<script>
// 目录卡片点击跳转到对应页
document.addEventListener('DOMContentLoaded', function() {
    const tocItems = document.querySelectorAll('.chapter-toc .toc-item');
    // 目标页索引（0 基）：“概念”→第3页(2)，“性质与计算”→第10页(9)，“应用”→第13页(12)，“积分方法”→第17页(16)
    const targets = [2, 9, 12, 16];
    tocItems.forEach((el, i) => {
        el.addEventListener('click', function() {
            if (targets[i] != null && typeof goToSlide === 'function') {
                goToSlide(targets[i]);
            }
        });
    });

    // 子项逐条跳转：根据关键字智能匹配对应页面标题
    const slides = Array.from(document.querySelectorAll('#slidesContainer > .slide'));
    const slideTitles = slides.map(slide => {
        const t1 = slide.querySelector('.left-content h1');
        const t2 = slide.querySelector('.left-content h2');
        const t3 = slide.querySelector('.left-content h3');
        return ((t1 && t1.textContent) || (t2 && t2.textContent) || (t3 && t3.textContent) || '').trim();
    });
    function findIndexByPatterns(patterns) {
        for (let i = 0; i < slideTitles.length; i++) {
            const t = slideTitles[i] || '';
            for (const p of patterns) {
                if (p && t.includes(p)) return i;
            }
        }
        return null;
    }
    const manualMap = new Map([
        ['问题引入：不规则图形面积', ['面积', '问题']],
        ['曲边梯形与分割思想', ['曲边梯形', '化曲为直', '分割']],
        ['定积分的定义与几何意义', ['定积分', '几何意义']],
        ['基本性质（线性性、可加性）', ['定积分的性质', '性质']],
        ['牛顿-莱布尼茨公式', ['牛顿-莱布尼茨']],
        ['计算实例', ['计算实例']],
        ['求平面图形面积', ['应用：求面积', '求面积']],
        ['求旋转体体积', ['应用：求体积', '求体积']],
        ['物理应用', ['物理']],
        ['常用积分公式', ['常用积分公式', '公式表', '公式速查']],
        ['换元积分法', ['换元积分法', '换元法']],
        ['分部积分法', ['分部积分法']],
        ['广义积分简介', ['广义积分']]
    ]);
    const subItems = document.querySelectorAll('.chapter-toc .toc-list li');
    subItems.forEach(li => {
        const text = (li.textContent || '').trim();
        let patterns = manualMap.get(text);
        if (!patterns) {
            // 基于文案猜测关键字
            patterns = [];
            if (text.includes('问题引入')) patterns.push('面积');
            if (text.includes('曲边')) patterns.push('曲边梯形');
            if (text.includes('分割')) patterns.push('化曲为直');
            if (text.includes('定义') || text.includes('几何')) patterns.push('定积分', '几何意义');
            if (text.includes('性质')) patterns.push('性质');
            if (text.includes('牛顿') || text.includes('莱布尼茨')) patterns.push('牛顿-莱布尼茨');
            if (text.includes('计算实例')) patterns.push('计算实例');
            if (text.includes('面积')) patterns.push('应用：求面积', '求面积');
            if (text.includes('体积')) patterns.push('应用：求体积', '求体积');
            if (text.includes('物理')) patterns.push('物理');
            if (text.includes('公式')) patterns.push('常用积分公式', '公式表', '公式');
            if (text.includes('换元')) patterns.push('换元积分法');
            if (text.includes('分部')) patterns.push('分部积分法');
            if (text.includes('广义')) patterns.push('广义积分');
        }
        const idx = findIndexByPatterns(patterns || []);
        if (idx != null) {
            li.style.cursor = 'pointer';
            li.addEventListener('click', () => { if (typeof goToSlide === 'function') goToSlide(idx); });
        }
    });
});
</script>
</html>
