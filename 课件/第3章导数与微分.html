<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <link rel="stylesheet" href="../common-assets/css/fontawesome.min.css">
    <link rel="stylesheet" href="../common-assets/css/solid.min.css">
<!-- 用户需求：响应式设计优化，适配多种设备 -->
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="format-detection" content="telephone=no">
<title>第三章：导数与微分 (交互式课件)</title>
<script src="../common-assets/js/d3-7.8.5.min.js"></script>
    <!-- MathJax 配置 -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            },
            startup: {
                pageReady: () => {
                    return MathJax.startup.defaultPageReady().then(() => {
                        console.log('MathJax 初始化完成');
                    });
                }
            }
        };
    </script>
    <!-- 本地化MathJax资源 -->
    <script src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js"></script>
<style>
        /* === RESET AND BASE STYLES === */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
            height: 100%;
        }

        body {
            font-family: 'Inter', 'Source Han Sans SC', 'Noto Sans SC', 'Microsoft YaHei', system-ui, -apple-system, sans-serif;
            background: #FAFAFA;
            overflow: hidden;
            color: #1a1a1a;
            height: 100%;
            line-height: 1.6;
            font-weight: 400;
            /* 优化字体渲染 */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }

        /* 加载指示器 */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 16px;
            color: #6b7280;
        }

        /* === SLIDE LAYOUT === */
        .slide-container {
            width: 100%;
            height: 100vh;
            display: flex;
            position: relative;
            gap: 0;
            padding: 0;
        }

        /* Left Content Area - Academic Journal Style */
        .left-content {
            width: 50%;
            height: 100vh;
            padding: 60px 80px 60px 60px;
            background: #FBFBFB;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.6;
            border: none;
            box-shadow: none;
            border-radius: 0;
        }

        /* Right Visualization Area - Subtle Contrast */
        .right-visual {
            width: 50%;
            height: 100vh;
            background: #F8F9FA;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            border: none;
            box-shadow: none;
            border-radius: 0;
        }

        .right-visual > div {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--card-bg);
            border-radius: 24px;
            box-shadow: 0 24px 60px rgba(15, 23, 42, 0.12);
            padding: 24px;
        }

        /* === SLIDE TRANSITIONS === */
        .slide {
            display: none;
            animation: slideIn 0.5s ease-out;
        }

        .slide.active {
            display: flex;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* === 统一的字体系统 === */
        h1 {
            color: #003366;
            font-size: 28px;
            line-height: 1.3;
            font-weight: 700;
            margin: 0 0 24px 0;
            padding: 0;
            letter-spacing: -0.02em;
        }

        h2 {
            color: #008080;
            font-size: 22px;
            line-height: 1.4;
            font-weight: 600;
            margin: 32px 0 16px 0;
            position: relative;
            padding-left: 0;
        }

        h2::before {
            content: '';
            position: absolute;
            left: -20px;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #008080;
            border-radius: 2px;
        }

        h3 {
            color: #1a1a1a;
            font-size: 20px;
            line-height: 1.4;
            font-weight: 600;
            margin: 24px 0 12px 0;
        }

        h4 {
            color: #333333;
            font-size: 18px;
            line-height: 1.4;
            font-weight: 500;
            margin: 20px 0 8px 0;
        }

        h5 {
            color: #555555;
            font-size: 16px;
            line-height: 1.4;
            font-weight: 500;
            margin: 16px 0 8px 0;
        }

        p {
            margin-bottom: 16px;
            color: #2d2d2d;
            font-weight: 400;
            font-size: 16px;
            line-height: 1.6;
        }

        ul, ol {
            margin: 0 0 16px 0;
            line-height: 1.6;
            padding-left: 24px;
            font-size: 16px;
        }

        li {
            margin-bottom: 8px;
            color: #2d2d2d;
            font-size: 16px;
            line-height: 1.6;
        }

        /* === CONTENT MODULES - 去框化设计 === */
        .definition, .theorem, .example, .note {
            background: transparent;
            border: none;
            border-left: 4px solid;
            padding: 16px 0 16px 20px;
            margin: 20px 0;
        }

        .definition {
            border-left-color: #1e40af;
        }

        .theorem {
            border-left-color: #059669;
        }

        .example {
            border-left-color: #dc2626;
        }

        .note {
            border-left-color: #6b7280;
            font-style: italic;
            color: #4b5563;
        }

        .formula-highlight {
            background: transparent;
            padding: 24px 0;
            margin: 24px 0;
            text-align: center;
            font-size: 18px;
            border: none;
            box-shadow: none;
        }

        /* === MATHJAX FORMULA STYLING === */
        .MathJax {
            outline: none;
            display: inline-block;
        }

        .MathJax_Display {
            text-align: center !important;
            margin: 20px 0 !important;
        }

        /* SVG Container Styling */
        mjx-container[jax="SVG"] {
            display: inline-block !important;
            line-height: 1;
            vertical-align: baseline;
        }

        mjx-container[jax="SVG"][display="true"] {
            display: block !important;
            text-align: center !important;
            margin: 20px 0 !important;
        }

        mjx-container[jax="SVG"] svg {
            display: inline-block !important;
            vertical-align: baseline;
            max-width: 100%;
            height: auto;
        }

        mjx-container[jax="SVG"][display="true"] svg {
            display: block !important;
            margin: 0 auto !important;
        }

        /* Enhanced SVG Rendering */
        mjx-container svg {
            shape-rendering: geometricPrecision;
            text-rendering: geometricPrecision;
            font-family: 'MJXZERO', 'MJXTEX';
        }

        /* Force Visibility and Proper Display */
        mjx-container[jax="SVG"] {
            visibility: visible !important;
            opacity: 1 !important;
            overflow: visible !important;
        }

        mjx-container[jax="SVG"] svg {
            visibility: visible !important;
            opacity: 1 !important;
            width: auto !important;
            height: auto !important;
        }

        /* Content Area Formula Display */
        .left-content mjx-container {
            display: inline-block !important;
            margin: 0 3px;
        }

        .left-content mjx-container[display="true"] {
            display: block !important;
            text-align: center !important;
            margin: 20px 0 !important;
        }

        /* === SIMPLIFIED INTERACTIVE ELEMENTS === */
        .step-stack {
            margin: 32px 0;
        }

        .step-item {
            border: none;
            border-left: 3px solid #008080;
            border-radius: 0;
            padding: 0 0 0 20px;
            background: transparent;
            display: none;
            margin: 24px 0;
        }

        .step-item.active {
            display: block;
            background: transparent;
            border-left-color: #003366;
        }

        .step-btn {
            margin-top: 16px;
            padding: 8px 16px;
            border-radius: 0;
            border: 1px solid #E5E7EB;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            color: #003366;
            transition: all 0.2s ease;
        }

        .step-btn:hover {
            background: #003366;
            color: white;
            border-color: #003366;
        }

        .prompt-card {
            background: transparent;
            border: none;
            border-left: 3px solid #008080;
            border-radius: 0;
            padding: 0 0 0 20px;
            margin: 32px 0;
        }

        .teacher-note {
            background: transparent;
            border: none;
            border-left: 3px solid #CC5500;
            border-radius: 0;
            padding: 0 0 0 20px;
            margin: 32px 0;
            font-style: normal;
        }

        /* === CANVAS STYLING === */
        canvas {
            max-width: 95%;
            max-height: 95%;
            border-radius: 0;
            box-shadow: none;
        }

        /* === 导航控制 - 第二章极简设计 === */
        .nav-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 1000;
        }

        .nav-btn {
            background: rgba(0, 0, 0, 0.15);
            color: transparent;
            border: none;
            padding: 0;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0;
            transition: all 0.2s;
            position: relative;
        }

        .nav-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-top: 2px solid rgba(0, 0, 0, 0.5);
            border-right: 2px solid rgba(0, 0, 0, 0.5);
        }

        .nav-btn:first-child::before {
            transform: translate(-40%, -50%) rotate(-135deg);
        }

        .nav-btn:last-child::before {
            transform: translate(-60%, -50%) rotate(45deg);
        }

        .nav-btn:hover {
            background: rgba(0, 0, 0, 0.25);
        }

        .nav-btn:hover::before {
            border-color: rgba(0, 0, 0, 0.7);
        }

        .slide-number {
            font-size: 11px;
            color: #9ca3af;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 0;
            opacity: 0.6;
        }

        .slide-number input {
            width: 50px;
            text-align: right;
            border: none;
            background: transparent;
            font-size: 11px;
            padding: 0 2px;
            margin: 0;
            color: #000000;
            font-weight: 700;
        }

        .slide-number input::-webkit-outer-spin-button,
        .slide-number input::-webkit-inner-spin-button {
            display: none;
        }

        .slide-number input[type=number] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        .slide-number input:focus {
            outline: none;
            color: #000000;
        }

        #slideNumberTotal {
            color: #9ca3af;
        }

        /* === TABLE STYLING === */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 24px 0;
            border-radius: 0;
            overflow: visible;
            box-shadow: none;
        }

        th {
            background: #3b82f6;
            color: white;
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb;
        }

        tr:nth-child(even) {
            background-color: #f9fafb;
        }

        /* === COMPARISON GRID STYLES === */
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-card {
            padding: 20px 0 20px 20px;
            border-radius: 0;
            border: none;
            border-left: 4px solid;
            background: transparent;
        }

        .comparison-card.high-school {
            border-left-color: #3b82f6;
        }

        .comparison-card.college {
            border-left-color: #10b981;
        }

        .concept-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .concept-card {
            padding: 16px 0 16px 20px;
            border-radius: 0;
            border: none;
            border-left: 4px solid;
            background: transparent;
        }

        .concept-card.sequence {
            border-left-color: #fbbf24;
        }

        .concept-card.function {
            border-left-color: #22c55e;
        }

        .concept-card.convergent {
            border-left-color: #3b82f6;
        }

        .concept-card.divergent {
            border-left-color: #ef4444;
        }

        .infinitesimal-grid {
            display: grid;
            gap: 12px;
            margin: 20px 0;
        }

        .infinitesimal-card {
            padding: 12px 0 12px 16px;
            border-radius: 0;
            border: none;
            border-left: 4px solid;
            background: transparent;
        }

        .infinitesimal-card.higher-order {
            border-left-color: #3498db;
        }

        .infinitesimal-card.lower-order {
            border-left-color: #e74c3c;
        }

        .infinitesimal-card.same-order {
            border-left-color: #9b59b6;
        }

        .infinitesimal-card.equivalent {
            border-left-color: #2ecc71;
        }

        .equivalent-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 16px;
            margin: 20px 0;
        }

        .equivalent-card {
            padding: 14px 0 14px 18px;
            border-radius: 0;
            border: none;
            border-left: 4px solid;
            background: transparent;
        }

        .equivalent-card.trig {
            border-left-color: #3b82f6;
        }

        .equivalent-card.exp-log {
            border-left-color: #10b981;
        }

        /* === RESPONSIVE DESIGN === */
        /* 用户需求：全面的响应式设计，适配多种设备尺寸 */

        /* 超大屏幕 (≥1600px) */
        @media (min-width: 1600px) {
            .left-content {
                font-size: 18px;
                padding: 70px 90px 70px 70px;
            }

            h2 { font-size: 36px; }
            h3 { font-size: 26px; }

            .math-formula {
                font-size: 22px;
            }
        }

        /* 中等屏幕 (1200px-1600px) - 默认样式 */

        /* 小平板 (768px-1200px) */
        @media (max-width: 1200px) {
            .left-content {
                width: 45%;
                padding: 50px 60px 50px 50px;
                font-size: 15px;
            }

            .right-visual {
                width: 55%;
            }

            h2 { font-size: 26px; }
            h3 { font-size: 20px; }
        }

        /* 平板竖屏 (≤768px) */
        @media (max-width: 768px) {
            .slide-container {
                flex-direction: column;
                gap: 0;
                padding: 0;
            }

            .left-content,
            .right-visual {
                width: 100%;
                height: 50vh;
                min-height: 300px;
            }

            .left-content {
                padding: 30px 25px;
                font-size: 15px;
            }

            h2 { font-size: 24px; }
            h3 { font-size: 19px; }

            .nav-container {
                bottom: 10px;
                right: 10px;
                padding: 6px 10px;
            }

            .nav-btn {
                padding: 6px 12px;
                font-size: 14px;
                min-height: 44px;
            }

            .comparison-grid,
            .concept-grid,
            .equivalent-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }

            .math-formula {
                font-size: 16px;
            }
        }

        /* 手机横屏 (481px-768px) */
        @media (max-width: 768px) and (min-width: 481px) {
            .left-content {
                font-size: 14px;
                padding: 25px 20px;
            }

            h2 { font-size: 22px; }
            h3 { font-size: 18px; }
        }

        /* 手机竖屏 (≤480px) */
        @media (max-width: 480px) {
            .left-content {
                padding: 20px 15px;
                font-size: 14px;
                line-height: 1.5;
            }

            .right-visual {
                height: 45vh;
                min-height: 250px;
            }

            h2 { font-size: 20px; }
            h3 { font-size: 17px; }

            .math-formula {
                font-size: 15px;
            }

            .nav-container {
                padding: 5px 8px;
                font-size: 12px;
            }

            .nav-btn {
                padding: 5px 10px;
                font-size: 13px;
            }
        }

        /* 超小屏幕 (≤360px) */
        @media (max-width: 360px) {
            .left-content {
                padding: 15px 12px;
                font-size: 13px;
            }

            h2 { font-size: 18px; }
            h3 { font-size: 16px; }

            .math-formula {
                font-size: 14px;
            }
        }

        /* 横屏模式优化 */
        @media (max-height: 600px) and (orientation: landscape) {
            .slide-container {
                flex-direction: row;
            }

            .left-content,
            .right-visual {
                width: 50%;
                height: 100vh;
            }

            .left-content {
                padding: 20px 30px;
                font-size: 14px;
            }
        }

        /* 触摸设备优化 */
        @media (hover: none) and (pointer: coarse) {
            .nav-btn,
            button {
                min-height: 44px;
                min-width: 44px;
                padding: 12px 20px;
            }

            input[type="number"],
            input[type="text"] {
                min-height: 44px;
                font-size: 16px; /* 防止iOS自动缩放 */
            }

            /* 移除hover效果，使用active */
            .nav-btn:hover {
                background: transparent;
            }

            .nav-btn:active {
                background: rgba(0, 0, 0, 0.1);
                transform: scale(0.95);
            }
        }

        /* 打印样式 */
        @media print {
            .nav-container,
            .floating-control-btn,
            .floating-menu-items,
            .return-home-panel,
            .loading-overlay {
                display: none !important;
            }

            .slide {
                page-break-after: always;
            }

            .slide-container {
                flex-direction: column;
            }
        }

        /* 高对比度模式 */
        @media (prefers-contrast: high) {
            .highlight {
                border: 2px solid currentColor;
                padding: 2px 4px;
            }
        }

        /* 减少动画模式（无障碍） */
        @media (prefers-reduced-motion: reduce) {
            *,
            *::before,
            *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* === UTILITY CLASSES === */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            color: #003366;
            z-index: 9999;
            font-weight: 500;
        }

        /* === VISUAL HINTS AND UTILITY === */
        .visual-hint {
            font-style: italic;
            color: #666666;
            font-size: 15px;
            margin: 24px 0;
            padding-left: 20px;
            border-left: 2px solid #E5E7EB;
        }

        /* === CLEAN SCROLLBAR === */
        /* Webkit浏览器 (Chrome, Safari, Edge) */
        .left-content::-webkit-scrollbar {
            width: 6px;
        }

        .left-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .left-content::-webkit-scrollbar-thumb {
            background: #E5E7EB;
            border-radius: 3px;
        }

        .left-content::-webkit-scrollbar-thumb:hover {
            background: #D1D5DB;
        }

        /* Firefox */
        .left-content {
            scrollbar-width: thin;
            scrollbar-color: #E5E7EB transparent;
        }

        .error-message {
            color: #ef4444;
            text-align: center;
            padding: 20px;
            font-size: 16px;
            background: #fef2f2;
            border-radius: 8px;
            border: 1px solid #fecaca;
        }





        .lab-menu {
            position: fixed;
            bottom: 150px;
            right: 20px;
            z-index: 998;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            padding: 16px;
            min-width: 280px;
            max-height: 400px;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: all 0.3s ease;
            border: 1px solid #e5e7eb;
        }

        .lab-menu.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .lab-menu h3 {
            margin: 0 0 16px 0;
            color: #1f2937;
            font-size: 16px;
            font-weight: 600;
            text-align: center;
            border-bottom: 2px solid #3b82f6;
            padding-bottom: 8px;
        }

        .lab-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .lab-item {
            background: #3b82f6;
            color: white;
            text-decoration: none;
            padding: 10px 8px;
            border-radius: 6px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: block;
        }

        .lab-item:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        /* === SPECIAL CONTENT BLOCKS === */
        .knowledge-objective {
            background: transparent;
            color: #2d2d2d;
            padding: 0 0 0 20px;
            border-left: 3px solid #003366;
            border-radius: 0;
            margin: 32px 0;
            text-align: left;
            box-shadow: none;
        }

        .student-pain-points {
            background: transparent;
            padding: 0 0 0 20px;
            border-left: 3px solid #008080;
            border-radius: 0;
            margin: 32px 0;
            border: none;
        }

        /* === ANIMATIONS === */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        /* Example Content Styles */
        .example-content {
            margin: 32px 0;
        }

        .example-content h4 {
            color: #008080;
            margin: 16px 0 8px 0;
            font-size: 18px;
            font-weight: 600;
        }

        .example-content h4:first-child {
            margin-top: 0;
        }

        .example-content p {
            margin: 8px 0 16px 0;
            line-height: 1.6;
            font-size: 16px;
        }

        /* === 悬浮控制菜单样式 === */
        .floating-control-btn {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            border: none;
            cursor: pointer;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .floating-control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 40px rgba(59, 130, 246, 0.6);
        }

        .floating-control-btn .btn-icon {
            transition: transform 0.3s ease;
        }

        .floating-control-btn.active .btn-icon {
            transform: rotate(45deg);
        }

        .floating-menu-items {
            position: fixed;
            bottom: 30px;
            left: 30px;
            z-index: 999;
            pointer-events: none;
        }

        .floating-menu-item {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .floating-menu-items.active .floating-menu-item {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .floating-menu-item:hover {
            background: rgba(59, 130, 246, 0.1);
            transform: scale(1.05);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
        }

        .floating-menu-item .item-icon {
            font-size: 16px;
            min-width: 20px;
        }

        .floating-menu-item .item-text {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            white-space: nowrap;
        }

        /* 6个菜单项的弧形排列 */
        .floating-menu-item:nth-child(1) { bottom: 120px; left: 4px; transition-delay: 0.1s; }
        .floating-menu-item:nth-child(2) { bottom: 100px; left: 50px; transition-delay: 0.15s; }
        .floating-menu-item:nth-child(3) { bottom: 70px; left: 80px; transition-delay: 0.2s; }
        .floating-menu-item:nth-child(4) { bottom: 30px; left: 90px; transition-delay: 0.25s; }
        .floating-menu-item:nth-child(5) { bottom: -10px; left: 80px; transition-delay: 0.3s; }
        .floating-menu-item:nth-child(6) { bottom: -40px; left: 50px; transition-delay: 0.35s; }

        /* === 目录菜单样式 === */
        #floating-menu {
            position: fixed;
            bottom: 30px;
            right: 30px;
            z-index: 1000;
        }

        .menu-toggle {
            background: rgba(59, 130, 246, 0.9);
            color: white;
            border: none;
            border-radius: 50px;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .menu-toggle:hover {
            background: rgba(59, 130, 246, 1);
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(59, 130, 246, 0.4);
        }

        .menu-content {
            position: absolute;
            bottom: 60px;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            min-width: 280px;
            max-height: 70vh;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px) scale(0.95);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .menu-content.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            text-decoration: none;
            color: #374151;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .menu-item:hover {
            background: rgba(59, 130, 246, 0.08);
            color: #1e40af;
        }

        .menu-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 6px;
            margin-right: 12px;
            font-size: 12px;
            font-weight: 600;
            color: #3b82f6;
        }

        .menu-text {
            font-size: 14px;
            font-weight: 500;
            flex: 1;
        }

        /* 滚动条样式 */
        .menu-content::-webkit-scrollbar {
            width: 4px;
        }

        .menu-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .menu-content::-webkit-scrollbar-thumb {
            background: rgba(59, 130, 246, 0.3);
            border-radius: 2px;
        }

        .menu-content::-webkit-scrollbar-thumb:hover {
            background: rgba(59, 130, 246, 0.5);
        }

        /* 章节分组样式 */
        .menu-section {
            margin-bottom: 8px;
        }

        .section-header {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            background: rgba(59, 130, 246, 0.05);
            border-left: 3px solid #3b82f6;
            margin-bottom: 4px;
        }

        .menu-section .menu-item {
            padding-left: 24px;
            font-size: 13px;
        }

        .menu-section .menu-item .menu-icon {
            width: 32px;
            font-size: 11px;
            background: rgba(107, 114, 128, 0.1);
            color: #6b7280;
        }

        .menu-section .menu-item:hover .menu-icon {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        /* === 二级菜单样式 === */
        .lab-submenu {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90vw;
            max-width: 900px;
            max-height: 80vh;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            overflow: hidden;
        }

        .submenu-content {
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
        }

        .submenu-title {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 20px 30px;
            font-size: 20px;
            font-weight: 600;
            text-align: center;
            margin: 0;
        }

        .submenu-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            padding: 30px;
            max-height: calc(80vh - 140px);
            overflow-y: auto;
        }

        .submenu-item {
            background: rgba(59, 130, 246, 0.05);
            border: 2px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .submenu-item:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.4);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.2);
        }
        /* 分组标题样式与叶子项样式 */
        .submenu-group {
            cursor: default;
            background: rgba(15, 23, 42, 0.06);
            border-color: rgba(15, 23, 42, 0.12);
        }
        .submenu-group .submenu-icon { color: #334155; }
        .submenu-leaf .submenu-icon {
            width: 36px;
            height: 36px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(59, 130, 246, 0.12);
            color: #1d4ed8;
            border-radius: 10px;
        }
        .submenu-leaf:hover .submenu-icon { background: rgba(59, 130, 246, 0.2); }

        .submenu-icon {
            font-size: 20px;
            min-width: 24px;
        }

        .submenu-text {
            font-size: 14px;
            font-weight: 500;
            color: #374151;
        }

        .submenu-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .submenu-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        /* 响应式设计 */
        @media (max-width: 768px) {
            .floating-control-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
                bottom: 20px;
                left: 20px;
            }

            .floating-menu-items {
                bottom: 20px;
                left: 20px;
            }

            .floating-menu-item {
                padding: 10px 12px;
                min-width: 100px;
            }

            .floating-menu-item .item-text {
                font-size: 12px;
            }

            .submenu-grid {
                grid-template-columns: 1fr;
                padding: 20px;
            }

            .submenu-title {
                padding: 15px 20px;
                font-size: 18px;
            }
        }

    </style>
<style>
        .return-home-panel {
            position: fixed;
            top: 16px;
            left: 16px;
            display: flex;
            gap: 10px;
            z-index: 9999;
            flex-wrap: wrap;
        }
        .return-home-panel .return-link {
            padding: 8px 14px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.8);
            color: #f8fafc;
            font-size: 14px;
            text-decoration: none;
            box-shadow: 0 6px 20px rgba(15, 23, 42, 0.25);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .return-home-panel .return-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(15, 23, 42, 0.35);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.85);
        }
        @media (max-width: 640px) {
            .return-home-panel {
                top: 12px;
                left: 12px;
                right: 12px;
                justify-content: center;
            }
            .return-home-panel .return-link {
                width: 100%;
                text-align: center;
            }
        }
    </style>
    <style>
        /* 返回按钮样式（统一为第1/2章风格） */
        .return-home-panel {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 9999;
            display: flex;
            gap: 10px;
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }
        .return-home-panel:hover { opacity: 1; }
        .return-home-panel .return-link {
            padding: 6px 12px;
            background: rgba(15, 23, 42, 0.7);
            color: #f8fafc;
            text-decoration: none;
            border-radius: 999px;
            font-size: 12px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 4px 12px rgba(15, 23, 42, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .return-home-panel .return-link:hover {
            background: rgba(15, 23, 42, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(15, 23, 42, 0.3);
        }
        .return-home-panel .return-link.return-main {
            background: rgba(79, 70, 229, 0.7);
        }
        .return-home-panel .return-link.return-main:hover {
            background: rgba(79, 70, 229, 0.9);
            box-shadow: 0 8px 16px rgba(79, 70, 229, 0.3);
        }
        
        /* 统一封面样式（与第1/2章一致） */
        .slide-container.cover {
            align-items: stretch;
        }
        .cover-left {
            padding: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .cover-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(90deg, #4a90e2, #9b59b6);
            color: #fff;
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 14px;
            width: fit-content;
            box-shadow: 0 6px 16px rgba(74,144,226,0.35);
        }
        .cover-title {
            font-size: 4rem;
            line-height: 1.1;
            margin: 18px 0 8px 0;
            color: #1a1a2e;
            background: linear-gradient(90deg, #1a1a2e 0%, #4a90e2 60%, #9b59b6 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% 100%;
            animation: titleGradientMove 12s ease-in-out infinite;
        }
        .cover-subtitle {
            font-size: 1.6rem;
            color: #4f5b6a;
            margin: 10px 0 18px 0;
        }
        .cover-meta {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            color: #6b7b8c;
            font-size: 0.95rem;
        }
        .cover-meta span { display: inline-flex; align-items: center; gap: 6px; }
        .cover-actions {
            display: flex;
            gap: 14px;
            margin-top: 26px;
            flex-wrap: wrap;
        }
        .cover-right {
            position: relative;
            overflow: hidden;
        }
        .cover-visual {
            position: relative;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(1200px 800px at 80% 20%, rgba(155, 89, 182, 0.18), transparent 60%),
                radial-gradient(900px 700px at 20% 80%, rgba(74, 144, 226, 0.18), transparent 60%),
                linear-gradient(135deg, #ffffff 0%, #f7faff 50%, #f9f6ff 100%);
        }
        .cover-visual::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(600px 300px at 50% -10%, rgba(255,255,255,0.7), transparent 70%);
            pointer-events: none;
        }
        .cover-visual::before {
            content: "";
            position: absolute;
            inset: -15%;
            background: conic-gradient(from 0deg, rgba(74,144,226,0.18), rgba(155,89,182,0.18), rgba(99,102,241,0.18), rgba(74,144,226,0.18));
            filter: blur(80px);
            opacity: 0.18;
            animation: rotateAurora 30s linear infinite;
            pointer-events: none;
        }
        /* 章节页标题基础样式（无容器框） */
        .chapter-title {
            margin: 28px 0 12px;
            font-weight: 800;
            letter-spacing: 0.5px;
            text-align: center;
        }
        .chapter-subtitle {
            font-size: 1.1rem;
            color: #6b7280;
            text-align: center;
            margin: 0;
        }
        .chapter-divider {
            width: 64px;
            height: 4px;
            border-radius: 999px;
            margin: 24px auto 0;
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            opacity: 0.9;
        }
        /* 过渡页右侧装饰可视化（无交互，仅防空白） */
        .chapter-art {
            position: relative;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(900px 600px at 80% 20%, rgba(99,102,241,0.10), transparent 60%),
                radial-gradient(700px 500px at 20% 80%, rgba(59,130,246,0.10), transparent 60%),
                linear-gradient(135deg, #ffffff 0%, #f8fbff 50%, #faf7ff 100%);
        }
        @media (max-width: 768px) { .chapter-title { font-size: 2.4rem !important; } }
        .math-badge {
            position: absolute;
            padding: 8px 12px;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(0,0,0,0.06);
            border-radius: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
            color: #34495e;
            font-weight: 600;
            animation: floatY 6s ease-in-out infinite;
            backdrop-filter: blur(4px);
        }
        .math-badge.b1 { left: 12%; top: 22%; animation-delay: 0s; }
        .math-badge.b2 { right: 14%; top: 30%; animation-delay: 0.8s; }
        .math-badge.b3 { left: 20%; bottom: 18%; animation-delay: 1.5s; }
        .math-badge.b4 { right: 18%; bottom: 22%; animation-delay: 2.2s; }
        @keyframes floatY {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-12px); }
            100% { transform: translateY(0px); }
        }
        @keyframes rotateAurora { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes titleGradientMove {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .orbit {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 320px;
            height: 320px;
            margin-left: -160px;
            margin-top: -160px;
            border-radius: 50%;
            border: 1px dashed rgba(52, 152, 219, 0.35);
            animation: spin 18s linear infinite;
        }
        .orbit .dot {
            position: absolute;
            top: -6px;
            left: 50%;
            width: 12px;
            height: 12px;
            margin-left: -6px;
            background: #4a90e2;
            border-radius: 50%;
            box-shadow: 0 0 0 6px rgba(74,144,226,0.15);
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
    <style>
        /* 悬浮主按钮与二级按钮（统一样式） */
        .floating-control-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 56px;
            height: 56px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 50%;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            cursor: pointer;
            z-index: 1100;
            transition: all 0.25s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
        }
        .floating-control-btn:hover { transform: translateY(-2px); box-shadow: 0 12px 28px rgba(0,0,0,0.18); background: #111827; }
        .floating-control-btn .btn-icon { color: #111827; font-size: 20px; transition: transform 0.3s ease, color 0.3s ease; }
        .floating-control-btn:hover .btn-icon { color: #ffffff; }
        .floating-control-btn.active .btn-icon { transform: rotate(45deg); }

        .floating-menu-items { position: fixed; bottom: 20px; left: 20px; z-index: 1099; pointer-events: none; opacity: 0; transition: all 0.25s ease; }
        .floating-menu-items.active { opacity: 1; pointer-events: auto; }
        .floating-menu-item { position: absolute; width: 48px; height: 48px; background: rgba(255,255,255,0.9); border: 1px solid rgba(0,0,0,0.08); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.25s ease; box-shadow: 0 8px 20px rgba(0,0,0,0.12); transform: scale(0); backdrop-filter: blur(8px); color: #111827; }
        .floating-menu-items.active .floating-menu-item { transform: scale(1); }
        .floating-menu-item:hover { background: #111827; color: #ffffff; transform: scale(1.06); }
        .floating-menu-item .item-icon { font-size: 16px; }
        .floating-menu-item .item-text { position: absolute; top: -32px; left: 0; transform: translateX(-10%); background: rgba(0,0,0,0.85); color: #fff; padding: 6px 10px; border-radius: 12px; font-size: 12px; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.2s ease; }
        .floating-menu-item:hover .item-text { opacity: 1; }
        .floating-menu-item:nth-child(1) { bottom: 28px; left: 88px; transition-delay: 0.08s; }
        .floating-menu-item:nth-child(2) { bottom: 28px; left: 148px; transition-delay: 0.12s; }
    </style>
</head>
<body>
    <style>
        /* 隐藏旧的自定义悬浮目录（统一使用全局样式与面板） */
        .floating-menu, #menuContent { display: none !important; }
    </style>
    <div class="return-home-panel">
        <a class="return-link" href="../index.html"><i class="fa-solid fa-house"></i> 返回主站</a>
        <a class="return-link return-main" href="javascript:void(0)" onclick="event.stopPropagation(); toggleCourseSubmenu()"><i class="fa-solid fa-arrow-left"></i> 返回目录</a>
    </div>
<!-- 加载指示器 -->
<!-- 用户需求：优化加载体验，显示加载进度 -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">正在加载课件...</div>
</div>

<div id="slidesContainer">
<!-- 第1页：标题页 -->
<div class="slide active"><div class="slide-container cover"><div class="left-content tex2jax_process cover-left">
<div class="cover-badge"><i class="fa-solid fa-seedling"></i><span> 第三章</span></div>
<h1 class="cover-title">导数与微分</h1>
<p class="cover-subtitle">从变化率到瞬时变化</p>
<div class="cover-meta">
<span><i class="fa-solid fa-book-open"></i> 基础篇</span>
<span><i class="fa-solid fa-bolt"></i> 关键概念速览</span>
</div>
<div class="cover-actions">
<a class="home-link-btn" href="../index.html"><span>主页</span></a>
<a class="home-link-btn" href="../故事书/第三章/双子星的诞生.html"><span>故事书</span></a>
<a class="home-link-btn" href="../习题/assets/derivative.html"><span>习题</span></a>
<!-- 产教结合页面链接（部署时需要修改为实际部署AI功能的域名） -->
<a class="home-link-btn" href="https://ai.projectmath.xyz/产教结合/index.html"><span>资源</span></a>
</div>
</div><div class="right-visual cover-right"><div class="cover-visual">
<div class="math-badge b1">f'(x)</div>
<div class="math-badge b2">dy/dx</div>
<div class="math-badge b3">∂</div>
<div class="math-badge b4">d²y/dx²</div>
<div class="orbit"><span class="dot"></span></div>
<div id="vis-cover"></div>
</div></div></div></div>
<!-- 第2页：第一节过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h1 class="chapter-title" style="font-size: 3.5rem; color: #3b82f6; text-align: center; margin-bottom: 20px;">第一节</h1>
<h2 class="chapter-subtitle" style="font-size: 1.4rem; text-align: center; margin-bottom: 10px;">导数的概念</h2>
<div class="chapter-divider"></div>
<div style="text-align: center; margin-top: 40px;">
    <p style="font-size: 1.4rem; color: var(--muted-color); line-height: 2;">
        • 从平均变化率到瞬时变化率<br/>
        • 导数的定义与几何意义<br/>
        • 切线与法线方程<br/>
        • 导数的物理意义
    </p>
</div>
<div class="math-formula" style="margin-top: 36px; font-size: 1.1rem;">
    $f'(x) = \lim\limits_{\Delta x \to 0} \frac{f(x + \Delta x) - f(x)}{\Delta x}$
</div>
 </div><div class="right-visual"><div id="vis-trans-1" class="chapter-art"></div></div></div></div>

<!-- 第3页：引入 - 速度与变化率 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>生活中的变化率</h2>
<h3>思考一个问题</h3>
<p>汽车行驶100公里用了2小时，<br/>平均速度是 <span class="highlight">50 km/h</span></p>
<p>但是...</p>
<ul>
<li>汽车真的一直以50 km/h行驶吗？</li>
<li>某一时刻的速度是多少？</li>
<li>如何描述"瞬间"的变化？</li>
</ul>
<div class="math-formula">
                变化率 = $\frac{\text{变化量}}{\text{时间}}$
            </div>
</div><div class="right-visual"><div id="vis-intro"></div></div></div></div>
<!-- 第3页：平均变化率 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>平均变化率</h2>
<p>函数 $y = f(x)$ 在区间 $[x_1, x_2]$ 上的平均变化率：</p>
<div class="math-formula">
                平均变化率 = $\frac{f(x_2) - f(x_1)}{x_2 - x_1}$
            </div>
<h3>几何意义</h3>
<p>平均变化率就是<span class="highlight">割线的斜率</span></p>
<p>• 连接两点的直线叫割线<br/>
            • 割线斜率反映了函数的平均变化快慢</p>
</div><div class="right-visual"><div id="vis-average-rate"></div></div></div></div>
<!-- 第4页：从平均到瞬时 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>逼近瞬时变化率</h2>
<p>当 $\Delta x$ 越来越小时会发生什么？</p>
<ul>
<li>两点越来越近</li>
<li>割线逐渐逼近切线</li>
<li>平均变化率逼近瞬时变化率</li>
</ul>
<div class="math-formula">
                瞬时变化率 = $\lim\limits_{\Delta x \to 0} \frac{f(x + \Delta x) - f(x)}{\Delta x}$
            </div>
<p>这就是<span class="highlight">导数</span>的概念！</p>
</div><div class="right-visual"><div id="vis-limit-approach"></div></div></div></div>
<!-- 第5页：导数的定义 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>导数</h2>
<h3>定义</h3>
<p>函数 $y = f(x)$ 在点 $x$ 处的导数记作：</p>
<div class="math-formula">
                $f'(x)$ 或 $\frac{dy}{dx}$
            </div>
<h3>几何意义</h3>
<p>导数就是函数图像在该点的<span class="highlight">切线斜率</span></p>
<h3>物理意义</h3>
<p>位移对时间的导数就是<span class="highlight">瞬时速度</span></p>
</div><div class="right-visual"><div id="vis-derivative-def"></div></div></div></div>
<!-- 第6页：切线的动态演示 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>切线演示</h2>
<p>观察函数 $f(x) = x^2$ 的切线</p>
<ul>
<li>在不同点处，切线斜率不同</li>
<li>切线斜率就是该点的导数值</li>
<li>导数描述了函数的变化趋势</li>
</ul>
<div class="math-formula">
                $f(x) = x^2$<br/>
                $f'(x) = 2x$
            </div>
<p>例如：在 $x = 1$ 处，$f'(1) = 2$</p>
</div><div class="right-visual"><div id="vis-tangent-demo"></div></div></div></div>
<!-- 第7页：切线和法线方程 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>切线和法线方程</h2>
<h3>切线方程</h3>
<p>曲线 $y = f(x)$ 在点 $(x_0, y_0)$ 处的切线方程：</p>
<div class="math-formula">
$y - y_0 = f'(x_0)(x - x_0)$
</div>
<h3>法线方程</h3>
<p>法线是过切点且垂直于切线的直线：</p>
<div class="math-formula">
$y - y_0 = -\frac{1}{f'(x_0)}(x - x_0)$
</div>
<p><span class="highlight">注意：</span>切线斜率 × 法线斜率 = -1</p>
</div><div class="right-visual"><div id="vis-tangent-normal"></div></div></div></div>
<!-- 第8页：切线法线例题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>例题：求切线和法线方程</h2>
<h3>题目</h3>
<p>求曲线 $y = x^2$ 在点 $(1, 1)$ 处的切线和法线方程</p>
<h3>解</h3>
<p><strong>步骤1：</strong>求导数</p>
<p>$y' = 2x$</p>
<p><strong>步骤2：</strong>求切点处的斜率</p>
<p>$k_{切} = y'|_{x=1} = 2 \times 1 = 2$</p>
<p><strong>步骤3：</strong>写切线方程</p>
<p>$y - 1 = 2(x - 1)$，即 $y = 2x - 1$</p>
<p><strong>步骤4：</strong>写法线方程</p>
<p>$k_{法} = -\frac{1}{2}$，$y - 1 = -\frac{1}{2}(x - 1)$</p>
<p>即 $y = -\frac{1}{2}x + \frac{3}{2}$</p>
</div><div class="right-visual"><div id="vis-tangent-normal-example"></div></div></div></div>
<!-- 第9页：导数的物理意义 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>导数的物理意义</h2>
<h3>位移与速度</h3>
<p>设物体的位移为 $s(t)$</p>
<p>则瞬时速度：$v(t) = s'(t)$</p>
<h3>速度与加速度</h3>
<p>瞬时加速度：$a(t) = v'(t) = s''(t)$</p>
<div class="math-formula">
                位移 $\xrightarrow{\text{求导}}$ 速度 $\xrightarrow{\text{求导}}$ 加速度
            </div>
</div><div class="right-visual"><div id="vis-physics"></div></div></div></div>
<!-- 第10页：第二节过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h1 class="chapter-title" style="font-size: 3.5rem; color: #10b981; text-align: center; margin-bottom: 20px;">第二节</h1>
<h2 class="chapter-subtitle" style="font-size: 1.4rem; text-align: center; margin-bottom: 10px;">基本导数公式</h2>
<div class="chapter-divider"></div>
<div style="text-align: center; margin-top: 40px;">
    <p style="font-size: 1.4rem; color: var(--muted-color); line-height: 2;">
        • 常数函数的导数<br/>
        • 幂函数的导数<br/>
        • 指数函数的导数<br/>
        • 对数函数的导数<br/>
        • 三角函数的导数
    </p>
</div>
<div class="math-formula" style="margin-top: 36px; font-size: 1.1rem;">
    $(x^n)' = nx^{n-1}$ &nbsp;&nbsp; $(e^x)' = e^x$ &nbsp;&nbsp; $(\ln x)' = \frac{1}{x}$
</div>
 </div><div class="right-visual"><div id="vis-trans-2" class="chapter-art"></div></div></div></div>

<!-- 第11页：常数函数的导数 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>基本导数公式</h2>
<h3>常数函数</h3>
<p>若 $f(x) = C$（C是常数）</p>
<div class="math-formula">
                $f'(x) = 0$
            </div>
<p><span class="highlight">理解：</span>常数函数的图像是水平线，斜率为0</p>
<p>例如：</p>
<ul>
<li>$f(x) = 5$，则 $f'(x) = 0$</li>
<li>$f(x) = -3$，则 $f'(x) = 0$</li>
</ul>
</div><div class="right-visual"><div id="vis-constant"></div></div></div></div>
<!-- 第11页：幂函数的导数 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>幂函数的导数</h2>
<p>若 $f(x) = x^n$（n是常数）</p>
<div class="math-formula">
                $f'(x) = n \cdot x^{n-1}$
            </div>
<h3>例子</h3>
<ul>
<li>$f(x) = x^2$，则 $f'(x) = 2x$</li>
<li>$f(x) = x^3$，则 $f'(x) = 3x^2$</li>
<li>$f(x) = x^{-1}$，则 $f'(x) = -x^{-2}$</li>
<li>$f(x) = \sqrt{x} = x^{1/2}$，则 $f'(x) = \frac{1}{2}x^{-1/2}$</li>
</ul>
</div><div class="right-visual"><div id="vis-power"></div></div></div></div>
<!-- 第12页：指数函数的导数 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>指数函数的导数</h2>
<h3>自然指数函数</h3>
<p>若 $f(x) = e^x$</p>
<div class="math-formula">
                $f'(x) = e^x$
            </div>
<p><span class="highlight">特殊性质：</span>导数等于函数本身！</p>
<h3>一般指数函数</h3>
<p>若 $f(x) = a^x$（$a &gt; 0, a \neq 1$）</p>
<div class="math-formula">
                $f'(x) = a^x \cdot \ln a$
            </div>
</div><div class="right-visual"><div id="vis-exponential"></div></div></div></div>
<!-- 第13页：对数函数的导数 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>对数函数的导数</h2>
<h3>自然对数函数</h3>
<p>若 $f(x) = \ln x$（$x &gt; 0$）</p>
<div class="math-formula">
                $f'(x) = \frac{1}{x}$
            </div>
<h3>一般对数函数</h3>
<p>若 $f(x) = \log_a x$（$a &gt; 0, a \neq 1, x &gt; 0$）</p>
<div class="math-formula">
                $f'(x) = \frac{1}{x \ln a}$
            </div>
</div><div class="right-visual"><div id="vis-logarithm"></div></div></div></div>
<!-- 第14页：三角函数的导数 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>三角函数的导数</h2>
<h3>正弦和余弦</h3>
<div class="math-formula">
                $(\sin x)' = \cos x$<br/>
                $(\cos x)' = -\sin x$
            </div>
<h3>正切</h3>
<div class="math-formula">
                $(\tan x)' = \sec^2 x = \frac{1}{\cos^2 x}$
            </div>
<p><span class="highlight">记忆技巧：</span><br/>
            正弦求导变余弦<br/>
            余弦求导变负正弦</p>
</div><div class="right-visual"><div id="vis-trigonometric"></div></div></div></div>
<!-- 第15页：第三节过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h1 class="chapter-title" style="font-size: 3.5rem; color: #f59e0b; text-align: center; margin-bottom: 20px;">第三节</h1>
<h2 class="chapter-subtitle" style="font-size: 1.4rem; text-align: center; margin-bottom: 10px;">导数运算法则</h2>
<div class="chapter-divider"></div>
<div style="text-align: center; margin-top: 40px;">
    <p style="font-size: 1.4rem; color: var(--muted-color); line-height: 2;">
        • 加法法则<br/>
        • 乘法法则<br/>
        • 除法法则<br/>
        • 链式法则（复合函数求导）
    </p>
</div>
<div class="math-formula" style="margin-top: 36px; font-size: 1.1rem;">
    $[f(x) \pm g(x)]' = f'(x) \pm g'(x)$<br/>
    $[f(x) \cdot g(x)]' = f'(x)g(x) + f(x)g'(x)$
</div>
 </div><div class="right-visual"><div id="vis-trans-3" class="chapter-art"></div></div></div></div>

<!-- 第16页：导数的加法法则 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>导数运算法则</h2>
<h3>加法法则</h3>
<p>两个函数和的导数等于导数的和</p>
<div class="math-formula">
                $[f(x) + g(x)]' = f'(x) + g'(x)$
            </div>
<h3>例子</h3>
<p>求 $y = x^2 + 3x$ 的导数</p>
<p>解：$y' = (x^2)' + (3x)'$</p>
<p>　　$= 2x + 3$</p>
</div><div class="right-visual"><div id="vis-addition-rule"></div></div></div></div>
<!-- 第16页：导数的乘法法则 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>乘法法则</h2>
<p>两个函数乘积的导数：</p>
<div class="math-formula">
                $[f(x) \cdot g(x)]' = f'(x)g(x) + f(x)g'(x)$
            </div>
<p><span class="highlight">记忆口诀：</span>前导后不导 + 前不导后导</p>
<h3>例子</h3>
<p>求 $y = x^2 \cdot e^x$ 的导数</p>
<p>解：$y' = (x^2)' \cdot e^x + x^2 \cdot (e^x)'$</p>
<p>　　$= 2x \cdot e^x + x^2 \cdot e^x$</p>
<p>　　$= e^x(2x + x^2)$</p>
</div><div class="right-visual"><div id="vis-product-rule"></div></div></div></div>
<!-- 第17页：导数的除法法则 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>除法法则</h2>
<p>两个函数商的导数：</p>
<div class="math-formula">
                $\left[\frac{f(x)}{g(x)}\right]' = \frac{f'(x)g(x) - f(x)g'(x)}{[g(x)]^2}$
            </div>
<p><span class="highlight">记忆口诀：</span>上导下不导 减 上不导下导，除以下的平方</p>
<h3>例子</h3>
<p>求 $y = \frac{x^2}{x+1}$ 的导数</p>
<p>解：$y' = \frac{2x(x+1) - x^2 \cdot 1}{(x+1)^2}$</p>
</div><div class="right-visual"><div id="vis-quotient-rule"></div></div></div></div>
<!-- 第18页：复合函数求导（链式法则） -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>链式法则</h2>
<p>复合函数 $y = f(g(x))$ 的导数：</p>
<div class="math-formula">
                $y' = f'(g(x)) \cdot g'(x)$
            </div>
<p><span class="highlight">步骤：</span></p>
<ol>
<li>先对外层函数求导</li>
<li>再乘以内层函数的导数</li>
</ol>
<h3>例子</h3>
<p>求 $y = (2x + 1)^3$ 的导数</p>
<p>解：$y' = 3(2x + 1)^2 \cdot 2 = 6(2x + 1)^2$</p>
</div><div class="right-visual"><div id="vis-chain-rule"></div></div></div></div>
<!-- 第19页：第四节过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h1 class="chapter-title" style="font-size: 3.5rem; color: #8b5cf6; text-align: center; margin-bottom: 20px;">第四节</h1>
<h2 class="chapter-subtitle" style="font-size: 1.4rem; text-align: center; margin-bottom: 10px;">特殊函数求导</h2>
<div class="chapter-divider"></div>
<div style="text-align: center; margin-top: 40px;">
    <p style="font-size: 1.4rem; color: var(--muted-color); line-height: 2;">
        • 反三角函数的导数<br/>
        • 隐函数求导<br/>
        • 参数方程求导<br/>
        • 对数求导法<br/>
        • 高阶导数
    </p>
</div>
<div class="math-formula" style="margin-top: 36px; font-size: 1.1rem;">
    $(\arcsin x)' = \frac{1}{\sqrt{1-x^2}}$ &nbsp;&nbsp; $\frac{dy}{dx} = \frac{dy/dt}{dx/dt}$
</div>
 </div><div class="right-visual"><div id="vis-trans-4" class="chapter-art"></div></div></div></div>

<!-- 第20页：反三角函数的导数 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>反三角函数的导数</h2>
<h3>反正弦和反余弦</h3>
<div class="math-formula">
$(\arcsin x)' = \frac{1}{\sqrt{1-x^2}}$ &nbsp;&nbsp; $(-1 < x < 1)$<br/>
$(\arccos x)' = -\frac{1}{\sqrt{1-x^2}}$ &nbsp;&nbsp; $(-1 < x < 1)$
</div>
<h3>反正切和反余切</h3>
<div class="math-formula">
$(\arctan x)' = \frac{1}{1+x^2}$<br/>
$(\text{arccot}\, x)' = -\frac{1}{1+x^2}$
</div>
<p><span class="highlight">记忆技巧：</span>arcsin和arctan的导数为正，arccos和arccot的导数为负</p>
<h3>例子</h3>
<p>求 $y = \arctan(2x)$ 的导数</p>
<p>解：$y' = \frac{1}{1+(2x)^2} \cdot 2 = \frac{2}{1+4x^2}$</p>
</div><div class="right-visual"><div id="vis-inverse-trig"></div></div></div></div>

<!-- 第20页：隐函数求导 - 概念 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>隐函数的导数</h2>
<h3>显函数与隐函数</h3>
<p><strong>显函数：</strong>由 $y = f(x)$ 形式给出，如 $y = x^2 + 3x$、$y = e^x \sin x$ 等</p>
<p><strong>隐函数：</strong>由方程 $F(x, y) = 0$ 确定的函数，如 $x^2 + y^2 = r^2$</p>
<h3>隐函数求导方法</h3>
<p><span class="highlight">步骤：</span></p>
<ol>
<li>将方程两边同时对 $x$ 求导</li>
<li>注意 $y$ 是 $x$ 的函数，$y$ 的函数是复合函数</li>
<li>利用导数公式和链式法则求导</li>
<li>解出 $y'$</li>
</ol>
</div><div class="right-visual"><div id="vis-implicit-concept"></div></div></div></div>

<!-- 第21页：隐函数求导 - 例题1（圆的方程） -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>隐函数求导例题1</h2>
<h3>题目</h3>
<p>求由方程 $x^2 + y^2 = R^2$ 所确定的隐函数的导数 $y'$</p>
<h3>解</h3>
<p><strong>步骤1：</strong>方程两边对 $x$ 求导</p>
<p>$(x^2)' + (y^2)' = (R^2)'$</p>
<p><strong>步骤2：</strong>应用导数公式（注意 $y$ 是 $x$ 的函数）</p>
<p>$2x + 2y \cdot y' = 0$</p>
<p><strong>步骤3：</strong>解出 $y'$</p>
<div class="math-formula">
$y' = -\frac{x}{y}$
</div>
<p><span class="highlight">几何意义：</span>圆上任一点的切线斜率为 $-\frac{x}{y}$</p>
</div><div class="right-visual"><div id="vis-implicit-circle"></div></div></div></div>

<!-- 第22页：隐函数求导 - 例题2（椭圆切线） -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>隐函数求导例题2</h2>
<h3>题目</h3>
<p>求椭圆 $\frac{x^2}{9} + \frac{y^2}{4} = 1$ 在点 $\left(\frac{3}{2}, \sqrt{3}\right)$ 处的切线方程和法线方程</p>
<h3>解</h3>
<p><strong>步骤1：</strong>方程两边对 $x$ 求导</p>
<p>$\frac{2x}{9} + \frac{2y \cdot y'}{4} = 0$</p>
<p><strong>步骤2：</strong>解出 $y'$</p>
<p>$y' = -\frac{4x}{9y}$</p>
<p><strong>步骤3：</strong>代入点 $\left(\frac{3}{2}, \sqrt{3}\right)$</p>
<p>$k_{\text{切}} = -\frac{4 \cdot \frac{3}{2}}{9\sqrt{3}} = -\frac{1}{\sqrt{3}}$，$k_{\text{法}} = \sqrt{3}$</p>
<p><strong>切线方程：</strong>$y - \sqrt{3} = -\frac{1}{\sqrt{3}}\left(x - \frac{3}{2}\right)$</p>
<p><strong>法线方程：</strong>$y - \sqrt{3} = \sqrt{3}\left(x - \frac{3}{2}\right)$</p>
</div><div class="right-visual"><div id="vis-implicit-ellipse"></div></div></div></div>

<!-- 第23页：隐函数求导 - 例题3（指数方程） -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>隐函数求导例题3</h2>
<h3>题目</h3>
<p>求由方程 $e^x + e^y = e^{x+y}$ 所确定的函数 $y$ 在 $x=0$ 处的导数</p>
<h3>解</h3>
<p><strong>步骤1：</strong>方程两边对 $x$ 求导</p>
<p>$(e^x)' + (e^y)' = (e^{x+y})'$</p>
<p>$e^x + e^y \cdot y' = e^{x+y} \cdot (1 + y')$</p>
<p><strong>步骤2：</strong>整理并解出 $y'$</p>
<p>$e^x + e^y \cdot y' = e^{x+y} + e^{x+y} \cdot y'$</p>
<p>$y'(e^y - e^{x+y}) = e^{x+y} - e^x$</p>
<p>$y' = \frac{e^{x+y} - e^x}{e^y - e^{x+y}}$</p>
<p><strong>步骤3：</strong>代入 $x=0$，由原方程得 $e^0 + e^y = e^y$，即 $y=0$</p>
<div class="math-formula">
$y'|_{x=0} = \frac{e^{0+0} - e^0}{e^0 - e^{0+0}} = \frac{1-1}{1-1}$ （不定式）
</div>
<p>实际上，当 $x=0$ 时，$y=0$，因此 $y'|_{x=0} = 1$</p>
</div><div class="right-visual"><div id="vis-implicit-exp"></div></div></div></div>

<!-- 第24页：参数方程求导 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>参数方程确定的函数的导数</h2>
<h3>参数方程</h3>
<p>若函数 $y$ 与 $x$ 的关系由参数方程给出：</p>
<div class="math-formula">
$\begin{cases} x = \varphi(t) \\ y = \psi(t) \end{cases}$
</div>
<h3>求导公式</h3>
<p>根据复合函数求导法则和反函数求导公式：</p>
<div class="math-formula">
$\frac{dy}{dx} = \frac{\frac{dy}{dt}}{\frac{dx}{dt}} = \frac{\psi'(t)}{\varphi'(t)}$ &nbsp; $(\varphi'(t) \neq 0)$
</div>
<h3>例子</h3>
<p>求由参数方程 $\begin{cases} x = a\cos t \\ y = b\sin t \end{cases}$ 确定的函数的导数</p>
<p>解：$\frac{dy}{dx} = \frac{b\cos t}{-a\sin t} = -\frac{b}{a}\cot t$</p>
</div><div class="right-visual"><div id="vis-parametric"></div></div></div></div>

<!-- 第25页：参数方程求导 - 摆线例题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>参数方程求导：摆线</h2>
<h3>题目</h3>
<p>求摆线 $\begin{cases} x = a(t - \sin t) \\ y = a(1 - \cos t) \end{cases}$ 在 $t = \frac{\pi}{2}$ 时曲线上的点的切线方程</p>
<h3>解</h3>
<p><strong>步骤1：</strong>求导数</p>
<p>$\frac{dx}{dt} = a(1 - \cos t)$，$\frac{dy}{dt} = a\sin t$</p>
<p>$\frac{dy}{dx} = \frac{a\sin t}{a(1-\cos t)} = \frac{\sin t}{1-\cos t}$</p>
<p><strong>步骤2：</strong>求 $t = \frac{\pi}{2}$ 时的点和斜率</p>
<p>当 $t = \frac{\pi}{2}$ 时：</p>
<p>$x = a\left(\frac{\pi}{2} - 1\right)$，$y = a$</p>
<p>$y'|_{t=\frac{\pi}{2}} = \frac{\sin\frac{\pi}{2}}{1-\cos\frac{\pi}{2}} = \frac{1}{1-0} = 1$</p>
<p><strong>切线方程：</strong>$y - a = 1 \cdot \left[x - a\left(\frac{\pi}{2}-1\right)\right]$</p>
<p>即：$y = x + a\left(2 - \frac{\pi}{2}\right)$</p>
</div><div class="right-visual"><div id="vis-cycloid"></div></div></div></div>

<!-- 第26页：对数求导法 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>对数求导法</h2>
<h3>适用情况</h3>
<p>对数求导法特别适用于以下情况：</p>
<ul>
<li>幂指函数：$y = u(x)^{v(x)}$</li>
<li>多项相乘相除的复杂函数</li>
</ul>
<h3>方法步骤</h3>
<ol>
<li>等式两边同时取自然对数 $\ln y$</li>
<li>利用对数运算性质简化</li>
<li>两边同时对 $x$ 求导</li>
<li>解出 $y'$</li>
</ol>
<h3>例题1</h3>
<p>求 $y = x^x$ $(x > 0)$ 的导数</p>
<p><strong>解：</strong></p>
<p>$\ln y = \ln x^x = x \ln x$</p>
<p>$\frac{y'}{y} = \ln x + x \cdot \frac{1}{x} = \ln x + 1$</p>
<div class="math-formula">
$y' = y(\ln x + 1) = x^x(\ln x + 1)$
</div>
</div><div class="right-visual"><div id="vis-logarithmic-diff"></div></div></div></div>

<!-- 第27页：对数求导法例题2 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>对数求导法例题2</h2>
<h3>题目</h3>
<p>求函数 $y = \frac{(x+1)(x+2)}{(x+3)(x+4)}$ 的导数</p>
<h3>解</h3>
<p><strong>步骤1：</strong>两边取对数</p>
<p>$\ln y = \ln(x+1) + \ln(x+2) - \ln(x+3) - \ln(x+4)$</p>
<p><strong>步骤2：</strong>两边对 $x$ 求导</p>
<p>$\frac{y'}{y} = \frac{1}{x+1} + \frac{1}{x+2} - \frac{1}{x+3} - \frac{1}{x+4}$</p>
<p><strong>步骤3：</strong>解出 $y'$</p>
<div class="math-formula">
$y' = y\left(\frac{1}{x+1} + \frac{1}{x+2} - \frac{1}{x+3} - \frac{1}{x+4}\right)$
</div>
<div class="math-formula">
$= \frac{(x+1)(x+2)}{(x+3)(x+4)}\left(\frac{1}{x+1} + \frac{1}{x+2} - \frac{1}{x+3} - \frac{1}{x+4}\right)$
</div>
<p><span class="highlight">优势：</span>避免了繁琐的乘法和除法法则计算</p>
</div><div class="right-visual"><div id="vis-logarithmic-diff2"></div></div></div></div>

<!-- 第28页：高阶导数 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>高阶导数</h2>
<p>对导数再求导，得到二阶导数：</p>
<div class="math-formula">
                $f''(x) = [f'(x)]'$
            </div>
<h3>记号</h3>
<ul>
<li>一阶导数：$f'(x)$ 或 $\frac{dy}{dx}$</li>
<li>二阶导数：$f''(x)$ 或 $\frac{d^2y}{dx^2}$</li>
<li>三阶导数：$f'''(x)$ 或 $\frac{d^3y}{dx^3}$</li>
<li>n阶导数：$f^{(n)}(x)$ 或 $\frac{d^ny}{dx^n}$</li>
</ul>
<h3>常见函数的高阶导数</h3>
<p>$(e^x)^{(n)} = e^x$</p>
<p>$(x^n)^{(n)} = n!$</p>
<p>$(\sin x)^{(n)} = \sin\left(x + n\cdot\frac{\pi}{2}\right)$</p>
<h3>应用</h3>
<p>二阶导数可以判断函数的凹凸性；在物理中，二阶导数表示加速度</p>
</div><div class="right-visual"><div id="vis-higher-order"></div></div></div></div>
<!-- 第29页：第五节过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h1 class="chapter-title" style="font-size: 3.5rem; color: #ef4444; text-align: center; margin-bottom: 20px;">第五节</h1>
<h2 class="chapter-subtitle" style="font-size: 1.4rem; text-align: center; margin-bottom: 10px;">函数的微分及其应用</h2>
<div class="chapter-divider"></div>
<div style="text-align: center; margin-top: 40px;">
    <p style="font-size: 1.4rem; color: var(--muted-color); line-height: 2;">
        • 微分的概念与记号<br/>
        • 线性近似与误差估计<br/>
        • 微分在实际问题中的应用<br/>
        • 误差分析
    </p>
</div>
<div class="math-formula" style="margin-top: 36px; font-size: 1.1rem;">
    $dy = f'(x_0) \cdot dx$ &nbsp;&nbsp; $\Delta y \approx dy$
</div>
 </div><div class="right-visual"><div id="vis-trans-5" class="chapter-art"></div></div></div></div>

<!-- 第30页：微分的概念与记号 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>微分的概念</h2>
<h3>定义与记号</h3>
<p>设函数 $y=f(x)$ 在点 $x=x_0$ 处可导，记 $f'(x_0)=k$。给定自变量的增量 $dx$，定义函数的微分为：</p>
<div class="math-formula">
$dy = f'(x_0)\,dx$
</div>
<p>当 $dx\to 0$ 时，增量 $\Delta y = f(x_0+dx)-f(x_0)$ 有分解：</p>
<div class="math-formula">
$\Delta y = dy + o(dx)$
</div>
<p>因此，$dy$ 是 $\Delta y$ 关于 $dx$ 的一阶线性主部，表示在 $x_0$ 处的线性改变量。</p>
</div><div class="right-visual"><div id="vis-differential-concept"></div></div></div></div>

<!-- 第31页：微分的线性近似与误差 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>线性近似与误差估计</h2>
<p>当 $|dx|$ 足够小时，有一阶近似：</p>
<div class="math-formula">
$f(x_0+dx) \approx f(x_0) + f'(x_0)\,dx = L(x_0+dx)$
</div>
<p>误差为：</p>
<div class="math-formula">
$R_1 = \Delta y - dy = f(x_0+dx)-f(x_0)-f'(x_0)\,dx = o(dx)$
</div>
<p>工程上常用 $L(x)$ 代替 $f(x)$ 进行估算与误差控制。</p>
</div><div class="right-visual"><div id="vis-differential-approx"></div></div></div></div>

<!-- 第32页：微分误差估计应用 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>微分在误差估计中的应用</h2>
<h3>题目</h3>
<p>测得圆钢截面的直径 $D = 60.03$ mm，测量 $D$ 的绝对误差限 $|\Delta D| \leq 0.05$ mm。利用公式 $A = \frac{\pi D^2}{4}$ 计算圆钢的截面积时，试估计面积的误差。</p>
<h3>解</h3>
<p><strong>步骤1：</strong>利用微分估计绝对误差</p>
<p>$dA = A'(D) \cdot dD = \frac{\pi}{4} \cdot 2D \cdot dD = \frac{\pi D}{2} \cdot dD$</p>
<p><strong>步骤2：</strong>计算绝对误差限</p>
<div class="math-formula">
$|\Delta A| \approx |dA| = \frac{\pi D}{2}|\Delta D| = \frac{\pi \times 60.03}{2} \times 0.05 \approx 4.72 \text{ mm}^2$
</div>
<p><strong>步骤3：</strong>计算相对误差</p>
<div class="math-formula">
$\frac{|\Delta A|}{A} \approx \frac{2|\Delta D|}{D} = \frac{2 \times 0.05}{60.03} \approx 0.17\%$
</div>
<p><span class="highlight">结论：</span>面积的绝对误差约为 4.72 mm²，相对误差约为 0.17%</p>
</div><div class="right-visual"><div id="vis-error-estimation"></div></div></div></div>

<!-- 第33页：补充内容过渡页 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h1 class="chapter-title" style="font-size: 3.5rem; color: #6b7280; text-align: center; margin-bottom: 20px;">补充内容</h1>
<h2 class="chapter-subtitle" style="font-size: 1.4rem; text-align: center; margin-bottom: 10px;">微分中值定理</h2>
<div class="chapter-divider"></div>
<div style="text-align: center; margin-top: 40px;">
    <p style="font-size: 1.4rem; color: var(--muted-color); line-height: 2;">
        • 罗尔定理<br/>
        • 拉格朗日中值定理<br/>
        • 柯西中值定理<br/>
        • 中值定理的应用
    </p>
</div>
<div class="math-formula" style="margin-top: 36px; font-size: 1.1rem;">
    $f'(\xi) = \frac{f(b) - f(a)}{b - a}$ &nbsp;&nbsp; $(\xi \in (a,b))$
</div>
 </div><div class="right-visual"><div id="vis-trans-6" class="chapter-art"></div></div></div></div>

<!-- 第34页：罗尔定理 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>微分中值定理（一）：罗尔定理</h2>
<h3>定理内容</h3>
<p>若函数 $f(x)$ 满足：</p>
<ul>
<li>在 $[a, b]$ 上连续</li>
<li>在 $(a, b)$ 内可导</li>
<li>$f(a) = f(b)$</li>
</ul>
<p>则至少存在一点 $\xi \in (a, b)$，使得：</p>
<div class="math-formula">
$f'(\xi) = 0$
</div>
<p><span class="highlight">几何意义：</span>曲线上至少有一点的切线是水平的</p>
</div><div class="right-visual"><div id="vis-rolle"></div></div></div></div>
<!-- 第21页：拉格朗日中值定理 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>微分中值定理（二）：拉格朗日中值定理</h2>
<h3>定理内容</h3>
<p>若函数 $f(x)$ 满足：</p>
<ul>
<li>在 $[a, b]$ 上连续</li>
<li>在 $(a, b)$ 内可导</li>
</ul>
<p>则至少存在一点 $\xi \in (a, b)$，使得：</p>
<div class="math-formula">
$f'(\xi) = \frac{f(b) - f(a)}{b - a}$
</div>
<p><span class="highlight">几何意义：</span>曲线上至少有一点的切线平行于弦AB</p>
<p><span class="highlight">注意：</span>罗尔定理是拉格朗日中值定理的特殊情况</p>
</div><div class="right-visual"><div id="vis-lagrange"></div></div></div></div>
<!-- 第22页：拉格朗日中值定理例题 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>例题：拉格朗日中值定理应用</h2>
<h3>题目</h3>
<p>验证函数 $f(x) = x^2$ 在区间 $[1, 3]$ 上满足拉格朗日中值定理，并求出 $\xi$</p>
<h3>解</h3>
<p><strong>步骤1：</strong>验证条件</p>
<p>$f(x) = x^2$ 在 $[1, 3]$ 上连续，在 $(1, 3)$ 内可导 ✓</p>
<p><strong>步骤2：</strong>计算平均变化率</p>
<p>$\frac{f(3) - f(1)}{3 - 1} = \frac{9 - 1}{2} = 4$</p>
<p><strong>步骤3：</strong>求 $\xi$</p>
<p>$f'(x) = 2x$，令 $f'(\xi) = 4$</p>
<p>$2\xi = 4$，得 $\xi = 2 \in (1, 3)$ ✓</p>
</div><div class="right-visual"><div id="vis-lagrange-example"></div></div></div></div>
<!-- 第23页：柯西中值定理 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>微分中值定理（三）：柯西中值定理</h2>
<h3>定理内容</h3>
<p>若函数 $f(x)$ 和 $g(x)$ 满足：</p>
<ul>
<li>在 $[a, b]$ 上连续</li>
<li>在 $(a, b)$ 内可导</li>
<li>$g'(x) \neq 0$</li>
</ul>
<p>则至少存在一点 $\xi \in (a, b)$，使得：</p>
<div class="math-formula">
$\frac{f'(\xi)}{g'(\xi)} = \frac{f(b) - f(a)}{g(b) - g(a)}$
</div>
<p><span class="highlight">注意：</span>当 $g(x) = x$ 时，柯西中值定理退化为拉格朗日中值定理</p>
</div><div class="right-visual"><div id="vis-cauchy"></div></div></div></div>
<!-- 第34页：第六节过渡页 -->
<!-- 第41页：第七节过渡页 -->
<div class="slide"><div class="slide-container single-column"><div class="left-content tex2jax_process">
<h2 style="font-size: 2.8rem; text-align: center; margin-bottom: 40px;">知识体系与总结</h2>
<div style="text-align: center; margin-top: 60px;">
    <p style="font-size: 1.4rem; color: var(--muted-color); line-height: 2;">
        • 导数与微分知识体系<br/>
        • 重点公式汇总<br/>
        • 实验室链接<br/>
        • 练习与总结
    </p>
</div>
<div class="math-formula" style="margin-top: 50px; font-size: 1.1rem;">
    导数 $\rightarrow$ 微分 $\rightarrow$ 应用
</div>
</div></div></div>

<!-- 第39页：知识体系（导数与微分） -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>第三章 知识体系</h2>
<h3>结构总览</h3>
<ul>
<li>概念与几何意义：切线斜率、瞬时变化率</li>
<li>基本公式：$(C)' = 0$、$(x^n)' = nx^{n-1}$、$(e^x)' = e^x$、$(\ln x)' = \dfrac{1}{x}$ 等</li>
<li>运算法则：加法、乘法、商法则，链式法则</li>
<li>特殊函数求导：指数、对数、三角、反三角</li>
<li>微分：$dy = f'(x)\,dx$ 与线性近似、误差估计</li>
<li>典型模型：速度/加速度、切线/法线、极值与中值定理铺垫</li>
<li>与第二章衔接：极限与连续 → 导数与微分</li>
<li>与第四章衔接：导数应用（单调性、极值、洛必达）</li>
 </ul>
<h3>关联实验</h3>
<ul>
<li><a href="../网页资源/lab 3-1.html" target="_blank" rel="noopener">lab 3-1 导数概念实验室</a></li>
<li><a href="../网页资源/lab 3-2.html" target="_blank" rel="noopener">lab 3-2 导数几何意义实验室</a></li>
<li><a href="../网页资源/lab 3-3.html" target="_blank" rel="noopener">lab 3-3 导数运算法则实验室</a></li>
<li><a href="../网页资源/lab 3-4.html" target="_blank" rel="noopener">lab 3-4 复合函数求导实验室</a></li>
<li><a href="../网页资源/lab 3-5.html" target="_blank" rel="noopener">lab 3-5 微分实验室</a></li>
<li><a href="../网页资源/lab 3-6.html" target="_blank" rel="noopener">lab 3-6 求导练习游戏</a></li>
 </ul>
</div><div class="right-visual"><div id="vis-knowledge-map"></div></div></div></div>
<!-- 第40页：练习与总结 -->
<div class="slide"><div class="slide-container"><div class="left-content tex2jax_process">
<h2>练习与总结</h2>
<h3>常用公式汇总</h3>
<ul>
<li>$(C)' = 0$</li>
<li>$(x^n)' = nx^{n-1}$</li>
<li>$(e^x)' = e^x$</li>
<li>$(\ln x)' = \frac{1}{x}$</li>
<li>$(\sin x)' = \cos x$</li>
<li>$(\cos x)' = -\sin x$</li>
</ul>
<p><span class="highlight">记住：</span>导数是研究函数变化的工具！</p>
</div><div class="right-visual"><div id="vis-practice"></div></div></div></div>
<!-- 导航控制 -->
<!-- 用户需求：支持键盘、鼠标、触摸多种交互方式 -->
<div class="nav-controls" role="navigation" aria-label="幻灯片导航">
    <button class="nav-btn" onclick="previousSlide()" aria-label="上一页" title="上一页 (<i class="fa-solid fa-arrow-left"></i>)"><i class="fa-solid fa-arrow-left"></i> 上一页</button>
    <div class="slide-number" role="status" aria-live="polite">
        <input type="number" id="slideNumberInput" min="1" max="44" value="1"
               onchange="jumpToSlide(this.value)"
               aria-label="当前页码">/<span id="slideNumberTotal">44</span>
    </div>
    <button class="nav-btn" onclick="nextSlide()" aria-label="下一页" title="下一页 (→)">下一页 →</button>
</div>
<div class="global-animation-controls" id="globalAnimationControls">
<button class="global-control-btn" id="globalPlayPauseBtn">暂停</button>
<button class="global-control-btn" id="globalSpeedBtn">1.0x</button>
</div>

<!-- 悬浮控制按钮与二级菜单（与第1/2章一致） -->
<button class="floating-control-btn" id="floating-control-btn"><span class="btn-icon">+</span></button>
<div class="floating-menu-items" id="floating-menu-items">
    <div class="floating-menu-item" onclick="event.stopPropagation(); toggleLabSubmenu()">
        <span class="item-icon"><i class="fa-solid fa-flask"></i></span>
        <span class="item-text">实验室</span>
    </div>
    <div class="floating-menu-item" onclick="event.stopPropagation(); toggleChapterSubmenu()">
        <span class="item-icon"><i class="fa-solid fa-clipboard-list"></i></span>
        <span class="item-text">本章目录</span>
    </div>
    
</div>

<!-- 覆盖：将二级按钮横向排布为与第1/2章一致 -->
<style>
    .floating-menu-items {
        position: fixed;
        bottom: 30px;
        left: 30px;
        display: flex;
        align-items: center;
        gap: 10px;
        padding-left: 70px; /* 与主按钮错开 */
        z-index: 999;
        pointer-events: none;
    }
    .floating-menu-item {
        position: static !important; /* 覆盖弧形绝对定位 */
        min-width: 110px;
        padding: 10px 14px;
        opacity: 0;
        transform: scale(0.98);
        pointer-events: none;
    }
    .floating-menu-items.active .floating-menu-item {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
    }
    /* 取消弧形布局的定位 */
    .floating-menu-item:nth-child(n) { bottom: auto !important; left: auto !important; }
    .floating-menu-item:hover { transform: translateY(-2px); }
</style>

<!-- 实验室弹层（第三章） -->
<div class="lab-submenu" id="lab-submenu" style="display: none;">
    <div class="submenu-content">
        <div class="submenu-title">第三章实验室</div>
        <div class="submenu-grid">
            <div class="submenu-item" onclick="window.open('../网页资源/index.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-list"></i></span><span class="submenu-text">资源总览</span></div>
            <div class="submenu-item" onclick="window.open('../网页资源/lab 3-1.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">导数概念实验室</span></div>
            <div class="submenu-item" onclick="window.open('../网页资源/lab 3-2.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">导数几何意义实验室</span></div>
            <div class="submenu-item" onclick="window.open('../网页资源/lab 3-3.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">导数运算法则实验室</span></div>
            <div class="submenu-item" onclick="window.open('../网页资源/lab 3-4.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">复合函数求导实验室</span></div>
            <div class="submenu-item" onclick="window.open('../网页资源/lab 3-5.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">微分实验室</span></div>
            <div class="submenu-item" onclick="window.open('../网页资源/lab 3-6.html','_blank')"><span class="submenu-icon"><i class="fa-solid fa-vial"></i></span><span class="submenu-text">求导练习游戏</span></div>
        </div>
        <div class="submenu-close" onclick="toggleLabSubmenu()">×</div>
    </div>
    
</div>

<!-- 复用章节菜单（打开现有右侧目录） -->
<div class="lab-submenu" id="chapter-submenu" style="display:none;">
    <div class="submenu-content">
        <div class="submenu-title">第三章目录</div>
        <div class="submenu-grid" id="chapter-submenu-grid"></div>
        <div class="submenu-close" onclick="toggleChapterSubmenu()">×</div>
    </div>
</div>

<!-- 全部课件目录弹层 -->
<div class="lab-submenu" id="course-submenu" style="display: none;">
    <div class="submenu-content">
        <div class="submenu-title">全部课件目录</div>
        <div class="submenu-grid">
            <div class="submenu-item" onclick="window.location.href='第1章代数.html';"><span class="submenu-icon"><i class="fa-solid fa-1"></i></span><span class="submenu-text">第1章 代数</span></div>
            <div class="submenu-item" onclick="window.location.href='第2章极限与连续.html';"><span class="submenu-icon"><i class="fa-solid fa-2"></i></span><span class="submenu-text">第2章 极限与连续</span></div>
            <div class="submenu-item" onclick="window.location.href='第3章导数与微分.html';"><span class="submenu-icon"><i class="fa-solid fa-3"></i></span><span class="submenu-text">第3章 导数与微分</span></div>
            <div class="submenu-item" onclick="window.location.href='第4章导数应用.html';"><span class="submenu-icon"><i class="fa-solid fa-4"></i></span><span class="submenu-text">第4章 导数应用</span></div>
            <div class="submenu-item" onclick="window.location.href='第5章不定积分.html';"><span class="submenu-icon"><i class="fa-solid fa-5"></i></span><span class="submenu-text">第5章 不定积分</span></div>
            <div class="submenu-item" onclick="window.location.href='第6章定积分.html';"><span class="submenu-icon"><i class="fa-solid fa-6"></i></span><span class="submenu-text">第6章 定积分</span></div>
            <div class="submenu-item" onclick="window.location.href='第7章常微分方程.html';"><span class="submenu-icon"><i class="fa-solid fa-7"></i></span><span class="submenu-text">第7章 常微分方程</span></div>
            <div class="submenu-item" onclick="window.location.href='第8章多元函数微分学.html';"><span class="submenu-icon"><i class="fa-solid fa-8"></i></span><span class="submenu-text">第8章 多元函数微分学</span></div>
            <div class="submenu-item" onclick="window.location.href='第9章多元函数积分学初步.html';"><span class="submenu-icon"><i class="fa-solid fa-9"></i></span><span class="submenu-text">第9章 多元函数积分学初步</span></div>
            <div class="submenu-item" onclick="window.location.href='第10章线性代数.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第10章 线性代数</span></div>
            <div class="submenu-item" onclick="window.location.href='第11章无穷级数.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第11章 无穷级数</span></div>
            <div class="submenu-item" onclick="window.location.href='第12章向量代数与空间解析几何.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第12章 向量代数与空间解析几何</span></div>
            <div class="submenu-item" onclick="window.location.href='第13章概率与统计.html';"><span class="submenu-icon"><i class="fa-solid fa-x"></i></span><span class="submenu-text">第13章 概率与统计</span></div>
        </div>
        <div class="submenu-close" onclick="toggleCourseSubmenu()">×</div>
    </div>
</div>
</div>
<script>
    // 全局变量
    let slides, totalSlides, currentSlide = 0;
    let globalAnimationPlaying = true;
    let globalAnimationSpeed = 1.0;
    let activeAnimations = [];
    const trackedAnimationCallbacks = new Set();
    
    let mathjaxReady = false;
    
    // 页面统计功能
    let pageViewTimes = [];
    let pageStartTime = Date.now();

    function registerAnimation(callback, id) {
        if (!callback || typeof callback !== 'function') return;
        if (callback.__rafId != null) {
            const existingIndex = activeAnimations.indexOf(callback.__rafId);
            if (existingIndex !== -1) {
                activeAnimations.splice(existingIndex, 1);
            }
        }
        callback.__rafId = id;
        trackedAnimationCallbacks.add(callback);
        activeAnimations.push(id);
    }
    let activeTimeouts = [];
    let activeIntervals = [];

    // 初始化
    // 用户需求：优化加载体验，添加触摸手势支持
    document.addEventListener('DOMContentLoaded', function() {
        slides = document.querySelectorAll('.slide');
        totalSlides = slides.length;
        
        // 初始化页面查看时间数组
        pageViewTimes = new Array(totalSlides).fill(0);

        initGlobalAnimationControls();
        showSlide(0);

        // 键盘导航
        document.addEventListener('keydown', handleKeyNavigation);

        // 鼠标滚轮导航
        document.addEventListener('wheel', handleWheelNavigation, { passive: false });

        // 触摸手势导航
        initTouchGestures();

        // 窗口调整处理
        initResizeHandler();

        // 屏幕方向改变处理
        initOrientationHandler();

        // 初始化悬浮菜单
        initFloatingControl();
        ['lab-submenu','chapter-submenu','course-submenu'].forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            const content = el.querySelector('.submenu-content');
            if (content) content.addEventListener('click', ev => ev.stopPropagation());
        });
        // 生成第三章目录面板
        buildChapterMenuCh3();
        document.addEventListener('click', () => {
            closeAllSubmenus();
            const floatingBtn = document.getElementById('floating-control-btn');
            const floatingMenu = document.getElementById('floating-menu-items');
            if (floatingBtn && floatingMenu) {
                floatingBtn.classList.remove('active');
                floatingMenu.classList.remove('active');
            }
        });
        document.addEventListener('keydown', (ev) => {
            if (ev.key === 'Escape') {
                closeAllSubmenus();
                const floatingBtn = document.getElementById('floating-control-btn');
                const floatingMenu = document.getElementById('floating-menu-items');
                if (floatingBtn && floatingMenu) {
                    floatingBtn.classList.remove('active');
                    floatingMenu.classList.remove('active');
                }
            }
        });

    // 等待MathJax加载完成后渲染所有公式
    if (window.MathJax) {
        if (window.MathJax.startup && window.MathJax.startup.promise) {
            MathJax.startup.promise.then(() => {
                mathjaxReady = true;
                console.log('MathJax loaded and ready');
                // 等待MathJax完全加载后渲染所有公式
                setTimeout(() => {
                    MathJax.typesetPromise();
                    hideLoadingOverlay();
                }, 500);
            }).catch((err) => {
                console.error("MathJax failed to load", err);
                mathjaxReady = true; // allow execution to continue
                hideLoadingOverlay();
            });
        } else {
            // 新版本MathJax v3
            MathJax.typesetPromise().then(() => {
                mathjaxReady = true;
                console.log('MathJax v3 loaded and rendered');
                hideLoadingOverlay();
            }).catch((err) => {
                console.error("MathJax v3 failed to render", err);
                mathjaxReady = true;
                hideLoadingOverlay();
            });
        }
    } else {
        // MathJax未加载
        console.warn('MathJax未找到，可能正在加载中...');
        mathjaxReady = true;
        hideLoadingOverlay();
    }
    });

    // ========================================
    // 触摸手势支持
    // 用户需求：支持移动设备滑动切换幻灯片
    // ========================================
    function initTouchGestures() {
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        }, { passive: true });

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 50;

            // 只处理水平滑动
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                if (deltaX > 0) {
                    previousSlide(); // 右滑 - 上一页
                } else {
                    nextSlide(); // 左滑 - 下一页
                }
            }
        }
    }

    // ========================================
    // 窗口大小调整处理
    // 用户需求：窗口大小改变时重新绘制可视化
    // ========================================
    function initResizeHandler() {
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // 重新运行当前幻灯片的可视化
                runVisualization(currentSlide);
            }, 300);
        });
    }

    // ========================================
    // 屏幕方向改变处理
    // 用户需求：设备旋转时优化布局
    // ========================================
    function initOrientationHandler() {
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                runVisualization(currentSlide);
            }, 300);
        });
    }

    // ========================================
    // 防止双指缩放
    // 用户需求：在移动设备上保持固定缩放比例
    // ========================================
    document.addEventListener('gesturestart', (e) => {
        e.preventDefault();
    });

    document.addEventListener('gesturechange', (e) => {
        e.preventDefault();
    });

    document.addEventListener('gestureend', (e) => {
        e.preventDefault();
    });

    // ========================================
    // 隐藏加载指示器
    // 用户需求：平滑隐藏加载动画
    // ========================================
    function hideLoadingOverlay() {
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
            overlay.classList.add('hidden');
            // 完全移除元素以释放资源
            setTimeout(() => {
                overlay.remove();
            }, 500);
        }
    }

    // ========================================
    // 性能监控
    // ========================================
    if (window.performance && window.performance.timing) {
        window.addEventListener('load', () => {
            setTimeout(() => {
                const perfData = window.performance.timing;
                const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
                console.log(`<i class="fa-solid fa-chart-bar"></i> 页面加载时间: ${pageLoadTime}ms`);
            }, 0);
        });
    }

    // 全局动画控制
    function initGlobalAnimationControls() {
        const playPauseBtn = document.getElementById('globalPlayPauseBtn');
        const speedBtn = document.getElementById('globalSpeedBtn');
        const speedOptions = [0.5, 1, 1.5, 2, 3];
        let currentSpeedIndex = 1;

        playPauseBtn?.addEventListener('click', () => {
            globalAnimationPlaying = !globalAnimationPlaying;
            playPauseBtn.textContent = globalAnimationPlaying ? '暂停' : '播放';
            playPauseBtn.className = globalAnimationPlaying ? 'global-control-btn' : 'global-control-btn pause';
            updateAnimationStates();
        });

        speedBtn?.addEventListener('click', () => {
            currentSpeedIndex = (currentSpeedIndex + 1) % speedOptions.length;
            globalAnimationSpeed = speedOptions[currentSpeedIndex];
            speedBtn.textContent = globalAnimationSpeed.toFixed(1) + 'x';
            updateAnimationStates();
        });
    }

    function updateAnimationStates() {
        // 重新运行当前页面的动画
        runVisualization(currentSlide);
    }

    // 更新翻页按钮状态
    function updateNavButtons() {
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        if (prevBtn && nextBtn) {
            prevBtn.disabled = (currentSlide === 0);
            nextBtn.disabled = (currentSlide === totalSlides - 1);
        }
    }

    // 悬浮菜单互斥控制与切换
    function closeAllSubmenus(exceptId) {
        ['lab-submenu','chapter-submenu','course-submenu'].forEach(id => {
            if (id !== exceptId) {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            }
        });
    }
    function toggleLabSubmenu() {
        const el = document.getElementById('lab-submenu');
        if (!el) return;
        const willOpen = el.style.display !== 'block';
        closeAllSubmenus('lab-submenu');
        el.style.display = willOpen ? 'block' : 'none';
    }
    function toggleChapterSubmenu() {
        const el = document.getElementById('chapter-submenu');
        if (!el) return;
        const willOpen = el.style.display !== 'block';
        closeAllSubmenus('chapter-submenu');
        el.style.display = willOpen ? 'block' : 'none';
    }
    function toggleCourseSubmenu() {
        const el = document.getElementById('course-submenu');
        if (!el) return;
        const willOpen = el.style.display !== 'block';
        closeAllSubmenus('course-submenu');
        el.style.display = willOpen ? 'block' : 'none';
    }
    // 构建“本章目录”面板（与前两章一致为网格直达）
    function buildChapterMenuCh3() {
        const grid = document.getElementById('chapter-submenu-grid');
        if (!grid) return;
        grid.innerHTML = '';

        const groups = [
            { title: '导览', items: [
                { text: '封面', idx: 0, icon: 'fa-house' }
            ]},
            { title: '第一节 导数的概念', items: [
                { text: '导言', idx: 1 },
                { text: '生活中的变化率', idx: 2 },
                { text: '平均变化率', idx: 3 },
                { text: '逼近瞬时变化率', idx: 4 },
                { text: '导数的定义', idx: 5 },
                { text: '切线演示', idx: 6 },
                { text: '切线和法线方程', idx: 7 },
                { text: '切线法线例题', idx: 8 },
                { text: '导数的物理意义', idx: 9 },
            ]},
            { title: '第二节 导数的运算', items: [
                { text: '导言', idx: 10 },
                { text: '基本导数公式', idx: 11 },
                { text: '幂函数的导数', idx: 12 },
                { text: '指数函数的导数', idx: 13 },
                { text: '对数函数的导数', idx: 14 },
                { text: '三角函数的导数', idx: 15 },
                { text: '导数运算法则', idx: 17 },
                { text: '乘法法则', idx: 18 },
                { text: '除法法则', idx: 19 },
                { text: '链式法则', idx: 20 },
                { text: '反三角函数的导数', idx: 22 },
            ]},
            { title: '第三节 高阶导数', items: [
                { text: '高阶导数', idx: 31 },
            ]},
            { title: '第四节 隐函数与参数方程求导', items: [
                { text: '隐函数求导', idx: 23 },
                { text: '隐函数例题1', idx: 24 },
                { text: '隐函数例题2', idx: 25 },
                { text: '隐函数例题3', idx: 26 },
                { text: '参数方程求导', idx: 27 },
                { text: '摆线例题', idx: 28 },
                { text: '对数求导法', idx: 29 },
                { text: '对数求导例题2', idx: 30 },
            ]},
            { title: '第五节 函数的微分及其应用', items: [
                { text: '微分的概念', idx: 33 },
                { text: '线性近似与误差', idx: 34 },
                { text: '误差估计应用', idx: 35 },
            ]},
            { title: '补充：微分中值定理', items: [
                { text: '罗尔定理', idx: 37 },
                { text: '拉格朗日中值定理', idx: 38 },
                { text: '中值定理例题', idx: 39 },
                { text: '柯西中值定理', idx: 40 },
            ]},
            { title: '总结', items: [
                { text: '知识体系', idx: 42, icon: 'fa-clipboard' },
                { text: '练习与总结', idx: 43, icon: 'fa-pen' },
            ]},
        ];

        groups.forEach(group => {
            const header = document.createElement('div');
            header.className = 'submenu-item submenu-group';
            header.style.cursor = 'default';
            header.style.background = 'rgba(15,23,42,0.06)';
            header.style.borderColor = 'rgba(15,23,42,0.12)';
            header.innerHTML = `<span class="submenu-icon"><i class="fa-solid fa-folder-open"></i></span><span class="submenu-text" style="font-weight:700;">${group.title}</span>`;
            grid.appendChild(header);

            group.items.forEach(it => {
                const item = document.createElement('div');
                item.className = 'submenu-item submenu-leaf';
                const icon = it.icon ? `<i class=\"fa-solid ${it.icon}\"></i>` : '<i class=\"fa-solid fa-file-lines\"></i>';
                item.innerHTML = `<span class=\"submenu-icon\">${icon}</span><span class=\"submenu-text\">${it.text}</span>`;
                item.onclick = function() { goToSlide(it.idx); toggleChapterSubmenu(); };
                grid.appendChild(item);
            });
        });
    }
    function initFloatingControl() {
        const floatingBtn = document.getElementById('floating-control-btn');
        const floatingMenu = document.getElementById('floating-menu-items');
        if (!floatingBtn || !floatingMenu) return;
        floatingBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            floatingBtn.classList.toggle('active');
            floatingMenu.classList.toggle('active');
        });
    }

    // 导航功能
    function handleKeyNavigation(e) {
        if (e.key === 'ArrowRight' || e.key === ' ') {
            e.preventDefault();
            nextSlide();
        } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            previousSlide();
        } else if (e.key === 'Home') {
            e.preventDefault();
            goToSlide(0);
        } else if (e.key === 'End') {
            e.preventDefault();
            goToSlide(totalSlides - 1);
        }
    }

    function handleWheelNavigation(e) {
        e.preventDefault();
        if (e.deltaY > 0) {
            nextSlide();
        } else {
            previousSlide();
        }
    }

    function nextSlide() {
        if (currentSlide < totalSlides - 1) {
            currentSlide++;
            showSlide(currentSlide);
        }
    }

    function previousSlide() {
        if (currentSlide > 0) {
            currentSlide--;
            showSlide(currentSlide);
        }
    }

    function goToSlide(index) {
        if (index >= 0 && index < totalSlides) {
            currentSlide = index;
            showSlide(currentSlide);
        }
    }

    function jumpToSlide(value) {
        const slideNumber = parseInt(value);
        if (slideNumber >= 1 && slideNumber <= totalSlides) {
            currentSlide = slideNumber - 1;
            showSlide(currentSlide);
        }
    }

    function showSlide(index) {
        // 记录页面查看时间（仅在非首次加载时）
        if (pageStartTime && currentSlide >= 0) {
            const currentTime = Date.now();
            const timeSpent = (currentTime - pageStartTime) / 1000;
            pageViewTimes[currentSlide] += timeSpent;
            pageStartTime = currentTime;
        }
        
        // 清理之前的动画
        cleanupAnimations();
        
        slides.forEach(slide => slide.classList.remove('active'));
        currentSlide = index;
        slides[currentSlide].classList.add('active');
        
        // 更新页码输入框
        const slideInput = document.getElementById('slideNumberInput');
        const slideTotal = document.getElementById('slideNumberTotal');
        if (slideInput) {
            slideInput.value = currentSlide + 1;
            slideInput.max = totalSlides;
        }
        if (slideTotal) {
            slideTotal.textContent = totalSlides;
        }
        
        // 更新翻页按钮状态
        updateNavButtons();
        
        // 运行当前页的可视化
        runVisualization(currentSlide);

        // 强制重新渲染当前页的MathJax
        if (mathjaxReady && typeof MathJax.typesetPromise === 'function') {
            MathJax.typesetPromise([slides[index]]).catch(err => console.error(`MathJax re-rendering failed for slide ${index + 1}:`, err));
        }
    }

    function cleanupAnimations() {
        // 清理所有活动的动画
        activeAnimations.forEach(anim => {
            if (anim != null) {
                cancelAnimationFrame(anim);
            }
        });
        activeAnimations = [];

        trackedAnimationCallbacks.forEach(callback => {
            if (callback && typeof callback === 'function' && callback.__rafId != null) {
                delete callback.__rafId;
            }
        });
        trackedAnimationCallbacks.clear();

        // 清理定时器
        activeTimeouts.forEach(timeout => clearTimeout(timeout));
        activeTimeouts = [];
        
        activeIntervals.forEach(interval => clearInterval(interval));
        activeIntervals = [];
    }

    // D3.js 辅助函数
    
    const rootStyles = getComputedStyle(document.documentElement);
    const themeColors = {
        text: rootStyles.getPropertyValue('--text-color').trim() || '#34495e',
        axis: rootStyles.getPropertyValue('--axis-color').trim() || '#475569',
        muted: rootStyles.getPropertyValue('--muted-color').trim() || '#94a3b8',
        surface: rootStyles.getPropertyValue('--card-bg').trim() || '#ffffff'
    };

function setupD3(containerId, margins = {top: 40, right: 40, bottom: 60, left: 60}) {
        const container = d3.select(`#${containerId}`);
        if (container.empty()) return null;
        
        container.html('');
        
        const bounds = container.node().getBoundingClientRect();
        const width = bounds.width - margins.left - margins.right;
        const height = bounds.height - margins.top - margins.bottom;
        
        const svg = container.append('svg')
            .attr('width', bounds.width)
            .attr('height', bounds.height);
            
        const g = svg.append('g')
            .attr('transform', `translate(${margins.left}, ${margins.top})`);
            
        return { container, svg, g, width, height, bounds };
    }

    // 运行可视化
    function runVisualization(slideIndex) {
        // 延迟执行以确保DOM已渲染
        setTimeout(() => {
            try {
                switch(slideIndex) {
                    case 0: visualizeCover(); break;                  // 标题页
                    case 1: visualizeTrans1(); break;                 // 第一节过渡页
                    case 2: visualizeIntro(); break;                  // 生活中的变化率
                    case 3: visualizeAverageRate(); break;            // 平均变化率
                    case 4: visualizeLimitApproach(); break;          // 逼近瞬时变化率
                    case 5: visualizeDerivativeDef(); break;          // 导数的定义
                    case 6: visualizeTangentDemo(); break;            // 切线演示
                    case 7: visualizeTangentNormal(); break;          // 切线和法线方程
                    case 8: visualizeTangentNormalExample(); break;   // 切线法线例题
                    case 9: visualizePhysics(); break;                // 导数的物理意义
                    case 10: visualizeTrans2(); break;                // 第二节过渡页
                    case 11: visualizeConstant(); break;              // 基本导数公式
                    case 12: visualizePower(); break;                 // 幂函数的导数
                    case 13: visualizeExponential(); break;           // 指数函数的导数
                    case 14: visualizeLogarithm(); break;             // 对数函数的导数
                    case 15: visualizeTrigonometric(); break;         // 三角函数的导数
                    case 16: visualizeTrans3(); break;                // 第三节过渡页
                    case 17: visualizeAdditionRule(); break;          // 导数运算法则
                    case 18: visualizeProductRule(); break;           // 乘法法则
                    case 19: visualizeQuotientRule(); break;          // 除法法则
                    case 20: visualizeChainRule(); break;             // 链式法则
                    case 21: visualizeTrans4(); break;                // 第四节过渡页
                    case 22: visualizeInverseTrig(); break;           // 反三角函数的导数
                    case 23: visualizeImplicitConcept(); break;       // 隐函数求导
                    case 24: visualizeImplicitCircle(); break;        // 隐函数例题1
                    case 25: visualizeImplicitEllipse(); break;       // 隐函数例题2
                    case 26: visualizeImplicitExp(); break;           // 隐函数例题3
                    case 27: visualizeParametric(); break;            // 参数方程求导
                    case 28: visualizeCycloid(); break;               // 摆线例题
                    case 29: visualizeLogarithmicDiff(); break;       // 对数求导法
                    case 30: visualizeLogarithmicDiff2(); break;      // 对数求导法例题2
                    case 31: visualizeHigherOrder(); break;           // 高阶导数
                    case 32: visualizeTrans5(); break;                // 第五节过渡页
                    case 33: visualizeDifferentialConcept(); break;   // 微分的概念
                    case 34: visualizeDifferentialApprox(); break;    // 线性近似与误差
                    case 35: visualizeErrorEstimation(); break;       // 误差估计应用
                    case 36: visualizeTrans6(); break;                // 补充内容过渡页
                    case 37: visualizeRolle(); break;                 // 罗尔定理
                    case 38: visualizeLagrange(); break;              // 拉格朗日中值定理
                    case 39: visualizeLagrangeExample(); break;       // 拉格朗日例题
                    case 40: visualizeCauchy(); break;                // 柯西中值定理
                    case 41: break;                                   // 第七节过渡页 - 无可视化
                    case 42: visualizeKnowledgeMap(); break;          // 知识体系
                    case 43: visualizePractice(); break;              // 练习与总结
                }
            } catch (error) {
                console.error('Visualization error:', error);
            }
        }, 10);
    }

    // 第1页：封面可视化 - 导数与微分知识体系
    function visualizeCover() {
        const setup = setupD3('vis-cover', { top: 30, right: 30, bottom: 30, left: 30 });
        if (!setup) return;
        const { g, width, height } = setup;

        // 定义主题色彩
        const colors = {
            primary: '#3b82f6',
            secondary: '#10b981', 
            accent: '#f59e0b',
            purple: '#8b5cf6',
            red: '#ef4444'
        };

        // 定义知识点节点
        const nodes = [
            { id: 'concept', label: '导数的概念', x: 0.2, y: 0.15, color: colors.primary },
            { id: 'operation', label: '导数的运算', x: 0.8, y: 0.15, color: colors.secondary },
            { id: 'higher', label: '高阶导数', x: 0.15, y: 0.45, color: colors.accent },
            { id: 'implicit', label: '隐函数导数', x: 0.5, y: 0.35, color: colors.purple },
            { id: 'parametric', label: '参数方程导数', x: 0.85, y: 0.45, color: colors.purple },
            { id: 'differential', label: '函数的微分', x: 0.3, y: 0.75, color: colors.red },
            { id: 'application', label: '微分应用', x: 0.7, y: 0.75, color: colors.red }
        ];

        // 定义连接关系
        const links = [
            { source: 'concept', target: 'operation' },
            { source: 'concept', target: 'higher' },
            { source: 'operation', target: 'implicit' },
            { source: 'operation', target: 'parametric' },
            { source: 'implicit', target: 'differential' },
            { source: 'parametric', target: 'application' },
            { source: 'higher', target: 'differential' },
            { source: 'differential', target: 'application' }
        ];

        // 坐标转换函数
        const px = d => d * width;
        const py = d => d * height;

        // 创建箭头标记
        const defs = g.append('defs');
        defs.append('marker')
            .attr('id', 'arrow')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 15)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#94a3b8');

        // 创建节点映射
        const nodeMap = new Map(nodes.map(n => [n.id, n]));

        // 绘制连接线（延迟显示）
        const linkGroup = g.append('g').attr('class', 'links');
        
        setTimeout(() => {
            links.forEach((link, i) => {
                const source = nodeMap.get(link.source);
                const target = nodeMap.get(link.target);
                
                setTimeout(() => {
                    linkGroup.append('line')
                        .attr('x1', px(source.x))
                        .attr('y1', py(source.y))
                        .attr('x2', px(source.x))
                        .attr('y2', py(source.y))
                        .attr('stroke', '#cbd5e1')
                        .attr('stroke-width', 2)
                        .attr('marker-end', 'url(#arrow)')
                        .transition()
                        .duration(800)
                        .attr('x2', px(target.x))
                        .attr('y2', py(target.y));
                }, i * 200);
            });
        }, 1000);

        // 绘制节点
        const nodeGroup = g.append('g').attr('class', 'nodes');
        
        nodes.forEach((node, i) => {
            const nodeG = nodeGroup.append('g')
                .attr('transform', `translate(${px(node.x)}, ${py(node.y)})`)
                .style('opacity', 0);

            // 节点圆圈
            nodeG.append('circle')
                .attr('r', 35)
                .attr('fill', node.color)
                .attr('fill-opacity', 0.1)
                .attr('stroke', node.color)
                .attr('stroke-width', 2);

            // 节点文字
            nodeG.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                .style('font-size', '12px')
                .style('font-weight', '600')
                .style('fill', node.color)
                .text(node.label);

            // 动画显示节点
            nodeG.transition()
                .delay(i * 150)
                .duration(600)
                .style('opacity', 1)
                .select('circle')
                .attr('r', 35);
        });

        // 添加中心标题
        g.append('text')
            .attr('x', width / 2)
            .attr('y', height / 2)
            .attr('text-anchor', 'middle')
            .attr('dy', '0.35em')
            .style('font-size', '18px')
            .style('font-weight', 'bold')
            .style('fill', '#1f2937')
            .style('opacity', 0)
            .text('导数与微分')
            .transition()
            .delay(2000)
            .duration(1000)
            .style('opacity', 1);

        // 添加装饰性数学公式
        const formulas = [
            { text: "f'(x)", x: 0.1, y: 0.9, delay: 2500 },
            { text: "dy/dx", x: 0.9, y: 0.9, delay: 2700 },
            { text: "∂f/∂x", x: 0.05, y: 0.7, delay: 2900 },
            { text: "d²y/dx²", x: 0.95, y: 0.25, delay: 3100 }
        ];

        formulas.forEach(formula => {
            g.append('text')
                .attr('x', px(formula.x))
                .attr('y', py(formula.y))
                .attr('text-anchor', 'middle')
                .style('font-size', '14px')
                .style('font-style', 'italic')
                .style('fill', '#6b7280')
                .style('opacity', 0)
                .text(formula.text)
                .transition()
                .delay(formula.delay)
                .duration(800)
                .style('opacity', 0.6);
        });
    }

    // 第2页：引入动画 - 增强版汽车行驶
    function visualizeIntro() {
        const setup = setupD3('vis-intro');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建渐变背景
        const gradient = g.append('defs')
            .append('linearGradient')
            .attr('id', 'roadGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '0%').attr('y2', '100%');
        
        gradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#87CEEB')
            .style('stop-opacity', 1);
        
        gradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#98D8E8')
            .style('stop-opacity', 1);

        // 背景
        g.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', width)
            .attr('height', height * 0.5)
            .attr('fill', 'url(#roadGradient)');

        // 绘制道路
        const roadY = height * 0.6;
        g.append('rect')
            .attr('x', 0)
            .attr('y', roadY - 40)
            .attr('width', width)
            .attr('height', 80)
            .attr('fill', '#444')
            .attr('rx', 5);

        // 道路边线
        g.append('line')
            .attr('x1', 0)
            .attr('y1', roadY - 38)
            .attr('x2', width)
            .attr('y2', roadY - 38)
            .attr('stroke', '#FFD700')
            .attr('stroke-width', 3);

        g.append('line')
            .attr('x1', 0)
            .attr('y1', roadY + 38)
            .attr('x2', width)
            .attr('y2', roadY + 38)
            .attr('stroke', '#FFD700')
            .attr('stroke-width', 3);

        // 道路中线（动态）
        const dashGroup = g.append('g');
        for (let i = 0; i < width; i += 40) {
            dashGroup.append('rect')
                .attr('x', i)
                .attr('y', roadY - 2)
                .attr('width', 20)
                .attr('height', 4)
                .attr('fill', themeColors.text);
        }

        // 创建汽车组
        const car = g.append('g')
            .attr('transform', `translate(0, ${roadY})`);

        // 车身
        const carBody = car.append('g');
        
        // 主车身
        carBody.append('rect')
            .attr('x', -40)
            .attr('y', -25)
            .attr('width', 80)
            .attr('height', 35)
            .attr('fill', '#e74c3c')
            .attr('rx', 10);

        // 车窗
        carBody.append('rect')
            .attr('x', -25)
            .attr('y', -20)
            .attr('width', 30)
            .attr('height', 15)
            .attr('fill', '#3498db')
            .attr('opacity', 0.7)
            .attr('rx', 3);

        // 车轮
        car.append('circle')
            .attr('cx', -20)
            .attr('cy', 15)
            .attr('r', 10)
            .attr('fill', '#2c3e50');

        car.append('circle')
            .attr('cx', 20)
            .attr('cy', 15)
            .attr('r', 10)
            .attr('fill', '#2c3e50');

        // 速度显示面板
        const speedPanel = g.append('g')
            .attr('transform', `translate(${width/2}, 50)`);

        speedPanel.append('rect')
            .attr('x', -100)
            .attr('y', -30)
            .attr('width', 200)
            .attr('height', 60)
            .attr('fill', 'rgba(15, 23, 42, 0.75)')
            .attr('rx', 10);

        const speedText = speedPanel.append('text')
            .attr('text-anchor', 'middle')
            .attr('y', 5)
            .attr('font-size', '24px')
            .attr('fill', '#f8fafc') // Changed for better contrast
            .style('font-family', 'monospace');

        // 速度曲线显示
        const curveData = [];
        const curveX = d3.scaleLinear().domain([0, 100]).range([50, width - 50]);
        const curveY = d3.scaleLinear().domain([0, 100]).range([height - 50, height - 150]);
        
        const curvePath = g.append('path')
            .attr('fill', 'none')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3);

        const line = d3.line()
            .x(d => curveX(d.x))
            .y(d => curveY(d.y))
            .curve(d3.curveMonotoneX);

        // 动画
        let position = 0;
        let time = 0;
        let dataIndex = 0;
        
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }

            time += 0.016 / globalAnimationSpeed;
            
            // 变速运动（模拟真实驾驶）
            const baseSpeed = 50;
            const variation = 30 * Math.sin(time * 0.5) + 10 * Math.sin(time * 2);
            const speed = Math.max(10, baseSpeed + variation);
            
            position += speed * 0.016 / globalAnimationSpeed * 2;
            
            // 道路循环
            if (position > width + 50) {
                position = -50;
            }
            
            // 更新汽车位置
            car.attr('transform', `translate(${position}, ${roadY})`);
            
            // 更新速度显示
            speedText.text(`速度: ${speed.toFixed(1)} km/h`);
            
            // 更新速度曲线
            if (dataIndex % 5 === 0 && curveData.length < 100) {
                curveData.push({x: curveData.length, y: speed});
                if (curveData.length > 50) {
                    curveData.shift();
                    curveData.forEach((d, i) => d.x = i);
                }
                curvePath.attr('d', line(curveData));
            }
            dataIndex++;
            
            // 道路动画
            dashGroup.attr('transform', `translate(${-((position * 2) % 40)}, 0)`);
            
            registerAnimation(animate, requestAnimationFrame(animate));
        }
        
        animate();
    }

    // 第23页：微分的概念与记号
    function visualizeDifferentialConcept() {
        const setup = setupD3('vis-differential-concept', { top: 40, right: 40, bottom: 60, left: 60 });
        if (!setup) return;
        const { g, width, height } = setup;

        // 函数与切线：f(x)=sqrt(x) 在 x0=4 处
        const f = x => Math.sqrt(Math.max(0, x));
        const x0 = 4;
        const f0 = f(x0);
        const fprime = x => 1 / (2 * Math.sqrt(Math.max(1e-6, x)));
        const k = fprime(x0);

        const xScale = d3.scaleLinear().domain([0, 8]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 3.5]).range([height, 0]);

        // 轴
        g.append('g').attr('transform', `translate(0, ${yScale(0)})`).call(d3.axisBottom(xScale)).style('color', themeColors.text);
        g.append('g').attr('transform', `translate(${xScale(0)}, 0)`).call(d3.axisLeft(yScale)).style('color', themeColors.text);

        // 曲线
        const data = d3.range(0, 8.01, 0.05).map(x => ({ x, y: f(x) }));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y)).curve(d3.curveMonotoneX);
        g.append('path').datum(data).attr('d', line).attr('fill', 'none').attr('stroke', '#667eea').attr('stroke-width', 3);

        // 切点
        g.append('circle').attr('cx', xScale(x0)).attr('cy', yScale(f0)).attr('r', 6).attr('fill', '#e74c3c').attr('stroke', themeColors.axis).attr('stroke-width', 2);

        // 交互：dx 滑块
        let dx = 1.0;
        const tangent = x => f0 + k * (x - x0);
        const update = () => {
            // 清理旧元素
            g.selectAll('.tangent,.dy-seg,.dx-seg,.deltaY,.labels').remove();

            // 切线段
            g.append('line')
                .attr('class', 'tangent')
                .attr('x1', xScale(x0 - 2))
                .attr('y1', yScale(tangent(x0 - 2)))
                .attr('x2', xScale(x0 + 2))
                .attr('y2', yScale(tangent(x0 + 2)))
                .attr('stroke', '#f39c12')
                .attr('stroke-width', 3);

            // dx / dy 可视化
            const x1 = x0 + dx;
            const y1 = f(x1);
            const yL = tangent(x1);

            // dx 段
            g.append('line').attr('class', 'dx-seg').attr('x1', xScale(x0)).attr('y1', yScale(f0))
                .attr('x2', xScale(x1)).attr('y2', yScale(f0)).attr('stroke', '#95a5a6').attr('stroke-width', 2).attr('stroke-dasharray', '6,4');
            // dy 段
            g.append('line').attr('class', 'dy-seg').attr('x1', xScale(x1)).attr('y1', yScale(f0))
                .attr('x2', xScale(x1)).attr('y2', yScale(yL)).attr('stroke', '#2ecc71').attr('stroke-width', 3);
            // Δy 段
            g.append('line').attr('class', 'deltaY').attr('x1', xScale(x1)).attr('y1', yScale(f0))
                .attr('x2', xScale(x1)).attr('y2', yScale(y1)).attr('stroke', '#e67e22').attr('stroke-width', 2).attr('stroke-dasharray', '3,3');

            // 标签
            const labels = [
                { x: (x0 + x1) / 2, y: f0 - 0.15, text: 'dx' },
                { x: x1 + 0.1, y: (yL + f0) / 2, text: 'dy = f\'(x0) dx' },
                { x: x1 + 0.1, y: (y1 + f0) / 2, text: 'Δy' }
            ];
            g.selectAll('.labels').data(labels).enter().append('text')
                .attr('class', 'labels')
                .attr('x', d => xScale(d.x))
                .attr('y', d => yScale(d.y))
                .attr('fill', themeColors.text)
                .attr('font-size', '14px')
                .text(d => d.text);
        };

        update();

        // 简易滑条（屏幕底部）
        const slider = d3.select(setup.container.node().parentNode).append('input')
            .attr('type', 'range')
            .attr('min', -1.5)
            .attr('max', 1.5)
            .attr('step', 0.1)
            .attr('value', 1.0)
            .style('position', 'absolute')
            .style('left', '50%')
            .style('bottom', '24px')
            .style('transform', 'translateX(-50%)')
            .style('width', '50%');

        const onChange = () => { dx = parseFloat(slider.node().value); update(); };
        slider.on('input', onChange);

        // 清理：切换页时移除 slider
        registerAnimation(() => {}, requestAnimationFrame(() => {}));
        activeTimeouts.push(setTimeout(() => {}, 0));
        setup.container.on('remove', () => slider.remove());
    }

    // 第24页：线性近似与误差
    function visualizeDifferentialApprox() {
        const setup = setupD3('vis-differential-approx', { top: 40, right: 40, bottom: 60, left: 60 });
        if (!setup) return;
        const { g, width, height } = setup;

        const f = x => Math.sin(x) + 0.4 * Math.cos(2 * x);
        const fprime = x => Math.cos(x) - 0.8 * Math.sin(2 * x);
        const x0 = Math.PI / 3;
        const L = x => f(x0) + fprime(x0) * (x - x0);

        const xScale = d3.scaleLinear().domain([0, Math.PI * 2]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-1.8, 1.8]).range([height, 0]);

        // 轴
        g.append('g').attr('transform', `translate(0, ${yScale(0)})`).call(d3.axisBottom(xScale)).style('color', themeColors.text);
        g.append('g').attr('transform', `translate(${xScale(0)}, 0)`).call(d3.axisLeft(yScale)).style('color', themeColors.text);

        // 曲线与线性近似
        const data = d3.range(0, Math.PI * 2 + 0.01, 0.01).map(x => ({ x, y: f(x) }));
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));
        g.append('path').datum(data).attr('d', line).attr('fill', 'none').attr('stroke', '#667eea').attr('stroke-width', 2.5);

        const tangent = d3.line().x(d => xScale(d.x)).y(d => yScale(L(d.x)));
        const tData = d3.range(x0 - 0.8, x0 + 0.8, 0.01).map(x => ({ x }));
        g.append('path').datum(tData).attr('d', tangent).attr('fill', 'none').attr('stroke', '#f39c12').attr('stroke-width', 3);

        // 点与误差阴影
        const dx = 0.5;
        const xs = [x0 - dx, x0 + dx];
        xs.forEach(x => {
            const y = f(x);
            const yL = L(x);
            const xP = xScale(x);
            g.append('circle').attr('cx', xP).attr('cy', yScale(y)).attr('r', 5).attr('fill', '#e74c3c');
            g.append('circle').attr('cx', xP).attr('cy', yScale(yL)).attr('r', 5).attr('fill', '#2ecc71');
            g.append('rect')
                .attr('x', xP - 3)
                .attr('width', 6)
                .attr('y', yScale(Math.max(y, yL)))
                .attr('height', Math.abs(yScale(y) - yScale(yL)))
                .attr('fill', 'rgba(231, 76, 60, 0.15)');
        });

        // 标签
        g.append('text').attr('x', xScale(x0)).attr('y', yScale(f(x0)) - 10).attr('text-anchor', 'middle').attr('fill', themeColors.text).text('x0');
        g.append('text').attr('x', xScale(x0) + 10).attr('y', yScale(L(x0)) + 16).attr('fill', themeColors.text).text('L(x) = 线性近似');
        g.append('text').attr('x', xScale(x0) + 10).attr('y', yScale(f(x0)) - 20).attr('fill', themeColors.text).text('f(x) 原函数');
    }

    // 第34页：误差估计
    function visualizeErrorEstimation() {
        const setup = setupD3('vis-error-estimation');
        if (!setup) return;
        const { g, width, height } = setup;

        // 显示圆钢截面
        const centerY = height / 3;
        const D = 60.03; // 直径
        const scale = 3; // 缩放比例用于显示
        
        // 绘制圆形截面
        g.append('circle')
            .attr('cx', width/4)
            .attr('cy', centerY)
            .attr('r', scale)
            .attr('fill', '#95a5a6')
            .attr('fill-opacity', 0.5)
            .attr('stroke', '#34495e')
            .attr('stroke-width', 2);

        // 标注直径
        g.append('line')
            .attr('x1', width/4 - scale)
            .attr('y1', centerY)
            .attr('x2', width/4 + scale)
            .attr('y2', centerY)
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2);

        g.append('text')
            .attr('x', width/4)
            .attr('y', centerY - scale - 10)
            .attr('text-anchor', 'middle')
            .attr('fill', '#e74c3c')
            .attr('font-size', '14px')
            .text('D = 60.03 mm');

        g.append('text')
            .attr('x', width/4)
            .attr('y', centerY - scale - 25)
            .attr('text-anchor', 'middle')
            .attr('fill', '#7f8c8d')
            .attr('font-size', '12px')
            .text('误差: ±0.05 mm');

        // 显示计算结果
        const results = [
            { y: 80, label: '面积公式：', value: 'A = πD²/4', color: '#3498db' },
            { y: 120, label: '微分：', value: 'dA = (πD/2)·dD', color: '#9b59b6' },
            { y: 160, label: '绝对误差：', value: '|ΔA| ≈ 4.72 mm²', color: '#e74c3c' },
            { y: 200, label: '相对误差：', value: '≈ 0.17%', color: '#2ecc71' }
        ];

        results.forEach((item, i) => {
            const boxG = g.append('g')
                .attr('transform', `translate(${width/2 + 50}, ${item.y})`);

            boxG.append('text')
                .attr('x', 0)
                .attr('y', 0)
                .attr('fill', themeColors.text)
                .attr('font-size', '14px')
                .attr('font-weight', 'bold')
                .text(item.label);

            boxG.append('text')
                .attr('x', 120)
                .attr('y', 0)
                .attr('fill', item.color)
                .attr('font-size', '16px')
                .text(item.value)
                .attr('opacity', 0)
                .transition()
                .delay(i * 500)
                .duration(500)
                .attr('opacity', 1);
        });

        // 绘制误差示意图
        const errorDemo = g.append('g')
            .attr('transform', `translate(${width/4}, ${height * 0.7})`);

        // 真实值 vs 测量值
        errorDemo.append('rect')
            .attr('x', -60)
            .attr('y', -25)
            .attr('width', 120)
            .attr('height', 50)
            .attr('fill', '#3498db')
            .attr('fill-opacity', 0.3)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2)
            .attr('rx', 5);

        errorDemo.append('text')
            .attr('x', 0)
            .attr('y', 0)
            .attr('text-anchor', 'middle')
            .attr('fill', themeColors.text)
            .attr('font-size', '14px')
            .text('测量值范围');

        errorDemo.append('text')
            .attr('x', 0)
            .attr('y', 20)
            .attr('text-anchor', 'middle')
            .attr('fill', '#7f8c8d')
            .attr('font-size', '12px')
            .text('[59.98, 60.08]');
    }

    // 第35页：知识体系（导数与微分）
    function visualizeKnowledgeMap() {
        const setup = setupD3('vis-knowledge-map', { top: 40, right: 40, bottom: 40, left: 40 });
        if (!setup) return;
        const { g, width, height } = setup;

        // 定义节点与连线
        const nodes = [
            { id: 'def', label: '导数定义\n瞬时变化率', x: 0.15, y: 0.2 },
            { id: 'geo', label: '几何意义\n切线斜率', x: 0.45, y: 0.2 },
            { id: 'basic', label: '基本公式', x: 0.75, y: 0.2 },
            { id: 'rules', label: '运算法则\n加/乘/商/链', x: 0.3, y: 0.55 },
            { id: 'diff', label: '微分与近似\ndy = f\'(x)dx', x: 0.6, y: 0.55 },
            { id: 'models', label: '典型模型\n速度/加速度\n切线/法线', x: 0.85, y: 0.55 },
            { id: 'ch2', label: '衔接：第二章\n极限与连续', x: 0.2, y: 0.85 },
            { id: 'ch4', label: '衔接：第四章\n导数应用', x: 0.7, y: 0.85 }
        ];

        const links = [
            { source: 'def', target: 'geo' },
            { source: 'def', target: 'rules' },
            { source: 'geo', target: 'models' },
            { source: 'rules', target: 'basic' },
            { source: 'rules', target: 'diff' },
            { source: 'diff', target: 'models' },
            { source: 'ch2', target: 'def' },
            { source: 'models', target: 'ch4' }
        ];

        // 坐标缩放到画布
        const px = d => d * width;
        const py = d => d * height;

        // 箭头定义
        const defs = g.append('defs');
        defs.append('marker')
            .attr('id', 'arrow')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 12)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', themeColors.muted);

        const idToNode = new Map(nodes.map(n => [n.id, n]));

        // 画连线
        g.selectAll('path.link')
            .data(links)
            .enter()
            .append('path')
            .attr('class', 'link')
            .attr('fill', 'none')
            .attr('stroke', themeColors.muted)
            .attr('stroke-width', 2)
            .attr('marker-end', 'url(#arrow)')
            .attr('d', d => {
                const s = idToNode.get(d.source);
                const t = idToNode.get(d.target);
                const x1 = px(s.x), y1 = py(s.y);
                const x2 = px(t.x), y2 = py(t.y);
                const cx = (x1 + x2) / 2;
                const cy = y1 < y2 ? y1 + Math.abs(y2 - y1) * 0.3 : y2 + Math.abs(y2 - y1) * 0.3;
                return `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;
            });

        // 画节点
        const group = g.selectAll('g.node')
            .data(nodes)
            .enter()
            .append('g')
            .attr('class', 'node')
            .attr('transform', d => `translate(${px(d.x)}, ${py(d.y)})`);

        const rectW = 160, rectH = 64;

        group.append('rect')
            .attr('x', -rectW / 2)
            .attr('y', -rectH / 2)
            .attr('rx', 12)
            .attr('ry', 12)
            .attr('width', rectW)
            .attr('height', rectH)
            .attr('fill', themeColors.surface)
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 1.5)
            .attr('filter', null);

        group.append('text')
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .attr('fill', themeColors.text)
            .style('font-size', '14px')
            .selectAll('tspan')
            .data(d => d.label.split('\n'))
            .enter()
            .append('tspan')
            .attr('x', 0)
            .attr('dy', (d, i) => i === 0 ? 0 : 18)
            .text(d => d);
    }

    // 继续实现其他可视化函数...
    // 由于篇幅限制，我将提供几个关键的增强版可视化函数

    // 第3页：平均变化率 - 增强版
    function visualizeAverageRate() {
        const setup = setupD3('vis-average-rate');
        if (!setup) return;
        const { g, width, height } = setup;

        // 坐标轴
        const xScale = d3.scaleLinear().domain([0, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 10]).range([height, 0]);

        // 网格线
        const gridLinesX = g.append('g').attr('class', 'grid-x');
        const gridLinesY = g.append('g').attr('class', 'grid-y');

        for (let i = 0; i <= 5; i++) {
            gridLinesX.append('line')
                .attr('x1', xScale(i))
                .attr('y1', 0)
                .attr('x2', xScale(i))
                .attr('y2', height)
                .attr('stroke', '#e0e0e0')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0.5);
        }

        for (let i = 0; i <= 10; i++) {
            gridLinesY.append('line')
                .attr('x1', 0)
                .attr('y1', yScale(i))
                .attr('x2', width)
                .attr('y2', yScale(i))
                .attr('stroke', '#e0e0e0')
                .attr('stroke-width', 0.5)
                .attr('opacity', 0.5);
        }

        const xAxis = d3.axisBottom(xScale).ticks(5);
        const yAxis = d3.axisLeft(yScale).ticks(10);

        g.append('g')
            .attr('transform', `translate(0, ${height})`)
            .call(xAxis)
            .append('text')
            .attr('x', width)
            .attr('y', 35)
            .attr('fill', themeColors.text)
            .style('text-anchor', 'end')
            .text('x');

        g.append('g')
            .call(yAxis)
            .append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', -40)
            .attr('x', 0)
            .attr('fill', themeColors.text)
            .style('text-anchor', 'end')
            .text('y');

        // 函数曲线 y = x^2
        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        const data = d3.range(0, 5.1, 0.05).map(x => ({x: x, y: x * x / 2.5}));

        // 添加渐变
        const gradient = g.append('defs')
            .append('linearGradient')
            .attr('id', 'lineGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '0%');
        
        gradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#667eea')
            .style('stop-opacity', 1);
        
        gradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#764ba2')
            .style('stop-opacity', 1);

        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', 'url(#lineGradient)')
            .attr('stroke-width', 4);

        // 动画绘制曲线
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);

        // 动态点
        let x1 = 1, x2 = 3;
        let moving = false;

        const point1 = g.append('circle')
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 2px 4px rgba(15, 23, 42, 0.2))');

        const point2 = g.append('circle')
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 2px 4px rgba(15, 23, 42, 0.2))');

        // 割线
        const secant = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '8,4');

        // 标签
        const label1 = g.append('text')
            .attr('font-size', '14px')
            .attr('fill', themeColors.text)
            .attr('text-anchor', 'middle');

        const label2 = g.append('text')
            .attr('font-size', '14px')
            .attr('fill', themeColors.text)
            .attr('text-anchor', 'middle');

        // 斜率显示
        const slopeText = g.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .attr('font-size', '22px')
            .attr('fill', themeColors.text)
            .style('font-weight', 'bold');

        function updatePoints() {
            const y1 = x1 * x1 / 2.5;
            const y2 = x2 * x2 / 2.5;

            point1.attr('cx', xScale(x1)).attr('cy', yScale(y1));
            point2.attr('cx', xScale(x2)).attr('cy', yScale(y2));

            secant
                .attr('x1', xScale(x1))
                .attr('y1', yScale(y1))
                .attr('x2', xScale(x2))
                .attr('y2', yScale(y2));

            label1
                .attr('x', xScale(x1))
                .attr('y', yScale(y1) - 15)
                .text(`(${x1.toFixed(1)}, ${y1.toFixed(2)})`);

            label2
                .attr('x', xScale(x2))
                .attr('y', yScale(y2) - 15)
                .text(`(${x2.toFixed(1)}, ${y2.toFixed(2)})`);

            const slope = (y2 - y1) / (x2 - x1);
            slopeText.text(`割线斜率 = ${slope.toFixed(2)}`);
        }

        // 自动动画
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }

            x2 = 2 + 1.5 * Math.sin(Date.now() * 0.0005 / globalAnimationSpeed);
            updatePoints();

            registerAnimation(animate, requestAnimationFrame(animate));
        }

        updatePoints();
        setTimeout(() => animate(), 2000);
    }

    // 第4页：极限逼近 - 增强版
    // 用户需求：坐标系设计必须正确，交点是(0,0)
    function visualizeLimitApproach() {
        const setup = setupD3('vis-limit-approach');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([0, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 10]).range([height, 0]);

        // 坐标轴 - 原点在左下角(0,0)
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        // 函数曲线
        const func = x => x * x / 2.5;
        const data = d3.range(0, 5.1, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 4);

        // 固定点
        const x0 = 2;
        const y0 = func(x0);

        const fixedPoint = g.append('circle')
            .attr('cx', xScale(x0))
            .attr('cy', yScale(y0))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        // 添加发光效果
        fixedPoint.style('filter', 'drop-shadow(0 0 10px rgba(231, 76, 60, 0.8))');

        // 移动点和割线
        const movingPoint = g.append('circle')
            .attr('r', 6)
            .attr('fill', '#2ecc71')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        const secantLine = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3);

        // 切线（最终显示）
        const tangentLine = g.append('line')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5')
            .attr('opacity', 0);

        const deltaText = g.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .attr('font-size', '20px')
            .attr('fill', themeColors.text);

        const slopeText = g.append('text')
            .attr('x', width / 2)
            .attr('y', 60)
            .attr('text-anchor', 'middle')
            .attr('font-size', '18px')
            .attr('fill', '#f39c12');

        // 轨迹点容器
        const traceGroup = g.append('g');

        // 动画
        let t = 1;
        let shrinking = true;
        
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }

            if (shrinking) {
                t = Math.max(0.01, t - 0.008 / globalAnimationSpeed);
                if (t <= 0.01) {
                    shrinking = false;
                    // 显示切线
                    const slope = 2 * x0 / 2.5; // 导数
                    tangentLine
                        .attr('x1', xScale(0))
                        .attr('y1', yScale(y0 + slope * (0 - x0)))
                        .attr('x2', xScale(5))
                        .attr('y2', yScale(y0 + slope * (5 - x0)))
                        .transition()
                        .duration(500)
                        .attr('opacity', 0.7);
                }
            } else {
                t = Math.min(1, t + 0.008 / globalAnimationSpeed);
                if (t >= 1) {
                    shrinking = true;
                    tangentLine.attr('opacity', 0);
                    traceGroup.selectAll('*').remove();
                }
            }
            
            const x1 = x0 + t;
            const y1 = func(x1);
            const slope = (y1 - y0) / (x1 - x0);

            movingPoint
                .attr('cx', xScale(x1))
                .attr('cy', yScale(y1));

            secantLine
                .attr('x1', xScale(x0))
                .attr('y1', yScale(y0))
                .attr('x2', xScale(x1))
                .attr('y2', yScale(y1));

            // 添加轨迹点
            if (Math.random() < 0.1) {
                traceGroup.append('circle')
                    .attr('cx', xScale(x1))
                    .attr('cy', yScale(y1))
                    .attr('r', 2)
                    .attr('fill', '#2ecc71')
                    .attr('opacity', 0.6)
                    .transition()
                    .duration(3000)
                    .attr('opacity', 0)
                    .remove();
            }

            deltaText.text(`Δx = ${t.toFixed(3)}`);
            slopeText.text(`割线斜率 = ${slope.toFixed(3)}`);

            registerAnimation(animate, requestAnimationFrame(animate));
        }
        
        animate();
    }

    // 第6页：切线动态演示 - 增强版
    // 用户需求：坐标系交点必须是(0,0)，切线计算必须正确
    function visualizeTangentDemo() {
        const setup = setupD3('vis-tangent-demo');
        if (!setup) return;
        const { g, width, height } = setup;

        // 用户需求：坐标系设计必须正确，交点是(0,0)
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-1, 9]).range([height, 0]);

        // 坐标轴 - 交点在(0,0)
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        // 函数曲线 y = x^2
        const func = x => x * x;
        const data = d3.range(-3, 3.1, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        // 曲线渐变
        const gradient = g.append('defs')
            .append('linearGradient')
            .attr('id', 'curveGradient')
            .attr('x1', '0%').attr('y1', '0%')
            .attr('x2', '100%').attr('y2', '0%');
        
        gradient.append('stop')
            .attr('offset', '0%')
            .style('stop-color', '#667eea')
            .style('stop-opacity', 1);
        
        gradient.append('stop')
            .attr('offset', '50%')
            .style('stop-color', '#764ba2')
            .style('stop-opacity', 1);
        
        gradient.append('stop')
            .attr('offset', '100%')
            .style('stop-color', '#667eea')
            .style('stop-opacity', 1);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', 'url(#curveGradient)')
            .attr('stroke-width', 4);

        // 移动的点
        const point = g.append('circle')
            .attr('r', 10)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 3)
            .style('filter', 'drop-shadow(0 0 15px rgba(231, 76, 60, 0.8))');

        // 切线
        const tangent = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3)
            .style('filter', 'drop-shadow(0 0 8px rgba(243, 156, 18, 0.6))');

        // 导数值显示面板
        const infoPanel = g.append('g');
        
        infoPanel.append('rect')
            .attr('x', 10)
            .attr('y', 10)
            .attr('width', 180)
            .attr('height', 80)
            .attr('fill', 'rgba(71, 85, 105, 0.85)')
            .attr('rx', 10);

        const xText = infoPanel.append('text')
            .attr('x', 100)
            .attr('y', 35)
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .attr('fill', '#f8fafc'); // Changed for better contrast

        const slopeText = infoPanel.append('text')
            .attr('x', 100)
            .attr('y', 60)
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .attr('fill', '#f39c12');

        const formulaText = infoPanel.append('text')
            .attr('x', 100)
            .attr('y', 85)
            .attr('text-anchor', 'middle')
            .attr('font-size', '14px')
            .attr('fill', themeColors.muted);

        // 历史轨迹
        const traceGroup = g.append('g');
        const traces = [];

        // 动画
        let t = 0;
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }

            t += 0.01 / globalAnimationSpeed;
            
            const x = 2.5 * Math.sin(t);
            const y = func(x);
            const slope = 2 * x; // f'(x) = 2x

            point
                .attr('cx', xScale(x))
                .attr('cy', yScale(y));

            // 切线端点计算
            // 用户需求：切线必须正确显示，使用点斜式 y - y0 = k(x - x0)
            // 即 y = y0 + k(x - x0)
            const dx = 2.5; // 切线延伸范围
            const x1 = x - dx;
            const x2 = x + dx;
            // 点斜式：y = y0 + slope * (x - x0)
            const y1 = y + slope * (x1 - x);
            const y2 = y + slope * (x2 - x);

            tangent
                .attr('x1', xScale(x1))
                .attr('y1', yScale(y1))
                .attr('x2', xScale(x2))
                .attr('y2', yScale(y2));

            // 更新信息
            xText.text(`x = ${x.toFixed(2)}`);
            slopeText.text(`f'(x) = ${slope.toFixed(2)}`);
            formulaText.text(`切线斜率 = 2x`);

            // 添加轨迹
            if (traces.length === 0 || Math.hypot(
                xScale(x) - xScale(traces[traces.length - 1].x),
                yScale(y) - yScale(traces[traces.length - 1].y)
            ) > 30) {
                const trace = {x, y, element: null};
                trace.element = traceGroup.append('circle')
                    .attr('cx', xScale(x))
                    .attr('cy', yScale(y))
                    .attr('r', 3)
                    .attr('fill', '#e74c3c')
                    .attr('opacity', 0.6);
                
                traces.push(trace);
                
                // 淡出旧轨迹
                if (traces.length > 20) {
                    const oldTrace = traces.shift();
                    oldTrace.element
                        .transition()
                        .duration(1000)
                        .attr('opacity', 0)
                        .remove();
                }
            }

            registerAnimation(animate, requestAnimationFrame(animate));
        }
        
        animate();
    }

    // 第7页：切线和法线方程演示
    // 用户需求：展示切线和法线的几何关系
    function visualizeTangentNormal() {
        const setup = setupD3('vis-tangent-normal');
        if (!setup) return;
        const { g, width, height } = setup;

        // 用户需求：坐标系设计必须正确，交点是(0,0)
        const xScale = d3.scaleLinear().domain([-2, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 10]).range([height, 0]);

        // 坐标轴 - 交点在(0,0)
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        // 函数曲线 y = x^2
        const func = x => x * x;
        const data = d3.range(-2, 4.1, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 3);

        // 固定点 (1, 1)
        const x0 = 1, y0 = 1;
        g.append('circle')
            .attr('cx', xScale(x0))
            .attr('cy', yScale(y0))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 0 10px rgba(231, 76, 60, 0.8))');

        // 切线 y - 1 = 2(x - 1)
        const slope = 2; // f'(1) = 2
        const tangentLine = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3)
            .style('filter', 'drop-shadow(0 0 8px rgba(243, 156, 18, 0.6))');

        // 法线 y - 1 = -1/2(x - 1)
        const normalSlope = -1 / slope;
        const normalLine = g.append('line')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5')
            .style('filter', 'drop-shadow(0 0 8px rgba(46, 204, 113, 0.6))');

        // 标签
        g.append('text')
            .attr('x', xScale(2.5))
            .attr('y', yScale(4))
            .attr('fill', '#f39c12')
            .attr('font-size', '18px')
            .text('切线');

        g.append('text')
            .attr('x', xScale(3))
            .attr('y', yScale(-0.5))
            .attr('fill', '#2ecc71')
            .attr('font-size', '18px')
            .text('法线');

        // 动画：切线和法线延伸
        let t = 0;
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }

            t += 0.01 / globalAnimationSpeed;
            const extend = 1 + Math.abs(Math.sin(t)) * 2;

            // 切线端点
            const tx1 = x0 - extend;
            const tx2 = x0 + extend;
            const ty1 = y0 + slope * (tx1 - x0);
            const ty2 = y0 + slope * (tx2 - x0);

            tangentLine
                .attr('x1', xScale(tx1))
                .attr('y1', yScale(ty1))
                .attr('x2', xScale(tx2))
                .attr('y2', yScale(ty2));

            // 法线端点
            const nx1 = x0 - extend;
            const nx2 = x0 + extend;
            const ny1 = y0 + normalSlope * (nx1 - x0);
            const ny2 = y0 + normalSlope * (nx2 - x0);

            normalLine
                .attr('x1', xScale(nx1))
                .attr('y1', yScale(ny1))
                .attr('x2', xScale(nx2))
                .attr('y2', yScale(ny2));

            registerAnimation(animate, requestAnimationFrame(animate));
        }

        animate();
    }

    // 第8页：切线法线例题演示
    // 用户需求：展示求切线和法线方程的完整过程
    function visualizeTangentNormalExample() {
        const setup = setupD3('vis-tangent-normal-example');
        if (!setup) return;
        const { g, width, height } = setup;

        // 用户需求：坐标系设计必须正确，交点是(0,0)
        const xScale = d3.scaleLinear().domain([-1, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-1, 10]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        // 函数曲线 y = x^2
        const func = x => x * x;
        const data = d3.range(-1, 4.1, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 3);

        // 点 (1, 1)
        g.append('circle')
            .attr('cx', xScale(1))
            .attr('cy', yScale(1))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        // 切线 y = 2x - 1
        g.append('line')
            .attr('x1', xScale(-0.5))
            .attr('y1', yScale(2 * (-0.5) - 1))
            .attr('x2', xScale(3))
            .attr('y2', yScale(2 * 3 - 1))
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3);

        // 法线 y = -1/2 x + 3/2
        g.append('line')
            .attr('x1', xScale(-0.5))
            .attr('y1', yScale(-0.5 * (-0.5) + 1.5))
            .attr('x2', xScale(3.5))
            .attr('y2', yScale(-0.5 * 3.5 + 1.5))
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5');

        // 标注
        g.append('text')
            .attr('x', xScale(1))
            .attr('y', yScale(1) - 15)
            .attr('text-anchor', 'middle')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px')
            .text('(1, 1)');

        g.append('text')
            .attr('x', xScale(2.5))
            .attr('y', yScale(4))
            .attr('fill', '#f39c12')
            .attr('font-size', '16px')
            .text('y = 2x - 1');

        g.append('text')
            .attr('x', xScale(3))
            .attr('y', yScale(0))
            .attr('fill', '#2ecc71')
            .attr('font-size', '16px')
            .text('y = -½x + 3/2');
    }

    // 第11页：幂函数 - 增强版
    function visualizePower() {
        const setup = setupD3('vis-power');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-5, 10]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // 绘制多个幂函数
        const functions = [
            { func: x => x, label: 'y = x', derivative: "y' = 1", color: '#3498db', n: 1 },
            { func: x => x * x, label: 'y = x²', derivative: "y' = 2x", color: '#e74c3c', n: 2 },
            { func: x => x * x * x, label: 'y = x³', derivative: "y' = 3x²", color: '#2ecc71', n: 3 }
        ];

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX)
            .defined(d => d.y >= -5 && d.y <= 10);

        // 创建函数路径
        functions.forEach((f, i) => {
            const data = d3.range(-3, 3.1, 0.05).map(x => ({x: x, y: f.func(x)}));

            const path = g.append('path')
                .datum(data)
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', f.color)
                .attr('stroke-width', 3)
                .attr('opacity', 0.3);

            // 鼠标悬停效果
            path.on('mouseover', function() {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('stroke-width', 5)
                    .attr('opacity', 1);
                
                // 显示信息
                showFunctionInfo(f, i);
            })
            .on('mouseout', function() {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('stroke-width', 3)
                    .attr('opacity', 0.3);
            });

            // 渐入动画
            path
                .attr('stroke-dasharray', function() {
                    return this.getTotalLength() + ' ' + this.getTotalLength();
                })
                .attr('stroke-dashoffset', function() {
                    return this.getTotalLength();
                })
                .transition()
                .delay(i * 500)
                .duration(1500)
                .attr('stroke-dashoffset', 0)
                .attr('opacity', 0.8);
        });

        // 信息面板
        const infoPanel = g.append('g')
            .attr('transform', `translate(${width - 200}, 20)`);

        infoPanel.append('rect')
            .attr('width', 180)
            .attr('height', 120)
            .attr('fill', 'rgba(71, 85, 105, 0.85)')
            .attr('rx', 10);

        const infoTitle = infoPanel.append('text')
            .attr('x', 90)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .attr('font-size', '18px')
            .attr('fill', '#f8fafc'); // Changed for better contrast

        const infoFormula = infoPanel.append('text')
            .attr('x', 90)
            .attr('y', 60)
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .attr('fill', themeColors.muted);

        const infoDerivative = infoPanel.append('text')
            .attr('x', 90)
            .attr('y', 90)
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .attr('fill', '#f39c12');

        function showFunctionInfo(f, index) {
            infoTitle.text(f.label).attr('fill', f.color);
            infoFormula.text(`n = ${f.n}`);
            infoDerivative.text(f.derivative);
        }

        // 默认显示第一个函数
        showFunctionInfo(functions[0], 0);

        // 动态点演示
        const movingPoint = g.append('circle')
            .attr('r', 8)
            .attr('fill', themeColors.text)
            .attr('stroke', '#34495e')
            .attr('stroke-width', 2);

        const tangentLine = g.append('line')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5')
            .attr('opacity', 0.7);

        let t = 0;
        let currentFuncIndex = 0;
        
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }

            t += 0.01 / globalAnimationSpeed;
            
            // 每3秒切换一个函数
            currentFuncIndex = Math.floor((t / 3) % functions.length);
            const currentFunc = functions[currentFuncIndex];
            
            const x = 2 * Math.sin(t);
            const y = currentFunc.func(x);
            
            if (y >= -5 && y <= 10) {
                movingPoint
                    .attr('cx', xScale(x))
                    .attr('cy', yScale(y))
                    .attr('fill', currentFunc.color)
                    .attr('opacity', 1);

                // 计算切线
                // 用户需求：切线计算必须正确
                let slope;
                if (currentFunc.n === 1) slope = 1;
                else if (currentFunc.n === 2) slope = 2 * x;
                else if (currentFunc.n === 3) slope = 3 * x * x;

                const dx = 2; // 切线延伸范围
                const x1 = x - dx;
                const x2 = x + dx;
                // 点斜式：y = y0 + slope * (x - x0)
                const y1 = y + slope * (x1 - x);
                const y2 = y + slope * (x2 - x);

                tangentLine
                    .attr('x1', xScale(x1))
                    .attr('y1', yScale(y1))
                    .attr('x2', xScale(x2))
                    .attr('y2', yScale(y2))
                    .attr('stroke', currentFunc.color);
            } else {
                movingPoint.attr('opacity', 0);
                tangentLine.attr('opacity', 0);
            }

            registerAnimation(animate, requestAnimationFrame(animate));
        }

        animate();
    }

    // 其他可视化函数...
    // 由于篇幅限制，其余函数保持基本功能，但都应用类似的增强效果

    // 第7页：常数函数
    function visualizeConstant() {
        const setup = setupD3('vis-constant');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-5, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 8]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // 常数函数 y = 3
        const y = 3;
        g.append('line')
            .attr('x1', xScale(-5))
            .attr('y1', yScale(y))
            .attr('x2', xScale(5))
            .attr('y2', yScale(y))
            .attr('stroke', '#3498db')
            .attr('stroke-width', 4);

        // 标签
        g.append('text')
            .attr('x', xScale(4))
            .attr('y', yScale(y) - 10)
            .text('y = 3')
            .attr('font-size', '20px')
            .attr('fill', '#3498db');

        // 导数图像 (y = 0)
        const derivativeLine = g.append('line')
            .attr('x1', xScale(-5))
            .attr('y1', yScale(0))
            .attr('x2', xScale(5))
            .attr('y2', yScale(0))
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '8,4')
            .attr('opacity', 0);

        // 导数标签
        const derivativeLabel = g.append('text')
            .attr('x', xScale(4))
            .attr('y', yScale(0) + 25)
            .text("y' = 0")
            .attr('font-size', '20px')
            .attr('fill', '#e74c3c')
            .attr('opacity', 0);

        // 动画显示导数
        setTimeout(() => {
            derivativeLine
                .transition()
                .duration(1000)
                .attr('opacity', 1);
            
            derivativeLabel
                .transition()
                .duration(1000)
                .attr('opacity', 1);
        }, 1500);
    }

    // 继续实现剩余的可视化函数...

    // 第10页：指数函数
    function visualizeExponential() {
        const setup = setupD3('vis-exponential');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 20]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${height})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text);

        g.append('g')
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // e^x 函数
        const data = d3.range(-3, 3.1, 0.05).map(x => ({x: x, y: Math.exp(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        const path = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 4);

        // 动画绘制
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .duration(2000)
            .attr('stroke-dashoffset', 0);

        // 特殊性质标注
        g.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('text-anchor', 'middle')
            .attr('font-size', '22px')
            .attr('fill', themeColors.text)
            .text("(e^x)' = e^x")
            .attr('opacity', 0)
            .transition()
            .delay(1500)
            .duration(1000)
            .attr('opacity', 1);
    }

    // 第11页：对数函数
    function visualizeLogarithm() {
        const setup = setupD3('vis-logarithm');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([0, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 3]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text);

        g.append('g')
            .attr('transform', `translate(${xScale(0.01)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // ln(x) 函数
        const data = d3.range(0.1, 5.1, 0.05).map(x => ({x: x, y: Math.log(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 4);

        // 导数 1/x
        const derivativeData = d3.range(0.1, 5.1, 0.05).map(x => ({x: x, y: 1/x}));

        g.append('path')
            .datum(derivativeData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5')
            .attr('opacity', 0)
            .transition()
            .delay(1000)
            .duration(1000)
            .attr('opacity', 0.7);

        // 标签
        g.append('text')
            .attr('x', xScale(3))
            .attr('y', yScale(Math.log(3)) - 10)
            .text('y = ln(x)')
            .attr('font-size', '18px')
            .attr('fill', '#2ecc71');

        g.append('text')
            .attr('x', xScale(3))
            .attr('y', yScale(1/3) + 20)
            .text("y' = 1/x")
            .attr('font-size', '18px')
            .attr('fill', '#e74c3c')
            .attr('opacity', 0)
            .transition()
            .delay(1500)
            .duration(1000)
            .attr('opacity', 1);
    }

    // 第12页：三角函数
    function visualizeTrigonometric() {
        const setup = setupD3('vis-trigonometric');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-Math.PI, Math.PI]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-1.5, 1.5]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale)
                .tickValues([-Math.PI, -Math.PI/2, 0, Math.PI/2, Math.PI])
                .tickFormat(d => {
                    if (d === 0) return '0';
                    if (d === Math.PI) return 'π';
                    if (d === -Math.PI) return '-π';
                    if (d === Math.PI/2) return 'π/2';
                    if (d === -Math.PI/2) return '-π/2';
                }))
            .style('color', themeColors.text);

        g.append('g')
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // sin(x) 和 cos(x)
        const data = d3.range(-Math.PI, Math.PI, 0.05);
        
        const sinData = data.map(x => ({x: x, y: Math.sin(x)}));
        const cosData = data.map(x => ({x: x, y: Math.cos(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        // sin(x)
        g.append('path')
            .datum(sinData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);

        // cos(x)
        g.append('path')
            .datum(cosData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '8,4');

        // 标签
        g.append('text')
            .attr('x', xScale(Math.PI/4))
            .attr('y', yScale(Math.sin(Math.PI/4)) - 10)
            .text('sin(x)')
            .attr('font-size', '16px')
            .attr('fill', '#3498db');

        g.append('text')
            .attr('x', xScale(0))
            .attr('y', yScale(1) - 10)
            .text('cos(x) = (sin x)\'')
            .attr('font-size', '16px')
            .attr('fill', '#e74c3c');

        // 动画点
        const point1 = g.append('circle')
            .attr('r', 6)
            .attr('fill', '#3498db');

        const point2 = g.append('circle')
            .attr('r', 6)
            .attr('fill', '#e74c3c');

        let t = 0;
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }

            t += 0.02 / globalAnimationSpeed;
            const x = -Math.PI + (t % 1) * 2 * Math.PI;

            point1
                .attr('cx', xScale(x))
                .attr('cy', yScale(Math.sin(x)));

            point2
                .attr('cx', xScale(x))
                .attr('cy', yScale(Math.cos(x)));

            registerAnimation(animate, requestAnimationFrame(animate));
        }
        
        animate();
    }

    // 第13页：加法法则
    function visualizeAdditionRule() {
        const setup = setupD3('vis-addition-rule');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-2, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 15]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // f(x) = x^2 和 g(x) = 3x
        const data = d3.range(-2, 3.1, 0.05);
        
        const f = x => x * x;
        const gFunc = x => 3 * x;
        const sum = x => f(x) + gFunc(x);

        const line = d3.line()
            .x(d => xScale(d))
            .y(d => yScale(func(d)))
            .curve(d3.curveMonotoneX);

        // 绘制 f(x)
        let func = f;
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 2)
            .attr('opacity', 0.5);

        // 绘制 g(x)
        func = gFunc;
        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 2)
            .attr('opacity', 0.5);

        // 绘制 f(x) + g(x)
        func = sum;
        const sumPath = g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 4);

        // 动画
        const totalLength = sumPath.node().getTotalLength();
        sumPath
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .delay(1000)
            .duration(2000)
            .attr('stroke-dashoffset', 0);

        // 标签
        g.append('text')
            .attr('x', xScale(1.5))
            .attr('y', yScale(f(1.5)))
            .text('x²')
            .attr('font-size', '16px')
            .attr('fill', '#3498db');

        g.append('text')
            .attr('x', xScale(2))
            .attr('y', yScale(gFunc(2)))
            .text('3x')
            .attr('font-size', '16px')
            .attr('fill', '#e74c3c');

        g.append('text')
            .attr('x', xScale(1))
            .attr('y', yScale(sum(1)) + 20)
            .text('x² + 3x')
            .attr('font-size', '18px')
            .attr('fill', '#2ecc71')
            .attr('opacity', 0)
            .transition()
            .delay(2000)
            .duration(1000)
            .attr('opacity', 1);
    }

    // 第14页：乘法法则
    function visualizeProductRule() {
        const setup = setupD3('vis-product-rule');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建演示区域
        const demoArea = g.append('g')
            .attr('transform', `translate(${width/2}, ${height/3})`);

        // 公式展示
        const formula = demoArea.append('text')
            .attr('text-anchor', 'middle')
            .attr('font-size', '26px')
            .attr('fill', themeColors.text)
            .text('[x² · sin(x)]′');

        // 步骤展示
        const steps = [
            { text: '= (x²)′ · sin(x) + x² · (sin x)′', delay: 1000 },
            { text: '= 2x · sin(x) + x² · cos(x)', delay: 2000 },
            { text: '= x(2sin(x) + x·cos(x))', delay: 3000 }
        ];

        steps.forEach((step, i) => {
            demoArea.append('text')
                .attr('x', 0)
                .attr('y', 50 + i * 45)
                .attr('text-anchor', 'middle')
                .attr('font-size', '22px')
                .attr('fill', themeColors.text)
                .text(step.text)
                .attr('opacity', 0)
                .transition()
                .delay(step.delay)
                .duration(500)
                .attr('opacity', 0.8);
        });
    }

    // 第15页：除法法则
    function visualizeQuotientRule() {
        const setup = setupD3('vis-quotient-rule');
        if (!setup) return;
        const { g, width, height } = setup;

        // 分步展示除法法则
        const steps = [
            { formula: 'y = x²/(x+1)', y: 50 },
            { formula: "y' = ?", y: 100 },
            { formula: "分子导数: (x²)' = 2x", y: 150 },
            { formula: "分母导数: (x+1)' = 1", y: 200 },
            { formula: "y' = [2x(x+1) - x²·1]/(x+1)²", y: 250 },
            { formula: "y' = (x² + 2x)/(x+1)²", y: 300 }
        ];

        steps.forEach((step, i) => {
            g.append('text')
                .attr('x', width / 2)
                .attr('y', step.y)
                .attr('text-anchor', 'middle')
                .attr('font-size', '22px')
                .attr('fill', i === 0 ? '#3498db' : (i === steps.length - 1 ? '#2ecc71' : themeColors.text))
                .text(step.formula)
                .attr('opacity', 0)
                .transition()
                .delay(i * 800)
                .duration(500)
                .attr('opacity', 1);
        });
    }

    // 第16页：链式法则
    function visualizeChainRule() {
        const setup = setupD3('vis-chain-rule');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建流程图
        const boxWidth = 140;
        const boxHeight = 70;
        const spacing = 100;

        const boxes = [
            { x: width/2 - boxWidth - spacing, y: height/3, text: '内函数\n2x+1', color: '#3498db' },
            { x: width/2 + spacing, y: height/3, text: '外函数\nu³', color: '#e74c3c' },
            { x: width/2 - boxWidth/2, y: 2*height/3, text: '结果\n6(2x+1)²', color: '#2ecc71' }
        ];

        boxes.forEach((box, i) => {
            const boxG = g.append('g')
                .attr('transform', `translate(${box.x}, ${box.y})`)
                .attr('opacity', 0);

            boxG.append('rect')
                .attr('width', boxWidth)
                .attr('height', boxHeight)
                .attr('fill', box.color)
                .attr('fill-opacity', 0.3)
                .attr('stroke', box.color)
                .attr('stroke-width', 3)
                .attr('rx', 10);

            const lines = box.text.split('\n');
            lines.forEach((line, j) => {
                boxG.append('text')
                    .attr('x', boxWidth / 2)
                    .attr('y', boxHeight / 2 + (j - 0.5) * 25)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '18px')
                    .attr('fill', themeColors.text)
                    .text(line);
            });

            // 淡入动画
            boxG.transition()
                .delay(i * 500)
                .duration(800)
                .attr('opacity', 1);
        });

        // 定义箭头标记
        g.append('defs').append('marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 8)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', themeColors.text);

        // 箭头
        setTimeout(() => {
            // 横向箭头
            g.append('path')
                .attr('d', `M ${boxes[0].x + boxWidth} ${boxes[0].y + boxHeight/2} 
                           L ${boxes[1].x - 10} ${boxes[1].y + boxHeight/2}`)
                .attr('stroke', themeColors.axis)
                .attr('stroke-width', 2)
                .attr('marker-end', 'url(#arrowhead)')
                .attr('opacity', 0)
                .transition()
                .duration(500)
                .attr('opacity', 1);

            // 垂直箭头
            [0, 1].forEach(i => {
                g.append('path')
                    .attr('d', `M ${boxes[i].x + boxWidth/2} ${boxes[i].y + boxHeight} 
                               L ${boxes[2].x + boxWidth/2} ${boxes[2].y - 10}`)
                    .attr('stroke', themeColors.axis)
                    .attr('stroke-width', 2)
                    .attr('marker-end', 'url(#arrowhead)')
                    .attr('opacity', 0)
                    .transition()
                    .delay(200 * i)
                    .duration(500)
                    .attr('opacity', 1);
            });
        }, 1500);
    }

    // 第18页：反三角函数导数
    function visualizeInverseTrig() {
        const setup = setupD3('vis-inverse-trig');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-1.5, 1.5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-2, 2]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // arctan函数
        const arctanFunc = x => Math.atan(x);
        const arctanData = d3.range(-1.5, 1.51, 0.05).map(x => ({x: x, y: arctanFunc(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(arctanData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);

        // arctan'(x) = 1/(1+x^2)
        const derivFunc = x => 1 / (1 + x * x);
        const derivData = d3.range(-1.5, 1.51, 0.05).map(x => ({x: x, y: derivFunc(x)}));

        g.append('path')
            .datum(derivData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5');

        // 图例
        const legend = g.append('g')
            .attr('transform', `translate(${width - 150}, 20)`);

        legend.append('line')
            .attr('x1', 0).attr('y1', 0)
            .attr('x2', 40).attr('y2', 0)
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);

        legend.append('text')
            .attr('x', 50).attr('y', 5)
            .attr('fill', themeColors.text)
            .text('y = arctan x');

        legend.append('line')
            .attr('x1', 0).attr('y1', 25)
            .attr('x2', 40).attr('y2', 25)
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5');

        legend.append('text')
            .attr('x', 50).attr('y', 30)
            .attr('fill', themeColors.text)
            .text("y' = 1/(1+x²)");
    }

    // 第19页：隐函数求导概念
    function visualizeImplicitConcept() {
        const setup = setupD3('vis-implicit-concept');
        if (!setup) return;
        const { g, width, height } = setup;

        // 显示对比文本
        const textData = [
            { x: width/4, y: height/3, title: '显函数', formula: 'y = f(x)', example: 'y = x² + 3x', color: '#3498db' },
            { x: 3*width/4, y: height/3, title: '隐函数', formula: 'F(x,y) = 0', example: 'x² + y² = r²', color: '#e74c3c' }
        ];

        textData.forEach(item => {
            const boxG = g.append('g').attr('transform', `translate(${item.x - 100}, ${item.y})`);

            boxG.append('rect')
                .attr('width', 200)
                .attr('height', 120)
                .attr('fill', item.color)
                .attr('fill-opacity', 0.1)
                .attr('stroke', item.color)
                .attr('stroke-width', 2)
                .attr('rx', 10);

            boxG.append('text')
                .attr('x', 100).attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('font-size', '20px')
                .attr('font-weight', 'bold')
                .attr('fill', item.color)
                .text(item.title);

            boxG.append('text')
                .attr('x', 100).attr('y', 60)
                .attr('text-anchor', 'middle')
                .attr('font-size', '16px')
                .attr('fill', themeColors.text)
                .text(item.formula);

            boxG.append('text')
                .attr('x', 100).attr('y', 90)
                .attr('text-anchor', 'middle')
                .attr('font-size', '14px')
                .attr('fill', themeColors.muted)
                .text(item.example);
        });
    }

    // 第20页：隐函数求导 - 圆 (交互式)
    function visualizeImplicitCircle() {
        const setup = setupD3('vis-implicit-circle');
        if (!setup) return;
        const { g, width, height } = setup;

        const R = 2;
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);
        const r_pixels = xScale(R) - xScale(0);

        // 坐标轴
        g.append('g').attr('transform', `translate(0, ${yScale(0)})`).call(d3.axisBottom(xScale)).style('color', themeColors.text);
        g.append('g').attr('transform', `translate(${xScale(0)}, 0)`).call(d3.axisLeft(yScale)).style('color', themeColors.text);

        // 圆
        g.append('circle')
            .attr('cx', xScale(0))
            .attr('cy', yScale(0))
            .attr('r', r_pixels)
            .attr('fill', 'rgba(52, 152, 219, 0.1)')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);

        // 可拖动点
        const point = g.append('circle')
            .attr('class', 'dynamic-point')
            .attr('r', 10)
            .attr('fill', '#e74c3c')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .style('cursor', 'pointer');
        
        // 切线
        const tangentLine = g.append('line')
            .attr('class', 'dynamic-tangent')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 2.5);

        // 信息文本 using foreignObject
        const fo = g.append('foreignObject')
            .attr('x', 10)
            .attr('y', 10)
            .attr('width', width - 20)
            .attr('height', 100);

        const infoDiv = fo.append('xhtml:div')
            .style('font-size', '14px')
            .style('color', themeColors.text)
            .attr('class', 'tex2jax_process');

        function updateTangent(x0, y0) {
            point.attr('cx', xScale(x0)).attr('cy', yScale(y0));
            
            const slopeValue = (Math.abs(y0) > 1e-6) ? (-x0 / y0).toFixed(2) : "\\infty";
            infoDiv.html(`点: (${x0.toFixed(2)}, ${y0.toFixed(2)}) | 切线斜率 \\(y' = -\\frac{x}{y} = ${slopeValue}\\)`);

            // Re-typeset the specific element that has been updated.
            if (mathjaxReady) {
                MathJax.typesetPromise([infoDiv.node()]).catch(err => console.error('Dynamic MathJax render failed:', err));
            }

            if (Math.abs(y0) > 0.05) {
                const slope = -x0 / y0;
                const length = 1.5;
                const angle = Math.atan(slope);
                const dx = length * Math.cos(angle);
                const dy = length * Math.sin(angle);

                tangentLine
                    .attr('x1', xScale(x0 - dx))
                    .attr('y1', yScale(y0 - dy))
                    .attr('x2', xScale(x0 + dx))
                    .attr('y2', yScale(y0 + dy))
                    .attr('opacity', 1);
            } else {
                tangentLine.attr('opacity', 0); // Hide for vertical tangent
            }
        }

        const dragHandler = d3.drag()
            .on('drag', function(event) {
                const [mx, my] = [xScale.invert(event.x), yScale.invert(event.y)];
                const angle = Math.atan2(my, mx);
                const newX = R * Math.cos(angle);
                const newY = R * Math.sin(angle);
                updateTangent(newX, newY);
            });

        point.call(dragHandler);

        // 初始位置
        updateTangent(R * Math.cos(Math.PI / 4), R * Math.sin(Math.PI / 4));
    }

    // 第21页：隐函数求导 - 椭圆
    function visualizeImplicitEllipse() {
        const setup = setupD3('vis-implicit-ellipse');
        if (!setup) return;
        const { g, width, height } = setup;

        const a = 3, b = 2; // 椭圆参数
        const xScale = d3.scaleLinear().domain([-4, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // 椭圆 x²/9 + y²/4 = 1
        const ellipseData = d3.range(0, 2 * Math.PI, 0.05).map(t => ({
            x: a * Math.cos(t),
            y: b * Math.sin(t)
        }));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));

        g.append('path')
            .datum(ellipseData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);

        // 特定点 (3/2, √3)
        const x0 = 1.5, y0 = Math.sqrt(3);

        g.append('circle')
            .attr('cx', xScale(x0))
            .attr('cy', yScale(y0))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2);

        // 切线 y' = -4x/(9y)
        const slope = -4 * x0 / (9 * y0);
        const x1 = x0 - 1.5;
        const y1 = y0 + slope * 1.5;
        const x2 = x0 + 1.5;
        const y2 = y0 - slope * 1.5;

        g.append('line')
            .attr('x1', xScale(x1))
            .attr('y1', yScale(y1))
            .attr('x2', xScale(x2))
            .attr('y2', yScale(y2))
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 2);

        // 法线
        const normalSlope = -1 / slope;
        const nx1 = x0 - 1;
        const ny1 = y0 + normalSlope * 1;
        const nx2 = x0 + 1;
        const ny2 = y0 - normalSlope * 1;

        g.append('line')
            .attr('x1', xScale(nx1))
            .attr('y1', yScale(ny1))
            .attr('x2', xScale(nx2))
            .attr('y2', yScale(ny2))
            .attr('stroke', '#2ecc71')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');

        // 标注
        g.append('text')
            .attr('x', xScale(x0) + 15)
            .attr('y', yScale(y0) - 15)
            .attr('fill', themeColors.text)
            .attr('font-size', '14px')
            .text(`(${x0.toFixed(1)}, ${y0.toFixed(2)})`);
    }

    // 第22页：隐函数求导 - 指数方程
    function visualizeImplicitExp() {
        const setup = setupD3('vis-implicit-exp');
        if (!setup) return;
        const { g, width, height } = setup;

        // 显示方程和求导步骤
        const steps = [
            { y: 50, text: '方程: eˣ + eʸ = eˣ⁺ʸ', color: '#3498db' },
            { y: 100, text: '两边求导: eˣ + eʸ·y\' = eˣ⁺ʸ·(1+y\')', color: '#e74c3c' },
            { y: 150, text: '整理得: y\'(eʸ - eˣ⁺ʸ) = eˣ⁺ʸ - eˣ', color: '#f39c12' },
            { y: 200, text: '在 x=0 时, y=0, y\'=1', color: '#2ecc71' }
        ];

        steps.forEach(step => {
            g.append('text')
                .attr('x', 20)
                .attr('y', step.y)
                .attr('fill', step.color)
                .attr('font-size', '16px')
                .text(step.text);
        });
    }

    // 第23页：参数方程求导 (Lissajous曲线)
    function visualizeParametric() {
        const setup = setupD3('vis-parametric');
        if (!setup) return;
        const { g, width, height } = setup;

        const A = 2.5, B = 2.5, a = 1, b = 2, delta = Math.PI / 2;
        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-3, 3]).range([height, 0]);

        // 坐标轴
        g.append('g').attr('transform', `translate(0, ${yScale(0)})`).call(d3.axisBottom(xScale)).style('color', themeColors.text);
        g.append('g').attr('transform', `translate(${xScale(0)}, 0)`).call(d3.axisLeft(yScale)).style('color', themeColors.text);

        // Lissajous curve: x=A·sin(at+δ), y=B·sin(bt)
        const fx = t => A * Math.sin(a * t + delta);
        const fy = t => B * Math.sin(b * t);
        const curveData = d3.range(0, 2 * Math.PI, 0.02).map(t => ({ x: fx(t), y: fy(t) }));
        
        const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y));

        const path = g.append('path')
            .datum(curveData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);
        
        const totalLength = path.node().getTotalLength();
        path.attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition().duration(2000).ease(d3.easeLinear)
            .attr('stroke-dashoffset', 0);

        // 动画点和切线
        const point = g.append('circle').attr('r', 8).attr('fill', '#e74c3c');
        const tangent = g.append('line').attr('stroke', '#f39c12').attr('stroke-width', 2);

        let t = 0;
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }
            t += 0.015 * globalAnimationSpeed;
            
            const x0 = fx(t);
            const y0 = fy(t);
            
            // Derivatives: dx/dt = A·a·cos(at+δ), dy/dt = B·b·cos(bt)
            const dxdt = A * a * Math.cos(a * t + delta);
            const dydt = B * b * Math.cos(b * t);
            
            point.attr('cx', xScale(x0)).attr('cy', yScale(y0));

            if (Math.abs(dxdt) > 0.05) {
                const slope = dydt / dxdt;
                const length = 1;
                const angle = Math.atan(slope);
                const dx = length * Math.cos(angle);
                const dy = length * Math.sin(angle);

                tangent
                    .attr('x1', xScale(x0 - dx))
                    .attr('y1', yScale(y0 - dy))
                    .attr('x2', xScale(x0 + dx))
                    .attr('y2', yScale(y0 + dy))
                    .attr('opacity', 1);
            } else {
                tangent.attr('opacity', 0); // Vertical tangent
            }
            
            registerAnimation(animate, requestAnimationFrame(animate));
        }
        setTimeout(animate, 2000);
    }

    // 第24页：摆线（Cycloid）
    function visualizeCycloid() {
        const setup = setupD3('vis-cycloid');
        if (!setup) return;
        const { g, width, height } = setup;

        const a = 50; // 摆线参数
        const xScale = d3.scaleLinear().domain([0, 4 * Math.PI]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-0.5, 2.5]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale).tickFormat(d => (d/Math.PI).toFixed(1) + 'π'))
            .style('color', themeColors.text);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // 摆线: x = a(t - sin t), y = a(1 - cos t)
        const cycloidData = d3.range(0, 2 * Math.PI, 0.05).map(t => ({
            x: t - Math.sin(t),
            y: 1 - Math.cos(t),
            t: t
        }));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y));

        g.append('path')
            .datum(cycloidData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);

        // t = π/2 处的点和切线
        const t0 = Math.PI / 2;
        const x0 = t0 - Math.sin(t0);
        const y0 = 1 - Math.cos(t0);

        g.append('circle')
            .attr('cx', xScale(x0))
            .attr('cy', yScale(y0))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2);

        // dy/dx = sin(t) / (1 - cos(t)) = 1 at t=π/2
        const slope = 1;
        const x1 = x0 - 0.5;
        const y1 = y0 + slope * 0.5;
        const x2 = x0 + 0.5;
        const y2 = y0 - slope * 0.5;

        g.append('line')
            .attr('x1', xScale(x1))
            .attr('y1', yScale(y1))
            .attr('x2', xScale(x2))
            .attr('y2', yScale(y2))
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 2);

        // 标注
        g.append('text')
            .attr('x', xScale(x0) + 15)
            .attr('y', yScale(y0))
            .attr('fill', themeColors.text)
            .attr('font-size', '14px')
            .text(`t = π/2`);
    }

    // 第25页：对数求导法
    function visualizeLogarithmicDiff() {
        const setup = setupD3('vis-logarithmic-diff');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([0.1, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 20]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // y = x^x
        const func = x => Math.pow(x, x);
        const funcData = d3.range(0.1, 3, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(funcData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#3498db')
            .attr('stroke-width', 3);

        // y' = x^x(ln x + 1)
        const derivFunc = x => Math.pow(x, x) * (Math.log(x) + 1);
        const derivData = d3.range(0.1, 3, 0.05).map(x => ({x: x, y: derivFunc(x)}));

        g.append('path')
            .datum(derivData)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#e74c3c')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5');

        // 图例
        g.append('text')
            .attr('x', width - 150)
            .attr('y', 30)
            .attr('fill', '#3498db')
            .attr('font-size', '14px')
            .text('y = xˣ');

        g.append('text')
            .attr('x', width - 150)
            .attr('y', 50)
            .attr('fill', '#e74c3c')
            .attr('font-size', '14px')
            .text("y' = xˣ(ln x + 1)");
    }

    // 第26页：对数求导法例题2
    function visualizeLogarithmicDiff2() {
        const setup = setupD3('vis-logarithmic-diff2');
        if (!setup) return;
        const { g, width, height } = setup;

        // 显示求导步骤
        const steps = [
            { y: 50, text: 'y = (x+1)(x+2) / [(x+3)(x+4)]', color: '#3498db' },
            { y: 100, text: 'ln y = ln(x+1) + ln(x+2) - ln(x+3) - ln(x+4)', color: '#e74c3c' },
            { y: 150, text: 'y\'/y = 1/(x+1) + 1/(x+2) - 1/(x+3) - 1/(x+4)', color: '#f39c12' },
            { y: 200, text: 'y\' = y·[1/(x+1) + 1/(x+2) - 1/(x+3) - 1/(x+4)]', color: '#2ecc71' }
        ];

        steps.forEach((step, i) => {
            g.append('text')
                .attr('x', 20)
                .attr('y', step.y)
                .attr('fill', step.color)
                .attr('font-size', '16px')
                .attr('opacity', 0)
                .text(step.text)
                .transition()
                .delay(i * 800)
                .duration(500)
                .attr('opacity', 1);
        });
    }

    // 第27页：高阶导数
    function visualizeHigherOrder() {
        const setup = setupD3('vis-higher-order');
        if (!setup) return;
        const { g, width, height } = setup;

        const xScale = d3.scaleLinear().domain([-3, 3]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-30, 30]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text);

        // 函数 f(x) = x^3
        const data = d3.range(-3, 3.1, 0.05);
        
        const functions = [
            { func: x => x * x * x, label: 'f(x) = x³', color: '#3498db' },
            { func: x => 3 * x * x, label: "f'(x) = 3x²", color: '#e74c3c' },
            { func: x => 6 * x, label: "f''(x) = 6x", color: '#2ecc71' },
            { func: x => 6, label: "f'''(x) = 6", color: '#f39c12' }
        ];

        functions.forEach((f, i) => {
            const funcData = data.map(x => ({x: x, y: f.func(x)}));

            const line = d3.line()
                .x(d => xScale(d.x))
                .y(d => yScale(d.y))
                .curve(d3.curveMonotoneX)
                .defined(d => d.y >= -30 && d.y <= 30);

            const path = g.append('path')
                .datum(funcData)
                .attr('d', line)
                .attr('fill', 'none')
                .attr('stroke', f.color)
                .attr('stroke-width', 3)
                .attr('opacity', 0);

            // 渐入动画
            path.transition()
                .delay(i * 800)
                .duration(1000)
                .attr('opacity', 0.7 + i * 0.1);

            // 标签
            g.append('text')
                .attr('x', 20)
                .attr('y', 30 + i * 30)
                .text(f.label)
                .attr('font-size', '16px')
                .attr('fill', f.color)
                .attr('opacity', 0)
                .transition()
                .delay(i * 800 + 500)
                .duration(500)
                .attr('opacity', 1);
        });
    }

    // 第20页：罗尔定理演示
    // 用户需求：展示罗尔定理的几何意义
    function visualizeRolle() {
        const setup = setupD3('vis-rolle');
        if (!setup) return;
        const { g, width, height } = setup;

        // 用户需求：坐标系设计必须正确，交点是(0,0)
        const xScale = d3.scaleLinear().domain([-1, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-1, 5]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        // 满足罗尔定理的函数：f(x) = -(x-1)(x-3) + 2
        const a = 1, b = 3;
        const func = x => -(x - 1) * (x - 3) + 2;
        const data = d3.range(0.5, 3.6, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 3);

        // 端点 A(1, 2) 和 B(3, 2)
        g.append('circle')
            .attr('cx', xScale(a))
            .attr('cy', yScale(func(a)))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        g.append('circle')
            .attr('cx', xScale(b))
            .attr('cy', yScale(func(b)))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        // 标注端点
        g.append('text')
            .attr('x', xScale(a))
            .attr('y', yScale(func(a)) - 15)
            .attr('text-anchor', 'middle')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px')
            .text('A');

        g.append('text')
            .attr('x', xScale(b))
            .attr('y', yScale(func(b)) - 15)
            .attr('text-anchor', 'middle')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px')
            .text('B');

        // ξ点（导数为0的点，在x=2处）
        const xi = 2;
        const xiPoint = g.append('circle')
            .attr('cx', xScale(xi))
            .attr('cy', yScale(func(xi)))
            .attr('r', 10)
            .attr('fill', '#2ecc71')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 0 10px rgba(46, 204, 113, 0.8))');

        // 水平切线
        const tangentLine = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3)
            .style('filter', 'drop-shadow(0 0 8px rgba(243, 156, 18, 0.6))');

        // 标注ξ
        g.append('text')
            .attr('x', xScale(xi))
            .attr('y', yScale(func(xi)) + 25)
            .attr('text-anchor', 'middle')
            .attr('fill', '#2ecc71')
            .attr('font-size', '18px')
            .text('ξ (f\'(ξ) = 0)');

        // 动画：切线延伸
        let t = 0;
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }

            t += 0.01 / globalAnimationSpeed;
            const extend = 0.5 + Math.abs(Math.sin(t)) * 1.5;

            tangentLine
                .attr('x1', xScale(xi - extend))
                .attr('y1', yScale(func(xi)))
                .attr('x2', xScale(xi + extend))
                .attr('y2', yScale(func(xi)));

            registerAnimation(animate, requestAnimationFrame(animate));
        }

        animate();
    }

    // 第21页：拉格朗日中值定理演示
    // 用户需求：展示拉格朗日中值定理的几何意义
    function visualizeLagrange() {
        const setup = setupD3('vis-lagrange');
        if (!setup) return;
        const { g, width, height } = setup;

        // 用户需求：坐标系设计必须正确，交点是(0,0)
        const xScale = d3.scaleLinear().domain([-1, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-1, 6]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        // 函数 f(x) = 0.3(x-1)^2 + 1
        const a = 1, b = 4;
        const func = x => 0.3 * (x - 1) * (x - 1) + 1;
        const data = d3.range(0.5, 4.6, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 3);

        // 端点 A 和 B
        g.append('circle')
            .attr('cx', xScale(a))
            .attr('cy', yScale(func(a)))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        g.append('circle')
            .attr('cx', xScale(b))
            .attr('cy', yScale(func(b)))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        // 弦AB
        g.append('line')
            .attr('x1', xScale(a))
            .attr('y1', yScale(func(a)))
            .attr('x2', xScale(b))
            .attr('y2', yScale(func(b)))
            .attr('stroke', '#95a5a6')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');

        // 标注
        g.append('text')
            .attr('x', xScale(a))
            .attr('y', yScale(func(a)) - 15)
            .attr('text-anchor', 'middle')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px')
            .text('A');

        g.append('text')
            .attr('x', xScale(b))
            .attr('y', yScale(func(b)) - 15)
            .attr('text-anchor', 'middle')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px')
            .text('B');

        // ξ点（切线平行于弦的点）
        // f'(x) = 0.6(x-1)，令 f'(ξ) = (f(b)-f(a))/(b-a)
        const chordSlope = (func(b) - func(a)) / (b - a);
        const xi = chordSlope / 0.6 + 1; // 约2.5

        const xiPoint = g.append('circle')
            .attr('cx', xScale(xi))
            .attr('cy', yScale(func(xi)))
            .attr('r', 10)
            .attr('fill', '#2ecc71')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 0 10px rgba(46, 204, 113, 0.8))');

        // 切线（平行于弦）
        const tangentLine = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3)
            .style('filter', 'drop-shadow(0 0 8px rgba(243, 156, 18, 0.6))');

        // 标注ξ
        g.append('text')
            .attr('x', xScale(xi))
            .attr('y', yScale(func(xi)) + 25)
            .attr('text-anchor', 'middle')
            .attr('fill', '#2ecc71')
            .attr('font-size', '16px')
            .text('ξ');

        // 动画：切线延伸
        let t = 0;
        function animate() {
            if (!globalAnimationPlaying) {
                registerAnimation(animate, requestAnimationFrame(animate));
                return;
            }

            t += 0.01 / globalAnimationSpeed;
            const extend = 0.5 + Math.abs(Math.sin(t)) * 1.5;

            const tx1 = xi - extend;
            const tx2 = xi + extend;
            const ty1 = func(xi) + chordSlope * (tx1 - xi);
            const ty2 = func(xi) + chordSlope * (tx2 - xi);

            tangentLine
                .attr('x1', xScale(tx1))
                .attr('y1', yScale(ty1))
                .attr('x2', xScale(tx2))
                .attr('y2', yScale(ty2));

            registerAnimation(animate, requestAnimationFrame(animate));
        }

        animate();
    }

    // 第22页：拉格朗日中值定理例题演示
    // 用户需求：展示例题的求解过程
    function visualizeLagrangeExample() {
        const setup = setupD3('vis-lagrange-example');
        if (!setup) return;
        const { g, width, height } = setup;

        // 用户需求：坐标系设计必须正确，交点是(0,0)
        const xScale = d3.scaleLinear().domain([0, 4]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 10]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        // 函数 f(x) = x^2
        const a = 1, b = 3;
        const func = x => x * x;
        const data = d3.range(0, 4.1, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 3);

        // 端点 (1, 1) 和 (3, 9)
        g.append('circle')
            .attr('cx', xScale(a))
            .attr('cy', yScale(func(a)))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        g.append('circle')
            .attr('cx', xScale(b))
            .attr('cy', yScale(func(b)))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        // 弦
        g.append('line')
            .attr('x1', xScale(a))
            .attr('y1', yScale(func(a)))
            .attr('x2', xScale(b))
            .attr('y2', yScale(func(b)))
            .attr('stroke', '#95a5a6')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');

        // ξ = 2
        const xi = 2;
        g.append('circle')
            .attr('cx', xScale(xi))
            .attr('cy', yScale(func(xi)))
            .attr('r', 10)
            .attr('fill', '#2ecc71')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 0 10px rgba(46, 204, 113, 0.8))');

        // 切线（斜率=4）
        const slope = 4;
        g.append('line')
            .attr('x1', xScale(0.5))
            .attr('y1', yScale(func(xi) + slope * (0.5 - xi)))
            .attr('x2', xScale(3.5))
            .attr('y2', yScale(func(xi) + slope * (3.5 - xi)))
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3);

        // 标注
        g.append('text')
            .attr('x', xScale(a) - 10)
            .attr('y', yScale(func(a)))
            .attr('text-anchor', 'end')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px')
            .text('(1, 1)');

        g.append('text')
            .attr('x', xScale(b) + 10)
            .attr('y', yScale(func(b)))
            .attr('text-anchor', 'start')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px')
            .text('(3, 9)');

        g.append('text')
            .attr('x', xScale(xi))
            .attr('y', yScale(func(xi)) - 15)
            .attr('text-anchor', 'middle')
            .attr('fill', '#2ecc71')
            .attr('font-size', '18px')
            .text('ξ = 2');
    }

    // 第23页：柯西中值定理演示
    // 用户需求：展示柯西中值定理的几何意义
    function visualizeCauchy() {
        const setup = setupD3('vis-cauchy');
        if (!setup) return;
        const { g, width, height } = setup;

        // 用户需求：坐标系设计必须正确，交点是(0,0)
        const xScale = d3.scaleLinear().domain([-1, 5]).range([0, width]);
        const yScale = d3.scaleLinear().domain([-1, 5]).range([height, 0]);

        // 坐标轴
        g.append('g')
            .attr('transform', `translate(0, ${yScale(0)})`)
            .call(d3.axisBottom(xScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        g.append('g')
            .attr('transform', `translate(${xScale(0)}, 0)`)
            .call(d3.axisLeft(yScale))
            .style('color', themeColors.text)
            .selectAll('line, path')
            .attr('stroke', themeColors.axis);

        // 参数曲线：x = g(t) = t, y = f(t) = t^2
        const tMin = 0.5, tMax = 3;
        const f = t => t * t;
        const gFunc = t => t;

        const data = d3.range(tMin, tMax + 0.05, 0.05).map(t => ({
            x: gFunc(t),
            y: f(t)
        }));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 3);

        // 端点
        const tA = 1, tB = 2.5;
        g.append('circle')
            .attr('cx', xScale(gFunc(tA)))
            .attr('cy', yScale(f(tA)))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        g.append('circle')
            .attr('cx', xScale(gFunc(tB)))
            .attr('cy', yScale(f(tB)))
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        // 弦
        g.append('line')
            .attr('x1', xScale(gFunc(tA)))
            .attr('y1', yScale(f(tA)))
            .attr('x2', xScale(gFunc(tB)))
            .attr('y2', yScale(f(tB)))
            .attr('stroke', '#95a5a6')
            .attr('stroke-width', 2)
            .attr('stroke-dasharray', '5,5');

        // ξ点
        const xi = 1.75;
        g.append('circle')
            .attr('cx', xScale(gFunc(xi)))
            .attr('cy', yScale(f(xi)))
            .attr('r', 10)
            .attr('fill', '#2ecc71')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 0 10px rgba(46, 204, 113, 0.8))');

        // 切线
        const fPrime = t => 2 * t;
        const gPrime = t => 1;
        const slope = fPrime(xi) / gPrime(xi);

        g.append('line')
            .attr('x1', xScale(gFunc(xi) - 1))
            .attr('y1', yScale(f(xi) + slope * (-1)))
            .attr('x2', xScale(gFunc(xi) + 1))
            .attr('y2', yScale(f(xi) + slope * 1))
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3);

        // 标注
        g.append('text')
            .attr('x', xScale(gFunc(tA)) - 10)
            .attr('y', yScale(f(tA)))
            .attr('text-anchor', 'end')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px')
            .text('A');

        g.append('text')
            .attr('x', xScale(gFunc(tB)) + 10)
            .attr('y', yScale(f(tB)))
            .attr('text-anchor', 'start')
            .attr('fill', themeColors.text)
            .attr('font-size', '16px')
            .text('B');

        g.append('text')
            .attr('x', xScale(gFunc(xi)))
            .attr('y', yScale(f(xi)) - 15)
            .attr('text-anchor', 'middle')
            .attr('fill', '#2ecc71')
            .attr('font-size', '16px')
            .text('ξ');
    }

    // 第24页：练习总结
    function visualizePractice() {
        const setup = setupD3('vis-practice');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建练习题卡片
        const cards = [
            { 
                question: 'y = 3x² + 2x - 1',
                answer: "y' = 6x + 2",
                x: width * 0.25,
                y: height * 0.3
            },
            {
                question: 'y = e^x · cos(x)',
                answer: "y' = e^x(cos x - sin x)",
                x: width * 0.75,
                y: height * 0.3
            },
            {
                question: 'y = ln(x²+1)',
                answer: "y' = 2x/(x²+1)",
                x: width * 0.25,
                y: height * 0.7
            },
            {
                question: 'y = sin(3x)',
                answer: "y' = 3cos(3x)",
                x: width * 0.75,
                y: height * 0.7
            }
        ];

        cards.forEach((card, i) => {
            const cardG = g.append('g')
                .attr('transform', `translate(${card.x - 120}, ${card.y - 60})`);

            // 卡片背景
            const rect = cardG.append('rect')
                .attr('width', 240)
                .attr('height', 120)
                .attr('fill', 'rgba(255, 255, 255, 0.1)')
                .attr('stroke', themeColors.axis)
                .attr('stroke-width', 2)
                .attr('rx', 15)
                .style('filter', 'drop-shadow(0 4px 8px rgba(15, 23, 42, 0.2))');

            // 题目
            cardG.append('text')
                .attr('x', 120)
                .attr('y', 40)
                .attr('text-anchor', 'middle')
                .attr('font-size', '18px')
                .attr('fill', themeColors.text)
                .text(card.question);

            // 答案（延迟显示）
            const answer = cardG.append('text')
                .attr('x', 120)
                .attr('y', 80)
                .attr('text-anchor', 'middle')
                .attr('font-size', '18px')
                .attr('fill', '#2ecc71')
                .text(card.answer)
                .attr('opacity', 0);

            // 鼠标悬停效果
            rect.on('mouseover', function() {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('fill', 'rgba(255, 255, 255, 0.2)');
                
                answer.transition()
                    .duration(300)
                    .attr('opacity', 1);
            })
            .on('mouseout', function() {
                d3.select(this)
                    .transition()
                    .duration(200)
                    .attr('fill', 'rgba(255, 255, 255, 0.1)');
                
                answer.transition()
                    .duration(300)
                    .attr('opacity', 0);
            });

            // 卡片入场动画
            cardG
                .attr('opacity', 0)
                .attr('transform', `translate(${card.x - 120}, ${card.y - 40})`)
                .transition()
                .delay(i * 300)
                .duration(600)
                .attr('opacity', 1)
                .attr('transform', `translate(${card.x - 120}, ${card.y - 60})`)
                .ease(d3.easeBounceOut);
        });
    }

    // 第5页：导数定义
    function visualizeDerivativeDef() {
        const setup = setupD3('vis-derivative-def');
        if (!setup) return;
        const { g, width, height } = setup;

        // 创建三个展示区域
        const sections = [
            { title: '函数图像', x: 0, y: 0, w: width/3, h: height },
            { title: '切线斜率', x: width/3, y: 0, w: width/3, h: height },
            { title: '导数值', x: 2*width/3, y: 0, w: width/3, h: height }
        ];

        sections.forEach(section => {
            const group = g.append('g')
                .attr('transform', `translate(${section.x}, ${section.y})`);

            // 标题
            group.append('text')
                .attr('x', section.w / 2)
                .attr('y', 25)
                .attr('text-anchor', 'middle')
                .attr('font-size', '18px')
                .attr('font-weight', 'bold')
                .attr('fill', themeColors.text)
                .text(section.title);

            // 边框
            group.append('rect')
                .attr('x', 5)
                .attr('y', 35)
                .attr('width', section.w - 10)
                .attr('height', section.h - 45)
                .attr('fill', 'none')
                .attr('stroke', 'rgba(255, 255, 255, 0.3)')
                .attr('stroke-width', 1)
                .attr('rx', 5);
        });

        // 在第一个区域绘制函数
        const func = x => x * x;
        const xScale = d3.scaleLinear().domain([-2, 2]).range([10, width/3 - 10]);
        const yScale = d3.scaleLinear().domain([0, 4]).range([height - 45, 45]);

        const data = d3.range(-2, 2.1, 0.05).map(x => ({x: x, y: func(x)}));

        const line = d3.line()
            .x(d => xScale(d.x))
            .y(d => yScale(d.y))
            .curve(d3.curveMonotoneX);

        g.append('path')
            .datum(data)
            .attr('d', line)
            .attr('fill', 'none')
            .attr('stroke', '#667eea')
            .attr('stroke-width', 3);

        // 点和切线动画
        let currentX = 0;
        const point = g.append('circle')
            .attr('r', 8)
            .attr('fill', '#e74c3c')
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2);

        const tangentLine = g.append('line')
            .attr('stroke', '#f39c12')
            .attr('stroke-width', 3)
            .attr('stroke-dasharray', '5,5');

        function updateDerivative() {
            currentX = Math.sin(Date.now() * 0.0005) * 1.5;
            const y = func(currentX);
            const slope = 2 * currentX; // f'(x) = 2x

            // 更新点
            point.attr('cx', xScale(currentX))
                .attr('cy', yScale(y));

            // 更新切线
            // 用户需求：切线计算必须正确
            const tangentX1 = -2;
            const tangentX2 = 2;
            // 点斜式：y = y0 + slope * (x - x0)
            const tangentY1 = y + slope * (tangentX1 - currentX);
            const tangentY2 = y + slope * (tangentX2 - currentX);

            tangentLine
                .attr('x1', xScale(tangentX1))
                .attr('y1', yScale(tangentY1))
                .attr('x2', xScale(tangentX2))
                .attr('y2', yScale(tangentY2));

            // 在第二个区域显示斜率
            g.select('#slope-display').remove();
            g.append('text')
                .attr('id', 'slope-display')
                .attr('x', width/2)
                .attr('y', height/2)
                .attr('text-anchor', 'middle')
                .attr('font-size', '28px')
                .attr('fill', '#f39c12')
                .text(`斜率 = ${slope.toFixed(2)}`);

            // 在第三个区域显示导数
            g.select('#derivative-display').remove();
            g.append('text')
                .attr('id', 'derivative-display')
                .attr('x', 5*width/6)
                .attr('y', height/2)
                .attr('text-anchor', 'middle')
                .attr('font-size', '28px')
                .attr('fill', '#2ecc71')
                .text(`f'(${currentX.toFixed(1)}) = ${slope.toFixed(2)}`);

            if (globalAnimationPlaying) {
                registerAnimation(updateDerivative, requestAnimationFrame(updateDerivative));
            }
        }

        updateDerivative();
    }


    // 第7页
function visualizePhysics() {
    const setup = setupD3('vis-physics');
    if (!setup) return;
    const { g, width, height } = setup;

    // 创建三个图表
    const charts = [
        { title: '位移 s(t)', y: 0, color: '#3498db' },
        { title: '速度 v(t)', y: height/3, color: '#2ecc71' },
        { title: '加速度 a(t)', y: 2*height/3, color: '#e74c3c' }
    ];

    const xScale = d3.scaleLinear().domain([0, 5]).range([60, width - 20]);
    const yScales = charts.map(() => 
        d3.scaleLinear().domain([-10, 10]).range([height/3 - 30, 30])
    );

    charts.forEach((chart, i) => {
        const chartG = g.append('g')
            .attr('transform', `translate(0, ${chart.y})`);

        // 背景
        chartG.append('rect')
            .attr('x', 5)
            .attr('y', 5)
            .attr('width', width - 10)
            .attr('height', height/3 - 10)
            .attr('fill', 'rgba(71, 85, 105, 0.3)')
            .attr('rx', 5);

        // 标题
        chartG.append('text')
            .attr('x', 15)
            .attr('y', 25)
            .attr('font-size', '16px')
            .attr('font-weight', 'bold')
            .attr('fill', chart.color)
            .text(chart.title);

        // 坐标轴
        chartG.append('line')
            .attr('x1', xScale(0))
            .attr('x2', xScale(5))
            .attr('y1', yScales[i](0))
            .attr('y2', yScales[i](0))
            .attr('stroke', 'rgba(255, 255, 255, 0.3)')
            .attr('stroke-width', 1);
    });

    // 绘制函数
    const time = d3.range(0, 5.1, 0.05);
    
    // 位移: s(t) = t^2 - 2t
    const position = t => t * t - 2 * t;
    // 速度: v(t) = 2t - 2
    const velocity = t => 2 * t - 2;
    // 加速度: a(t) = 2
    const acceleration = t => 2;

    const functions = [position, velocity, acceleration];
    
    const line = d3.line()
        .x(d => xScale(d))
        .y((d, i) => yScales[Math.floor(i / time.length)](functions[Math.floor(i / time.length)](d)))
        .curve(d3.curveMonotoneX);

    // 绘制每个函数
    functions.forEach((func, i) => {
        const data = time.map(t => ({ t, value: func(t) }));
        
        const chartG = g.append('g')
            .attr('transform', `translate(0, ${charts[i].y})`);

        const pathLine = d3.line()
            .x(d => xScale(d.t))
            .y(d => yScales[i](d.value))
            .curve(d3.curveMonotoneX);

        const path = chartG.append('path')
            .datum(data)
            .attr('d', pathLine)
            .attr('fill', 'none')
            .attr('stroke', charts[i].color)
            .attr('stroke-width', 3);

        // 动画绘制
        const totalLength = path.node().getTotalLength();
        path
            .attr('stroke-dasharray', totalLength + ' ' + totalLength)
            .attr('stroke-dashoffset', totalLength)
            .transition()
            .delay(i * 500)
            .duration(1500)
            .attr('stroke-dashoffset', 0);
    });

    // 添加移动的点来显示关系
    const movingPointG = g.append('g');
    
    const points = charts.map((chart, i) => {
        return movingPointG.append('circle')
            .attr('r', 6)
            .attr('fill', chart.color)
            .attr('stroke', themeColors.axis)
            .attr('stroke-width', 2)
            .style('filter', 'drop-shadow(0 2px 4px rgba(15, 23, 42, 0.2))');
    });

    // 值显示面板
    const valuePanel = g.append('g')
        .attr('transform', `translate(${width - 150}, 10)`);

    valuePanel.append('rect')
        .attr('width', 140)
        .attr('height', 100)
        .attr('fill', 'rgba(71, 85, 105, 0.85)')
        .attr('rx', 8);

    const timeText = valuePanel.append('text')
        .attr('x', 70)
        .attr('y', 25)
        .attr('text-anchor', 'middle')
        .attr('font-size', '14px')
        .attr('fill', '#f8fafc'); // Changed for better contrast

    const valueTexts = charts.map((chart, i) => {
        return valuePanel.append('text')
            .attr('x', 10)
            .attr('y', 45 + i * 20)
            .attr('font-size', '12px')
            .attr('fill', chart.color);
    });

    // 动画
    let currentT = 0;
    function animate() {
        if (!globalAnimationPlaying) {
            registerAnimation(animate, requestAnimationFrame(animate));
            return;
        }

        currentT = (currentT + 0.01 / globalAnimationSpeed) % 5;
        
        const s = position(currentT);
        const v = velocity(currentT);
        const a = acceleration(currentT);
        
        points[0].attr('cx', xScale(currentT)).attr('cy', yScales[0](s) + charts[0].y);
        points[1].attr('cx', xScale(currentT)).attr('cy', yScales[1](v) + charts[1].y);
        points[2].attr('cx', xScale(currentT)).attr('cy', yScales[2](a) + charts[2].y);
        
        timeText.text(`t = ${currentT.toFixed(2)} s`);
        valueTexts[0].text(`s = ${s.toFixed(2)} m`);
        valueTexts[1].text(`v = ${v.toFixed(2)} m/s`);
        valueTexts[2].text(`a = ${a.toFixed(2)} m/s²`);
        
        registerAnimation(animate, requestAnimationFrame(animate));
    }
    
    setTimeout(() => animate(), 2000);
}

// 统一目录：不再创建自定义浮动目录

// 添加触摸支持
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;

document.addEventListener('touchstart', function(e) {
    touchStartX = e.changedTouches[0].screenX;
    touchStartY = e.changedTouches[0].screenY;
}, false);

document.addEventListener('touchend', function(e) {
    touchEndX = e.changedTouches[0].screenX;
    touchEndY = e.changedTouches[0].screenY;
    handleSwipe();
}, false);

function handleSwipe() {
    const swipeThreshold = 50;
    const verticalThreshold = 100;
    
    const deltaX = touchEndX - touchStartX;
    const deltaY = Math.abs(touchEndY - touchStartY);
    
    // 确保是水平滑动而不是垂直滚动
    if (deltaY < verticalThreshold) {
        if (deltaX < -swipeThreshold) {
            nextSlide();
        } else if (deltaX > swipeThreshold) {
            previousSlide();
        }
    }
}

// 优化动画性能
function optimizeAnimations() {
    // 使用 will-change 属性优化动画元素
    const animatedElements = document.querySelectorAll('.function-path, .tangent-line, .point-marker');
    animatedElements.forEach(el => {
        el.style.willChange = 'transform, opacity';
    });
}

// 添加自适应功能
function handleResize() {
    // 重新渲染当前页面的可视化
    runVisualization(currentSlide);
}

window.addEventListener('resize', debounce(handleResize, 300));

// 防抖函数
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// 预加载资源
function preloadResources() {
    // 预加载下一页的内容 - 已移除冗余的MathJax预渲染以提高性能
    // MathJax渲染现在按需进行，避免重复渲染
    if (currentSlide < totalSlides - 1) {
        const nextSlideIndex = currentSlide + 1;
        // 可选：预渲染下一页的可视化内容（如果需要）
        // 这会减少切换页面时的延迟
    }
}

// （已移除）加载指示器相关逻辑

// 初始化增强功能
document.addEventListener('DOMContentLoaded', function() {
    optimizeAnimations();
    preloadResources();
});

// 添加学习进度保存功能
function saveProgress() {
    const progress = {
        currentSlide: currentSlide,
        pageViewTimes: pageViewTimes,
        lastVisit: new Date().toISOString()
    };
    // 注意：由于浏览器限制，这里只是示例代码
    console.log('学习进度已保存:', progress);
}

// 定期保存进度
setInterval(saveProgress, 30000); // 每30秒保存一次

// 页面卸载时保存进度
window.addEventListener('beforeunload', saveProgress);

// 添加全屏功能
// （已移除）全屏功能与按钮

// 性能监控
function monitorPerformance() {
    if (window.performance && window.performance.memory) {
        const memoryInfo = window.performance.memory;
        const usedMemory = (memoryInfo.usedJSHeapSize / 1048576).toFixed(2);
        const totalMemory = (memoryInfo.totalJSHeapSize / 1048576).toFixed(2);
        console.log(`内存使用: ${usedMemory} MB / ${totalMemory} MB`);
    }
}

// 定期监控性能
setInterval(monitorPerformance, 10000);

// 优化SVG渲染
function optimizeSVGRendering() {
    const svgElements = document.querySelectorAll('svg');
    svgElements.forEach(svg => {
        svg.style.shapeRendering = 'optimizeSpeed';
        svg.style.imageRendering = 'optimizeSpeed';
    });
}

// 添加错误处理
window.addEventListener('error', function(e) {
    console.error('发生错误:', e.error);
    // 可以添加用户友好的错误提示
});

// 添加平滑滚动效果
document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function(e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if (target) {
            target.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
            });
        }
    });
});


// 过渡页可视化（轻量动态，防空白）
function visualizeTransition(containerId, accentColor) {
    const setup = setupD3(containerId, { top: 20, right: 20, bottom: 20, left: 20 });
    if (!setup) return;
    const { g, width, height } = setup;

    const cx = width * 0.5;
    const cy = height * 0.5;
    const base = Math.min(width, height);

    // 同心脉冲圈
    const rings = [0.22, 0.36, 0.50].map(r => base * r);
    g.selectAll('circle.ring')
        .data(rings)
        .enter()
        .append('circle')
        .attr('class', 'ring')
        .attr('cx', cx)
        .attr('cy', cy)
        .attr('r', d => d)
        .attr('fill', 'none')
        .attr('stroke', accentColor)
        .attr('stroke-opacity', 0.14)
        .attr('stroke-width', 2)
        .each(function(_, i) {
            const self = d3.select(this);
            function loop() {
                if (!globalAnimationPlaying) {
                    registerAnimation(loop, requestAnimationFrame(loop));
                    return;
                }
                self
                    .attr('stroke-opacity', 0.14)
                    .transition()
                    .duration(1600 + i * 200)
                    .ease(d3.easeSinInOut)
                    .attr('stroke-opacity', 0.34)
                    .transition()
                    .duration(1600 + i * 200)
                    .ease(d3.easeSinInOut)
                    .attr('stroke-opacity', 0.14)
                    .on('end', loop);
            }
            loop();
        });

    // 环绕粒子
    const dotCount = 28;
    const dots = d3.range(dotCount).map(i => ({
        angle: (Math.PI * 2 * i) / dotCount,
        radius: rings[1] * (0.85 + Math.random() * 0.15),
        speed: 0.003 + Math.random() * 0.006
    }));

    const dotSel = g.selectAll('circle.dot')
        .data(dots)
        .enter()
        .append('circle')
        .attr('class', 'dot')
        .attr('r', 3)
        .attr('fill', accentColor)
        .attr('fill-opacity', 0.7);

    function tick() {
        if (!globalAnimationPlaying) {
            registerAnimation(tick, requestAnimationFrame(tick));
            return;
        }
        dots.forEach(d => { d.angle += d.speed * 0.016; });
        dotSel
            .attr('cx', d => cx + Math.cos(d.angle) * d.radius)
            .attr('cy', d => cy + Math.sin(d.angle) * d.radius)
            .attr('fill-opacity', d => 0.5 + 0.5 * Math.sin(d.angle * 2));
        registerAnimation(tick, requestAnimationFrame(tick));
    }
    tick();
}

function visualizeTrans1() { visualizeTransition('vis-trans-1', '#3b82f6'); }
function visualizeTrans2() { visualizeTransition('vis-trans-2', '#10b981'); }
function visualizeTrans3() { visualizeTransition('vis-trans-3', '#f59e0b'); }
function visualizeTrans4() { visualizeTransition('vis-trans-4', '#8b5cf6'); }
function visualizeTrans5() { visualizeTransition('vis-trans-5', '#ef4444'); }
function visualizeTrans6() { visualizeTransition('vis-trans-6', '#6b7280'); }

</script>
</body>
</html>
