<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lab 6.1 定积分概念：从分割到求和</title>
    <!-- 本地化资源 -->
    <script src="../common-assets/js/tailwind.min.js"></script>
    <link rel="stylesheet" href="../common-assets/css/lab1-material-symbols.css">
    <script>
        MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            svg: { fontCache: 'global' }
        };
    </script>
    <script id="MathJax-script" async src="../common-assets/js/mathjax-3.2.2-tex-svg.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; }
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%;
            background: #4f46e5; cursor: pointer; margin-top: -8px; box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #d1d5db; border-radius: 2px;
        }
        .active-tab { background-color: #e0e7ff; color: #4338ca; border-left: 4px solid #4f46e5; }
        canvas { touch-action: none; }
        
        /* 修复 MathJax 在 Tailwind 下的显示问题 */
        /* Tailwind 将 svg 设为 block，导致内联公式换行。这里强制设回 inline */
        mjx-container[display="false"] svg { 
            display: inline-block !important; 
            vertical-align: middle !important; 
        }
        mjx-container[display="false"] {
            display: inline-block !important;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden text-gray-800 bg-gray-100">
    <header class="bg-white shadow-sm z-10 flex-none h-16 flex items-center px-6 justify-between">
        <div class="flex items-center gap-3">
            <span class="material-symbols-outlined text-indigo-600 text-3xl">functions</span>
            <div>
                <h1 class="text-xl font-bold text-gray-800">定积分概念实验室</h1>
                <p class="text-xs text-gray-500">Lab 6.1 曲边梯形与黎曼和</p>
            </div>
        </div>
        <div class="text-sm text-gray-600 bg-gray-100 px-3 py-1 rounded-full hidden md:block">
            <span class="font-bold text-indigo-600">目标：</span> 理解"分割、近似、求和、取极限"的思想
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <nav class="w-64 bg-white border-r border-gray-200 flex-none flex-col py-4 overflow-y-auto hidden md:flex">
            <div class="px-4 mb-2 text-xs font-semibold text-gray-400 uppercase tracking-wider">学习步骤</div>
            <button onclick="setStep('scenario')" id="btn-scenario" class="w-full text-left px-6 py-4 hover:bg-gray-50 transition-colors border-l-4 flex items-center gap-3 active-tab">
                <span class="material-symbols-outlined">landscape</span>
                <div><div class="font-medium">1. 问题引入</div><div class="text-xs text-gray-500">不规则图形怎么算面积？</div></div>
            </button>
            <button onclick="setStep('definition')" id="btn-definition" class="w-full text-left px-6 py-4 hover:bg-gray-50 transition-colors border-l-4 border-transparent flex items-center gap-3">
                <span class="material-symbols-outlined">architecture</span>
                <div><div class="font-medium">2. 什么是曲边梯形</div><div class="text-xs text-gray-500">几何特征与边界定义</div></div>
            </button>
            <button onclick="setStep('experiment')" id="btn-experiment" class="w-full text-left px-6 py-4 hover:bg-gray-50 transition-colors border-l-4 border-transparent flex items-center gap-3">
                <span class="material-symbols-outlined">bar_chart</span>
                <div><div class="font-medium">3. 黎曼和实验</div><div class="text-xs text-gray-500">以直代曲，逼近真值</div></div>
            </button>
            <button onclick="setStep('limit')" id="btn-limit" class="w-full text-left px-6 py-4 hover:bg-gray-50 transition-colors border-l-4 border-transparent flex items-center gap-3">
                <span class="material-symbols-outlined">all_inclusive</span>
                <div><div class="font-medium">4. 从近似到精确</div><div class="text-xs text-gray-500">极限与定积分定义</div></div>
            </button>
        </nav>

        <main class="flex-1 bg-gray-50 p-6 overflow-y-auto relative">
            <!-- 场景 1: 问题引入 -->
            <div id="view-scenario" class="max-w-5xl mx-auto space-y-6">
                <div class="bg-white rounded-2xl p-8 shadow-sm border border-gray-100">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4 flex items-center gap-2">
                        <span class="material-symbols-outlined text-yellow-500">lightbulb</span> 工程问题：计算草坪面积
                    </h2>
                    <p class="text-lg text-gray-600 mb-6 leading-relaxed">
                        学校计划在图书馆前铺设一块形状不规则的草坪（如下图深绿色区域）。这块地的一边是直的（路边），另一边是弯曲的景观线。
                        <br>作为工程造价员，<strong>我们没有直接计算这种"弯曲形状"面积的公式</strong>。
                        <br>你能想到什么办法来估算它的面积，以便采购草皮吗？
                    </p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                        <!-- FIX: Added absolute positioning here for safety too -->
                        <div class="relative bg-gray-100 rounded-xl overflow-hidden shadow-inner border border-gray-200 aspect-video flex items-center justify-center">
                            <canvas id="scenarioCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
                        </div>
                        <div class="space-y-4">
                            <div class="p-4 bg-indigo-50 rounded-xl border border-indigo-100">
                                <h3 class="font-bold text-indigo-700 mb-2">思考方向</h3>
                                <ul class="list-disc list-inside text-gray-700 space-y-2">
                                    <li>如果是矩形，我们会算：$\text{长} \times \text{宽}$。</li>
                                    <li>如果是三角形，我们也会算。</li>
                                    <li>但这有一条边是<strong>曲线</strong>。</li>
                                    <li><strong>思路：</strong>能不能把它切成我们熟悉的长条形？</li>
                                </ul>
                            </div>
                            <button onclick="setStep('definition')" class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-semibold shadow-lg transition-transform active:scale-95 flex items-center justify-center gap-2">
                                下一步：将图形数学化 <span class="material-symbols-outlined">arrow_forward</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 场景 2: 曲边梯形定义 -->
            <div id="view-definition" class="max-w-5xl mx-auto space-y-6 hidden">
                <div class="bg-white rounded-2xl p-8 shadow-sm border border-gray-100">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">数学抽象：曲边梯形</h2>
                    <p class="text-gray-600 mb-6">我们将刚才的草坪放入直角坐标系中。这个图形在数学上有一个专门的名字，叫<strong>曲边梯形</strong>。它由四条线围成：</p>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div class="col-span-2 bg-white border border-gray-200 rounded-xl p-2 shadow-inner relative" style="min-height:300px">
                             <!-- FIX: Added absolute positioning here for safety too -->
                            <canvas id="defCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
                        </div>
                        <div class="flex flex-col gap-3 justify-center">
                            <div class="group p-3 rounded-lg border border-transparent hover:bg-blue-50 hover:border-blue-200 transition-all cursor-pointer" onmouseover="highlightBorder('top')" onmouseout="highlightBorder('none')">
                                <div class="flex items-center gap-2"><span class="w-4 h-4 rounded-full bg-blue-500"></span><span class="font-bold text-gray-700">上底 (曲边)</span></div>
                                <div class="text-sm text-gray-500 pl-6">函数 $y = f(x)$</div>
                            </div>
                            <div class="group p-3 rounded-lg border border-transparent hover:bg-gray-100 hover:border-gray-300 transition-all cursor-pointer" onmouseover="highlightBorder('bottom')" onmouseout="highlightBorder('none')">
                                <div class="flex items-center gap-2"><span class="w-4 h-4 rounded-full bg-gray-800"></span><span class="font-bold text-gray-700">下底 (直边)</span></div>
                                <div class="text-sm text-gray-500 pl-6">x轴区间 $[a, b]$</div>
                            </div>
                            <div class="group p-3 rounded-lg border border-transparent hover:bg-red-50 hover:border-red-200 transition-all cursor-pointer" onmouseover="highlightBorder('sides')" onmouseout="highlightBorder('none')">
                                <div class="flex items-center gap-2"><span class="w-4 h-4 rounded-full bg-red-500"></span><span class="font-bold text-gray-700">两侧 (垂线)</span></div>
                                <div class="text-sm text-gray-500 pl-6">直线 $x=a$ 和 $x=b$</div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 text-center">
                        <button onclick="setStep('experiment')" class="px-8 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-semibold shadow-lg transition-transform active:scale-95 inline-flex items-center gap-2">
                            开始求解面积 <span class="material-symbols-outlined">arrow_forward</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- 场景 3: 黎曼和实验 -->
            <div id="view-experiment" class="max-w-6xl mx-auto space-y-4 hidden">
                <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
                    <div class="lg:col-span-4 space-y-4">
                        <div class="bg-white rounded-xl p-6 shadow-sm border border-gray-100">
                            <h3 class="font-bold text-lg mb-4 text-gray-800 border-b pb-2">1. 分割 (Partition)</h3>
                            <p class="text-sm text-gray-600 mb-4">把底边 $[a, b]$ 切成 $n$ 个小段，用矩形来代替曲边梯形。</p>
                            <div class="mb-6">
                                <div class="flex justify-between mb-2">
                                    <label class="font-semibold text-gray-700">矩形数量 (n)</label>
                                    <span class="bg-indigo-100 text-indigo-700 px-2 py-0.5 rounded text-sm font-bold" id="n-display">5</span>
                                </div>
                                <input type="range" id="n-slider" min="2" max="50" step="1" value="5" class="w-full">
                                <div class="flex justify-between text-xs text-gray-400 mt-1"><span>粗糙</span><span>精细</span></div>
                            </div>
                            <h3 class="font-bold text-lg mb-4 text-gray-800 border-b pb-2">2. 近似 (Approx)</h3>
                            <p class="text-sm text-gray-600 mb-3">矩形的高度怎么定？</p>
                            <div class="flex gap-2 mb-2">
                                <button onclick="setMethod('left')" class="method-btn flex-1 py-2 text-sm border rounded-lg bg-indigo-50 border-indigo-200 text-indigo-700 font-medium">左端点</button>
                                <button onclick="setMethod('right')" class="method-btn flex-1 py-2 text-sm border rounded-lg bg-white border-gray-200 text-gray-600 hover:bg-gray-50">右端点</button>
                            </div>
                        </div>
                        <div class="bg-white rounded-xl p-6 shadow-sm border border-gray-100">
                            <h3 class="font-bold text-lg mb-3 text-gray-800 flex items-center gap-2">
                                <span class="material-symbols-outlined text-green-500">calculate</span> 数据分析
                            </h3>
                            <div class="space-y-3 text-sm">
                                <div class="flex justify-between items-center border-b border-gray-100 pb-2">
                                    <span class="text-gray-500">每个矩形宽度 ($\Delta x$)</span>
                                    <span class="font-mono font-bold" id="data-dx">0.00</span>
                                </div>
                                <div class="flex justify-between items-center border-b border-gray-100 pb-2">
                                    <span class="text-gray-500">所有矩形面积和 ($S_n$)</span>
                                    <span class="font-mono font-bold text-indigo-600 text-lg" id="data-sum">0.00</span>
                                </div>
                                <div class="flex justify-between items-center bg-red-50 p-2 rounded">
                                    <span class="text-red-600">误差 (Error)</span>
                                    <span class="font-mono font-bold text-red-600" id="data-error">0.00</span>
                                </div>
                            </div>
                            <p class="text-xs text-gray-400 mt-3">* 真实面积约为 11.333</p>
                        </div>
                    </div>
                    <div class="lg:col-span-8 space-y-4">
                        <div class="bg-white rounded-xl p-4 shadow-sm border border-gray-100 h-full flex flex-col">
                            <div class="flex justify-between items-center mb-2">
                                <h3 class="font-bold text-gray-700">图形演示</h3>
                                <div class="flex items-center gap-4 text-xs">
                                    <div class="flex items-center gap-1"><span class="w-3 h-3 bg-indigo-200 border border-indigo-400"></span> 矩形近似面积</div>
                                    <div class="flex items-center gap-1"><span class="w-3 h-3 bg-red-400"></span> 误差区域</div>
                                </div>
                            </div>
                            <!-- MAJOR FIX: Added 'absolute top-0 left-0' to canvas to prevent infinite growth loop -->
                            <div class="flex-1 relative bg-white border rounded-lg overflow-hidden w-full" style="min-height:400px">
                                <canvas id="mainCanvas" class="absolute top-0 left-0 w-full h-full"></canvas>
                                <div id="overlay-msg" class="absolute top-4 left-4 bg-white/90 backdrop-blur px-4 py-2 rounded-lg shadow border border-gray-200 text-sm hidden pointer-events-none">
                                    <span class="font-bold text-indigo-600">n 增大</span> → 矩形越瘦 → 误差越小
                                </div>
                            </div>
                            <div class="mt-4 p-4 bg-yellow-50 text-yellow-800 rounded-lg text-sm flex items-start gap-3 flex-none">
                                <span class="material-symbols-outlined text-yellow-600 shrink-0">info</span>
                                <div><strong>核心发现：</strong>当分割的数量 $n$ 越来越多（$n \to \infty$）时，红色误差区域会越来越小，最后趋近于 0。</div>
                            </div>
                        </div>
                        <div class="text-right">
                            <button onclick="setStep('limit')" class="px-6 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-semibold shadow transition-colors inline-flex items-center gap-2">
                                总结结论 <span class="material-symbols-outlined">arrow_forward</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 场景 4: 极限与定积分定义 -->
            <div id="view-limit" class="max-w-4xl mx-auto space-y-6 hidden">
                <div class="bg-white rounded-2xl p-8 shadow-sm border border-gray-100 text-center">
                    <div class="w-16 h-16 bg-indigo-100 rounded-full flex items-center justify-center mx-auto mb-6">
                        <span class="material-symbols-outlined text-indigo-600 text-3xl">done_all</span>
                    </div>
                    <h2 class="text-2xl font-bold text-gray-800 mb-6">从"近似"到"精确"</h2>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8">
                        <div class="p-4 bg-gray-50 rounded-xl">
                            <div class="text-gray-500 text-sm mb-2">第1步：分割</div>
                            <div class="font-bold">$\Delta x = \dfrac{b-a}{n}$</div>
                        </div>
                        <div class="p-4 bg-gray-50 rounded-xl">
                            <div class="text-gray-500 text-sm mb-2">第2步：求和</div>
                            <div class="font-bold">$\sum_{i=1}^{n} f(\xi_i) \Delta x$</div>
                        </div>
                        <div class="p-4 bg-indigo-50 rounded-xl border border-indigo-100">
                            <div class="text-indigo-600 text-sm mb-2">第3步：取极限</div>
                            <div class="font-bold text-indigo-700">$\lim_{n \to \infty}$ <br><span class="text-xs font-normal text-indigo-500">(或 $\Delta x \to 0$)</span></div>
                        </div>
                    </div>
                    <p class="text-gray-600 mb-8">当分割无限细密（$n \to \infty$）时，所有矩形的面积之和，就是曲边梯形的<strong>精确面积</strong>。数学上用一个专用符号来表示这个极限值：</p>
                    <div class="bg-gray-900 text-white p-8 rounded-2xl shadow-xl mb-8 relative overflow-hidden">
                        <div class="absolute top-0 right-0 opacity-10 transform translate-x-10 -translate-y-10">
                            <span class="material-symbols-outlined text-9xl">functions</span>
                        </div>
                        <div class="text-2xl md:text-3xl">
                            $$\int_a^b f(x)\,dx = \lim_{n \to \infty} \sum_{i=1}^{n} f(\xi_i) \Delta x$$
                        </div>
                        <div class="mt-6 flex flex-wrap justify-center gap-6 text-sm text-gray-400 font-mono">
                            <div>$\int$ : 拉长的S (Sum)</div>
                            <div>$a, b$ : 积分上下限</div>
                            <div>$f(x)$ : 被积函数</div>
                            <div>$dx$ : 无穷小的底边</div>
                        </div>
                    </div>
                    <button onclick="setStep('scenario')" class="px-6 py-2 border border-gray-300 hover:bg-gray-50 text-gray-700 rounded-lg transition-colors">返回重新开始</button>
                </div>
            </div>
        </main>
    </div>

    <script>
        const config = { a: 0, b: 4, f: x => 0.1 * x * x + 1, F: x => (0.1/3) * Math.pow(x, 3) + x };
        const trueArea = config.F(config.b) - config.F(config.a);
        let state = { step: 'scenario', n: 5, method: 'left', highlightDef: 'none' };

        function setStep(stepId) {
            state.step = stepId;
            document.querySelectorAll('nav button').forEach(btn => { btn.classList.remove('active-tab'); btn.classList.add('border-transparent'); });
            const activeBtn = document.getElementById(`btn-${stepId}`);
            if (activeBtn) { activeBtn.classList.add('active-tab'); activeBtn.classList.remove('border-transparent'); }
            ['scenario', 'definition', 'experiment', 'limit'].forEach(id => document.getElementById(`view-${id}`).classList.add('hidden'));
            document.getElementById(`view-${stepId}`).classList.remove('hidden');
            setTimeout(() => {
                if (stepId === 'scenario') drawScenario();
                if (stepId === 'definition') drawDefinition();
                if (stepId === 'experiment') updateExperiment();
                if (typeof MathJax !== 'undefined') MathJax.typeset();
            }, 50);
        }

        function setupCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            // Set actual canvas size (pixels)
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            // Normalize coordinate system
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            return { ctx, width: rect.width, height: rect.height };
        }

        function toCanvas(x, y, width, height) {
            const margin = { left: 50, right: 30, top: 30, bottom: 40 };
            const drawW = width - margin.left - margin.right, drawH = height - margin.top - margin.bottom;
            const xMin = config.a - 0.5, xMax = config.b + 0.5, yMin = 0, yMax = config.f(config.b) + 0.5;
            return { x: margin.left + ((x - xMin) / (xMax - xMin)) * drawW, y: height - margin.bottom - ((y - yMin) / (yMax - yMin)) * drawH };
        }

        function drawAxes(ctx, width, height) {
            const origin = toCanvas(0, 0, width, height);
            ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(30, origin.y); ctx.lineTo(width - 20, origin.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(origin.x, height - 20); ctx.lineTo(origin.x, 20); ctx.stroke();
            ctx.font = '14px sans-serif'; ctx.fillStyle = '#6b7280';
            ctx.fillText('x', width - 20, origin.y + 15); ctx.fillText('y', origin.x - 20, 20);
        }

        function drawFunctionCurve(ctx, width, height, color = '#4f46e5', lineWidth = 2) {
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = lineWidth;
            for (let x = -0.5; x <= config.b + 0.5; x += 0.05) {
                const pt = toCanvas(x, config.f(x), width, height);
                x === -0.5 ? ctx.moveTo(pt.x, pt.y) : ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
        }

        function drawScenario() {
            const { ctx, width, height } = setupCanvas('scenarioCanvas');
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#f0fdf4'; ctx.fillRect(0, 0, width, height);
            ctx.beginPath();
            const start = toCanvas(config.a, 0, width, height);
            ctx.moveTo(start.x, start.y);
            for (let x = config.a; x <= config.b; x += 0.05) ctx.lineTo(toCanvas(x, 0, width, height).x, toCanvas(x, 0, width, height).y);
            ctx.lineTo(toCanvas(config.b, config.f(config.b), width, height).x, toCanvas(config.b, config.f(config.b), width, height).y);
            for (let x = config.b; x >= config.a; x -= 0.05) ctx.lineTo(toCanvas(x, config.f(x), width, height).x, toCanvas(x, config.f(x), width, height).y);
            ctx.closePath();
            ctx.fillStyle = '#4ade80'; ctx.fill();
            ctx.lineWidth = 2; ctx.strokeStyle = '#166534'; ctx.stroke();
            ctx.fillStyle = '#166534'; ctx.font = '14px sans-serif';
            ctx.fillText('路边 (直)', start.x + 20, start.y + 18);
            ctx.fillText('景观线 (曲)', start.x + 40, start.y - 80);
            ctx.fillText('?', start.x + 100, start.y - 40);
        }

        function drawDefinition() {
            const { ctx, width, height } = setupCanvas('defCanvas');
            ctx.clearRect(0, 0, width, height);
            drawAxes(ctx, width, height);
            const aPt0 = toCanvas(config.a, 0, width, height), bPt0 = toCanvas(config.b, 0, width, height);
            const aPtTop = toCanvas(config.a, config.f(config.a), width, height), bPtTop = toCanvas(config.b, config.f(config.b), width, height);
            ctx.beginPath(); ctx.moveTo(aPt0.x, aPt0.y); ctx.lineTo(bPt0.x, bPt0.y); ctx.lineTo(bPtTop.x, bPtTop.y);
            for (let x = config.b; x >= config.a; x -= 0.05) ctx.lineTo(toCanvas(x, config.f(x), width, height).x, toCanvas(x, config.f(x), width, height).y);
            ctx.closePath(); ctx.fillStyle = 'rgba(79, 70, 229, 0.1)'; ctx.fill();

            ctx.beginPath(); ctx.moveTo(aPt0.x, aPt0.y); ctx.lineTo(bPt0.x, bPt0.y);
            ctx.strokeStyle = state.highlightDef === 'bottom' ? '#1f2937' : 'rgba(0,0,0,0.2)'; ctx.lineWidth = state.highlightDef === 'bottom' ? 4 : 2; ctx.stroke();
            ctx.fillStyle = '#374151'; ctx.font = 'bold 14px sans-serif'; ctx.fillText('a', aPt0.x - 5, aPt0.y + 20); ctx.fillText('b', bPt0.x - 5, bPt0.y + 20);

            ctx.beginPath(); ctx.moveTo(aPt0.x, aPt0.y); ctx.lineTo(aPtTop.x, aPtTop.y); ctx.moveTo(bPt0.x, bPt0.y); ctx.lineTo(bPtTop.x, bPtTop.y);
            ctx.strokeStyle = state.highlightDef === 'sides' ? '#ef4444' : 'rgba(0,0,0,0.2)'; ctx.lineWidth = state.highlightDef === 'sides' ? 4 : 2;
            if (state.highlightDef === 'sides') ctx.setLineDash([5, 3]); ctx.stroke(); ctx.setLineDash([]);

            ctx.beginPath();
            for (let x = config.a; x <= config.b; x += 0.05) { const pt = toCanvas(x, config.f(x), width, height); x === config.a ? ctx.moveTo(pt.x, pt.y) : ctx.lineTo(pt.x, pt.y); }
            ctx.strokeStyle = state.highlightDef === 'top' ? '#3b82f6' : '#4f46e5'; ctx.lineWidth = state.highlightDef === 'top' ? 4 : 2; ctx.stroke();
        }

        function highlightBorder(part) { state.highlightDef = part; drawDefinition(); }

        function setMethod(m) {
            state.method = m;
            document.querySelectorAll('.method-btn').forEach(btn => { btn.classList.remove('bg-indigo-50', 'text-indigo-700', 'border-indigo-200'); btn.classList.add('bg-white', 'text-gray-600', 'border-gray-200'); });
            event.target.classList.remove('bg-white', 'text-gray-600', 'border-gray-200');
            event.target.classList.add('bg-indigo-50', 'text-indigo-700', 'border-indigo-200');
            updateExperiment();
        }

        document.getElementById('n-slider').addEventListener('input', e => {
            state.n = parseInt(e.target.value);
            document.getElementById('n-display').innerText = state.n;
            const msg = document.getElementById('overlay-msg'); msg.classList.remove('hidden'); setTimeout(() => msg.classList.add('hidden'), 1500);
            updateExperiment();
        });

        function updateExperiment() {
            const { ctx, width, height } = setupCanvas('mainCanvas');
            ctx.clearRect(0, 0, width, height);
            drawAxes(ctx, width, height);
            drawFunctionCurve(ctx, width, height, '#9ca3af', 1);
            const dx = (config.b - config.a) / state.n;
            let sumArea = 0;
            for (let i = 0; i < state.n; i++) {
                const xLeft = config.a + i * dx, xRight = xLeft + dx;
                const xSample = state.method === 'left' ? xLeft : xRight;
                const h = config.f(xSample);
                sumArea += h * dx;
                const p1 = toCanvas(xLeft, 0, width, height), p2 = toCanvas(xRight, h, width, height);
                const rectW = p2.x - p1.x, rectH = p1.y - p2.y;
                ctx.fillStyle = 'rgba(99, 102, 241, 0.2)'; ctx.fillRect(p1.x, p2.y, rectW, rectH);
                ctx.strokeStyle = 'rgba(99, 102, 241, 0.8)'; ctx.lineWidth = 1; ctx.strokeRect(p1.x, p2.y, rectW, rectH);
                ctx.beginPath(); ctx.fillStyle = 'rgba(239, 68, 68, 0.5)';
                if (state.method === 'left') {
                    ctx.moveTo(toCanvas(xLeft, h, width, height).x, toCanvas(xLeft, h, width, height).y);
                    ctx.lineTo(toCanvas(xRight, h, width, height).x, toCanvas(xRight, h, width, height).y);
                    ctx.lineTo(toCanvas(xRight, config.f(xRight), width, height).x, toCanvas(xRight, config.f(xRight), width, height).y);
                    for (let x = xRight; x >= xLeft; x -= 0.05) ctx.lineTo(toCanvas(x, config.f(x), width, height).x, toCanvas(x, config.f(x), width, height).y);
                } else {
                    ctx.moveTo(toCanvas(xLeft, config.f(xLeft), width, height).x, toCanvas(xLeft, config.f(xLeft), width, height).y);
                    ctx.lineTo(toCanvas(xLeft, h, width, height).x, toCanvas(xLeft, h, width, height).y);
                    ctx.lineTo(toCanvas(xRight, h, width, height).x, toCanvas(xRight, h, width, height).y);
                    for (let x = xRight; x >= xLeft; x -= 0.05) ctx.lineTo(toCanvas(x, config.f(x), width, height).x, toCanvas(x, config.f(x), width, height).y);
                }
                ctx.fill();
            }
            document.getElementById('data-dx').innerText = dx.toFixed(4);
            document.getElementById('data-sum').innerText = sumArea.toFixed(4);
            const error = sumArea - trueArea;
            document.getElementById('data-error').innerText = (error > 0 ? "+" : "") + error.toFixed(4);
        }

        window.addEventListener('load', () => setStep('scenario'));
        window.addEventListener('resize', () => { if (state.step === 'scenario') drawScenario(); if (state.step === 'definition') drawDefinition(); if (state.step === 'experiment') updateExperiment(); });
    </script>
</body>
</html>
